/*
Navicat MySQL Data Transfer

Source Server         : 本地
Source Server Version : 50717
Source Host           : localhost:3306
Source Database       : ctest2

Target Server Type    : MYSQL
Target Server Version : 50717
File Encoding         : 65001

Date: 2018-04-23 18:36:49
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for collection
-- ----------------------------
DROP TABLE IF EXISTS `collection`;
CREATE TABLE `collection` (
  `id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `exercise_id` mediumint(8) NOT NULL,
  `username` varchar(16) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of collection
-- ----------------------------
INSERT INTO `collection` VALUES ('7', '11', 'szl');
INSERT INTO `collection` VALUES ('8', '21', 'szl');
INSERT INTO `collection` VALUES ('9', '1', 'szl');
INSERT INTO `collection` VALUES ('14', '58', 'suzelin');
INSERT INTO `collection` VALUES ('15', '90', 'suzelin');
INSERT INTO `collection` VALUES ('21', '5', 'suzelin');
INSERT INTO `collection` VALUES ('24', '58', 'lifengxia');

-- ----------------------------
-- Table structure for course
-- ----------------------------
DROP TABLE IF EXISTS `course`;
CREATE TABLE `course` (
  `id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT NULL,
  `start_date` date DEFAULT NULL,
  `end_date` date DEFAULT NULL,
  `introduce` varchar(2048) DEFAULT NULL,
  `img_url` varchar(255) DEFAULT NULL,
  `teacher_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of course
-- ----------------------------
INSERT INTO `course` VALUES ('1', 'C语言程序设计', '2014-05-22', '2014-09-01', '程序设计是一门基础课程。对于计算机相关专业而言，程序设计是专业基础知识，是进一步学习其他专业知识的第一步阶梯；对于非计算机专业而言，程序设计的学习有助于理解计算机的能力所在，理解哪些是计算机擅长解决的问题，怎样的方式方法是计算机擅长的手段，从而能更好地利用计算机来解决本专业领域内的问题。\r\n\r\nC语言是古老而长青的编程语言，它具备了现代程序设计的基础要求，它的语法是很多其他编程语言的基础，在系统程序、嵌入式系统等领域依然是无可替代的编程语言，在各类编程语言排行榜上常年占据前两名的位置。\r\n\r\n对于非计算机专业的学生，学习本课程的主要目的是掌握程序设计的基本方法，C语言是教学媒介。但是对于计算机专业的学生，本课程是向后续的计算机组成、操作系统、编译原理、体系结构等课程前进的基石，对于C语言本身甚至程序设计语言基础原理的深入理解都是应该掌握的。\r\n\r\n程序设计是实践性很强的课程，该课程的学习有其自身的特点，听不会，也看不会，只能练会。你必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。在这里所提供的，只是基础的知识讲解，要想学会编程，还需要更多时间的投入和努力。\r\n\r\n  为了学习编程，你需要有一台计算机，安装必要的编程软件。无论是MS Windows、Mac OS X还是Linux，都有适合C语言编程的软件。', 'A065FC17D39ACEB56C1A94FAF6A3F543.png', '6');
INSERT INTO `course` VALUES ('2', 'C语言程序设计(上)', '2018-03-25', '2018-06-30', '        我们一如既往还说C，因为它称霸于计算机语言，超乎我们的想象。\r\n\r\n        如果想深刻的理解这个时代，就要理解计算机编程! 编程完成了基于计算机的计算实现，改变着我们的思维方式！ 编程的日子上演着种种惊喜，让我们实现着梦想！\r\n       C 语言具备了面向过程程序设计的基本要求，在诸多领域无可替代，也适合于构建程序设计基础。所以它是一门程序设计的公共基础课程，相信也是热爱程序设计的朋友们会青睐的一门课。对于计算机类专业，程序设计是专业基础课，它是后续专业课程的基础；对于非计算机类专业，程序设计将会改变我们的思维，教给我们信息时代如何思考问题，从而能更好地利用计算机科学与技术解决本专业领域的计算相关、信息处理相关的问题。\r\n        为了循序渐进，我们将《C语言程序设计》这门课程分为上、下两部分完成。以数组为分割点，由《C语言程序设计（上）》和《C语言程序设计（下）》，前者8周，后者10周。采用分而治之，旨在由浅入深，坚固基础，追求完备。\r\n        我们的课堂将从零基础开始，为大家介绍“什么是程序设计？如何实现程序设计？”。本课程以计算思维为导向，以应用问题为牵引，以能力培养为目标，实施 “传授知识与思维训练相结合，编程语言与程序设计相结合，自主学习与平台引导相结合”的教学模式。\r\n              \r\n              \r\n              ', '4A5DADAAACFEEFE79DFF9C19E626C659.jpg', '7');
INSERT INTO `course` VALUES ('3', 'C语言程序设计（下）', '2018-03-26', '2018-06-30', '欢迎大家进入C语言程序设计第二部分的学习。\r\n\r\n相信大家已经掌握了C语言的基本语法，学会用三种基本结构编写程序，能够解决一般的数值处理问题、穷举问题等。 就如同学习汉语，大家已经学习了字、组词、造句，能够写短文了，接下来是怎样写长文章？对应C语言来说，我们如何设计较长的程序？如何解决相对复杂的问题？如何重复使用某一段代码？\r\n\r\n有人说编程是艺术，用C就可以写出很“美“的代码。例如如果我们不用循环结构，不用递归算法，能不能在屏幕上输出从1到1000？学完这部分，大家就可以试试啦。\r\n\r\nC语言的基本结构是函数，其基本含义是：一个软件可以由多个源程序（文件）组成；一个源程序（文件）可以由多个函数组成；函数就是一段具有某种功能的程序，除主函数之外，用户写的这段程序叫做用户定义函数，由函数名，参数，说明语句和执行语句构成。定义后的函数可以重复被主函数或其他函数调用。所以说，函数是实现模块化设计的基础。\r\n\r\n更为神奇的是，如果我们把函数的组成部分细化，列出一个树状的结构，你会发现你学过的C语言的基础知识内容都在里面啦，学过函数后，你也可以试试啊。\r\n\r\n怎么使用函数呢？函数的递归调用是难点，要掌握编写递归算法的关键，通过典型的递归问题掌握编写递归程序的技巧；其次要将前面各章中的一些题目用递归算法实现，通过对比分析，加深对递归的理解和掌握。\r\n\r\n接下来，我们学习指针。指针是C语音的特色，也是C语言中最灵活的地方。\r\n\r\n如何学习指针呢？ C语言中指针就是地址。大家要掌握指向变量的指针，指向数组的指针，指向函数的指针，指向指针的指针,指针数组等。注意从定义和引用的形式上区分不同功能的指针，要理解指针与数组的关系，以及定义了指针之后，如何引用变量的值等具体问题，\r\n\r\n结构、联合与枚举都是C语言中的构造数据类型，是基本数据类型的某种组合。\r\n\r\n链表是指针、结构体的高级应用，也是C语言各阶段语法知识的综合体现。链表就是动态的数据结构。要掌握链表如何定义，如何建立简单的单向链表，以及学会编写链表中节点的插入、删除等基本操作。在上述知识和练习基础上，练习编写小软件，例如：学生档案管理系统等。\r\n\r\n以往程序中对数据的操作均在内存上实现，随着程序运行的结束，变量的内存空间和变量的值均消失。C语言中可以利用文件实现数据在外存上的存取操作。\r\n\r\n首先要掌握文件的基本概念，其中重要的是文件型指针，文件通过文件指针操作。要学会使用文件读写函数，分别实现文件的按字符读写、按字符串读写、按数据块读写和按格式读写；还有文件当前状态的测试函数等，必须熟练使用这些函数。\r\n              \r\n              \r\n              \r\n              \r\n              \r\n              ', '4A5DADAAACFEEFE79DFF9C19E626C659.jpg', '7');
INSERT INTO `course` VALUES ('4', 'C语言程序设计精髓', '2018-02-05', '2018-06-10', '对于这个地球上大多数人来说，真正的数字化革命还没有开始。在接下来的10年里，变化将无处不在，让我们一起来给这个世界编码吧！——Eric Schmidt Google执行主席    \r\n\r\n   我们会用15周的时间来深入讲解C语言，在授课过程中，我们会注重多解释一些“为什么”以及错误程序的分析，从环环相扣的问题入手，将一些易被忽视且对高水平程序设计很重要的“点”，沿着数据结构从简单到复杂的主线逐一展开，在实例的“不断深化和提升”中引出知识点，通过对问题的举一反三和前后知识点的融会贯通，由浅入深地引导你循序渐进地编写规模逐步增大的程序。\r\n\r\n   在过去30年90%的时间里，C语言独领风骚，仅偶尔被 Java 超越，可见其魅力。C语言作为一种高级语言，其实并不高级，但正是这种“低级”给我们更多思考的机会。期望通过本课程的学习，你不只是简单地能够掌握一种语言的语法，还能理解隐含在语法背后的思想，并初步具备灵活使用这些思想进行编写程序解决实际问题的能力。如果你掌握了这些，你会发现，迈向成功的最后一步不过是选择一种合适的编程工具而已。 \r\n\r\n   你想从“菜鸟”升级为“程序猿”吗？那就加入“稀饭”的行列，和我们一起踏上爱上C语言之旅吧。', '2983071803279791004.png', '8');
INSERT INTO `course` VALUES ('5', 'C语言程序设计', '2018-03-12', '2018-06-17', 'C语言是一门结构化程序设计语言，是计算机程序语言的基础，兼有高级语言和低级语言的功能，不仅可用于编写应用软件，还可以编写系统软件以及嵌入式系统。目前流行的面向对象程序设计语言，如C++、Java、C#等都是在C语言的基础上发展派生而来的。通过学习C语言不仅能够掌握程序设计的基本思想，也可为今后学习Java、C++、VB等语言打下良好的基础。\r\n\r\nC语言可以用于开发比较底层的东西，比如驱动、通信协议之类，在Unix和Linux环境中也是不可或缺的，另外在嵌入式领域也大有作为。\r\n\r\n     本课程讲解C语言的基本数据类型及其运算、分支结构、循环结构、数组、函数、结构体、指针和文件等内容。\r\n\r\n     如果懂得C，就能很好地理解程序设计的思想，理解如何构造数组、链表、树、图等结构，才能体验程序设计的思想和算法的精髓。', '49BB70C94F0AA99BE0A0EE30E7B1B4E4.jpg', '9');
INSERT INTO `course` VALUES ('6', 'C语言程序设计进阶', '2017-11-06', '2018-01-16', '课程以一个Windows下的图形游戏程序入手，借助一个C语言图形库，展开全部的教学内容。\r\n\r\n作为计算机的基础语言，C语言有许多独特的地方。从1970年代诞生起，它的历史使命就是编写系统程序，它被设计成非常贴近底层、贴近硬件。它的很多独特的设计都是为了能够准确地反映硬件操作。但是历史又和C语言开了一个玩笑，它被当作了第一个通用型语言，曾经广泛地用于各种场合，解决各种问题。可是它之后的语言，再也没有像它那样贴近硬件，它们拿掉了那些硬件相关的东西，变得越来越远离底层了。\r\n\r\n这门课，就是要告诉你C语言到底有哪些独特的地方，为什么能长期占据15%上下的编程语言份额。它是在前序课程——《程序设计入门-C语言》或《程序设计入门-Java语言》的基础上，让你完全掌握C语言本身的课程。\r\n\r\n虽然我们会借助一个Windows下的图形库来展开教学内容，但是用C语言写Windows程序已经是过去式了，我们并不是要教大家如何用C语言来写Windows程序，只是借一下故事而已。', '6608226511143817333.jpg', '6');

-- ----------------------------
-- Table structure for exercises
-- ----------------------------
DROP TABLE IF EXISTS `exercises`;
CREATE TABLE `exercises` (
  `exercise_id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `exercise_title` varchar(1023) DEFAULT NULL,
  `a_option` varchar(255) DEFAULT NULL,
  `b_option` varchar(255) DEFAULT NULL,
  `c_option` varchar(255) DEFAULT NULL,
  `d_option` varchar(255) DEFAULT NULL,
  `answer` varchar(255) DEFAULT NULL,
  `type` int(255) DEFAULT NULL,
  `paper_id` int(11) DEFAULT NULL,
  `paper_title` varchar(255) DEFAULT NULL,
  `difficulty` mediumint(8) DEFAULT NULL,
  `analysis` varchar(1023) DEFAULT NULL,
  PRIMARY KEY (`exercise_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=702 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of exercises
-- ----------------------------
INSERT INTO `exercises` VALUES ('1', '下列描述中正确的是', '算法是指对解题方案的准确而完整的描述', '算法的有穷性是指算法程序的长度是有限的', '算法是否有效与拥有的情报无关', '算法的基本特征有可行性、确定性和有穷性', 'A', '1', '1', '第1章_程序设计基本概念', '2', '无解析');
INSERT INTO `exercises` VALUES ('2', '下列数据结构中属于非线性结构的是', '队列', '线性表', '二叉树', '栈', 'C', '1', '1', '第1章_程序设计基本概念', '2', '无解析');
INSERT INTO `exercises` VALUES ('3', '在C语言中，合法的长整型常数是', '0.123456', '4962717', '9L', '5.321e2', 'C', '2', '1', '第1章_程序设计基本概念', '3', '无解析');
INSERT INTO `exercises` VALUES ('4', '执行语句X=(a=10，b=a--.后，x、a、b的值依次为', '10,10,9', '10,9,9', '9,10,9', '10,9,10', 'D', '2', '1', '第1章_程序设计基本概念', '4', '无解析');
INSERT INTO `exercises` VALUES ('5', '下面概念中，不属于面向对象方法的是', '对象', '继承', '类', '过程调用', 'D', '2', '1', '第1章_程序设计基本概念', '5', '无解析');
INSERT INTO `exercises` VALUES ('6', '下列选项中属于软件生命周期开发阶段任务的是', '可行性研究', '需求分析', '详细设计', '软件维护', 'C', '1', '1', '第1章_程序设计基本概念', '4', '无解析');
INSERT INTO `exercises` VALUES ('7', '软件设计中衡量模块独立性的度量标准是', '抽象和信息隐蔽', '局部化和封装化', '内聚性和耦合性', '激活机制和控制方法', 'C', '1', '1', '第1章_程序设计基本概念', '3', '无解析');
INSERT INTO `exercises` VALUES ('8', '下列不属于过程设计工具中图形工的是', 'N-S', 'PAD', '程序流程图', 'DFD', 'D', '1', '1', '第1章_程序设计基本概念', '4', '无解析');
INSERT INTO `exercises` VALUES ('9', '下列叙述中错误的是', '数据库管理系统是故据库的核心', '数据库系统由数据库、数据库管理系统、数据库管理员三部分组成', '数据共享最好的是数据库系统阶段', '数据库中的数据独立于应用程序而不依赖于应用程序', 'B', '1', '1', '第1章_程序设计基本概念', '5', '无解析');
INSERT INTO `exercises` VALUES ('10', '在下列选项中，哪个不是-', '无穷性', '可行性', '确定性', '有穷性', 'A', '1', '1', '第1章_程序设计基本概念', '5', '无解析');
INSERT INTO `exercises` VALUES ('11', '程序流程图中带有前头的线段表示的是', '图九美系', '教据漆', '控制疏', '调用关系', 'C', '1', '37', '2018年3月二级《C语言》模拟试题3', '1', '在数据流图中，用标有名字的前头表示故据流。右程序流程图中，用标有名字的箭头表示控\r\n制流。所以选择C');
INSERT INTO `exercises` VALUES ('12', '结构化程序设计的基本原则不包括', '多态性', '自頂向下', '模块化', '逐步求精', 'A', '1', '37', '2018年3月二级《C语言》模拟试题3', '2', '结构化程序设计的思想包括。自顶向下、逐步求精、模块化、限制使用goto语句，所以选择\r\nA\r\n');
INSERT INTO `exercises` VALUES ('13', '教件设计中模块划分应遵酒的准则是', '低内聚低耦合', '高内聚低耦合', '低内聚高耦合', '高内聚高耦合', 'B', '1', '37', '2018年3月二级《C语言》模拟试题3', '4', '软件设计中模块划分应遵语的准贝是高内聚低偶台、模块大小规模适当、模块的依赖关系适\r\n当等。模块的划分应遵语一定的要求，以保证模块划分合理，并进一步保证以此为依据开发出的软件系统可\r\n靠性强，县于理解和维护。模块之间的耦合应尽可能的低，模块的內聚度应尽可能的高');
INSERT INTO `exercises` VALUES ('14', '在软件开发中，需家分析阶段产生的主要文档是', '可行性分析报告', '软件需求规格说明书', '概要设计说明书', '集成测试计划', 'B', '1', '37', '2018年3月二级《C语言》模拟试题3', '3', '解析1A 增误，可行性分析阶码产生可行性分析报告。C)借误概要设计说明书是总体设计阶段产\r\n生的文档。D)错误，集成商试计划是在概要设计阶段编写的文档。B)正确，需求规格说明书是后续工作如设\r\nt、编码等需要的重要参考文档。');
INSERT INTO `exercises` VALUES ('15', '算法的有穷性是指', '算法程序的运行时间是有限的', '算法程序所处理的数据量是有限的', '算法程序的长度是有限的', '算法只能被有限的用户使用', 'A', '1', '37', '2018年3月二级《C语言》模拟试题3', '5', '算法原贝上能够情确地运行.而且人们用笔和纸做有限次运算后即可完成。有方性是指算法\r\n程序的运行时间是有限的');
INSERT INTO `exercises` VALUES ('16', '对长度为r的线住表排序，在最坏情况下，比较次数不是a(n一D/2的排序方法是', '快速排序', '冒泡排序', '直接插入排序', '堆排序', 'D', '1', '37', '2018年3月二级《C语言》模拟试题3', '3', '除了堆排序算法的比较次故是\r\nO(eleson)，其他的都是n(n一D/2.');
INSERT INTO `exercises` VALUES ('17', '下列关于栈的前述正确的是', '栈按“先进先出“组织数据', '栈按”先进后出“组织教据', '只能在栈底插入数据', '不能到际教据', 'B', '1', '37', '2018年3月二级《C语言》模拟试题3', '2', '栈是按失进出的原则组乡数据的数据的板和田际都在核债进行操作、\r\n笔记');
INSERT INTO `exercises` VALUES ('18', '在数据库设计中，将E一图转换成关系故据模型的过程属于', '需求分析阶段', '概念设计阶段', '逻辑设计阶段', '物理设计阶段', 'C', '1', '37', '2018年3月二级《C语言》模拟试题3', '2', 'E一R图转换成关系横型数据则是把图形分析出来的联系反映子数据库中，即设计出表，所以\r\n属于逻辑设计阶段。');
INSERT INTO `exercises` VALUES ('19', '有表示4 性选课的三张表，学生S( 学号，姓名，性別，年齡，身份证号)，课程C(课号，课名)，选课SC(学\r\n好，课号，成绩》，则表SC的关键字(健或码)为', '课号，成績', '学号，咸绩', '学号课号', '学号，姓名成绩', 'C', '1', '37', '2018年3月二级《C语言》模拟试题3', '3', '学号是学生表S的王键，课号是课程表C的主键，所选课表$的关键字就应该是与前两表\r\n能够直接联系且能唯一定义的学号和评号，所以选择C');
INSERT INTO `exercises` VALUES ('20', '以下额述中错误的是', 'C语言中的每条可扶行语句和非执行语句最终都将被转换成二进制的机器指令', 'c程序经过编详、连接步黎之后才能形成一个真正可执行的二进制机器指令文件', '用C语言编写的程序称为源程序，它以ASCI代码形式存放在一个文本文件中', 'C语言源程序经编译后生成后握为ob的目标程序', 'B', '1', '37', '2018年3月二级《C语言》模拟试题3', '3', 'C语言中的非执行语均不会被编评，不会生成二选制的机器指令，所以入)错误。由C语宫构\r\n成的指令予列称C源程序，C源程序经过C语言编译程序编评之后生成一个后援为。ORJ的二进制文件(称为目\r\n标文件) 最后委由“连接程序“把此。OBJ文件与C语言提供的各种库函数连接起来生成一个后提为，X的可\r\n执行文件。');
INSERT INTO `exercises` VALUES ('21', '以下选项中，合法的一组C语言效值常量是', '12.0Xa23 4 5e0', '028.5e-3-0xt', '，177 4o1.5 Oabc', '0x8A 10,000 3.e5', 'A', '2', '6', '2015年9月计算机二级考试《C语言》真题及解析', '4', 'C语言中八选制整型常量的开头是故字0 十六进制整型常量的开头数字是OX。C语言中的实\r\n型常量有两种表示形式，小数形式，小数形式表示的实型常量必须要有小致点指数元式，以”。“或下“后\r\n跟一个整故来表示以10为底数的某故，且规定字母。或之前必须要有数字，且。或后面的指数必页为整\r\n故。B)选项中028错误，八进制中没有数字8。C)选项中41.5中6后面的指数不是整数。D)选项中3.e5小数\r\n点后面缺少数字。');
INSERT INTO `exercises` VALUES ('22', '以下选项中不台法的标识符是', '&a', 'FOR', 'print', '00', 'A', '2', '6', '2015年9月计算机二级考试《C语言》真题及解析', '4', 'C 语言中标识符由字母、下切线、数字组成，且开4 必须是字母或下划线。另外，关键字不能\r\n作为标识符。因为C语言中区分大小写，所以B)法顶中的“FOR”可以作为标识符来用。A)选项中含有非法字符\r\nk，所以选择A');
INSERT INTO `exercises` VALUES ('23', '苦有定义，double 45 22 int i=0.k= 18r 则不符合C语言规定的赋值语句是', 'i- (a+k)< (i+k);', 'i=a%11', 'a=a++，i++', 'i=! a', 'B', '2', '6', '2015年9月计算机二级考试《C语言》真题及解析', '2', '取模运算符“%”，二元运算符，具有左结合性，参与运算的量均为整型。选项肿中的变量是\r\ndouble实型，所以B)不符合规定。');
INSERT INTO `exercises` VALUES ('24', '下关干逻辑运算符两偶运算对象的叙述中正确的是', '可以是任意合法的表达式', '只能是整数0或非0整数', '可以是结构体类型的数据', '只能是整數0或1', 'A', '1', '6', '2015年9月计算机二级考试《C语言》真题及解析', '4', 'C语言的逻辑运算符比较特别，它的操作数设有明确的故据夫型，可以是任意合法的表达式，\r\n所以选择A');
INSERT INTO `exercises` VALUES ('25', '以下毅述中错误的是', '可以给指针变量赋一个整数作为地址值', '函数可以返回地址值', '改变角数形参的值，不会改变对应实参的值', '当在程序的开头包含头文件stdio.h时，可以给指针变量財NULL', 'A', '2', '6', '2015年9月计算机二级考试《C语言》真题及解析', '1', '不能行一个整故直接赋给指针变量作为地址，所w是错误的函数的返回值可以是地址，\r\n即指针。函数调用中形参值的变化不会传递给实梦');
INSERT INTO `exercises` VALUES ('26', '设已有定义，float x 则以下对指针支量p进行定义且财切值的语句中正确的是', 'int *p= (tloat)x:', 'tloat *p-bx', 'float D=&x;', 'f1oat *p= 1024', 'B', '2', '6', '2015年9月计算机二级考试《C语言》真题及解析', '2', '指计是用来存放地址的支量，用(类型名+指针变量名)的无式定义。赋值时应将其个变量地\r\n址即紅x 賕給指针交量，所以选择B');
INSERT INTO `exercises` VALUES ('27', '以下数组定义中错误的是', 'int x[2][3]= [1,2,3,4,5,6}:', 'int x[[3]= (0);', 'int x[][3]= [{1,2,3).[4,5,61];', 'int x[2][3]= [[1.2].[3,4].[5,6});', 'D', '2', '6', '2015年9月计算机二级考试《C语言》真题及解析', '3', '选项中x[2][3]定《的是一个两行三列的二维故组。而在给故组元素赋值时却赋成了三行，\r\n所以错误。');
INSERT INTO `exercises` VALUES ('28', '设有定义，charp[]=(\'1\'，\'2’，\'3\')，*q=p，以下不能计算出一个char型的操所占字节数的表达式是', 'sizeot(p)', 'sixeot(char)', 'sixeot(*q)', 'nixeot(p[0])', 'A', '2', '6', '2015年9月计算机二级考试《C语言》真题及解析', '4', '根据慧目中的定义可(30港sizo of(o)，计算的是数组=中所有t素所占用的子节的，配不是\r\nchar型数据所占字节数。');
INSERT INTO `exercises` VALUES ('29', '以下权述中正确的是', '在C语言中，预处理命令行都以”开头', '预处理命令行必须位于C源程序的起始位置', 'Binc1ude <stdio.b>必须放在C程序的开头', 'C语言的预处理不能实现宏定义和条件编译的功能', 'A', '2', '6', '2015年9月计算机二级考试《C语言》真题及解析', '1', '预处理命令是以“”号开头的命会它们不是C语言的可执行命令这些命令应该在函故之\r\n外书写，一般在源文件的景扩面书写，但不是必须在起始位置书写所以B) 0)错误。C)语言的预外理能够\r\n实现完定义和条件编译等功能，所以D)增误。');
INSERT INTO `exercises` VALUES ('30', '在C语言中，合法的长整型常数是', '0.123456', '4962717', '9L', '5.321e2', 'C', '2', '6', '2015年9月计算机二级考试《C语言》真题及解析', '3', '无解析');
INSERT INTO `exercises` VALUES ('31', '执行语句X=(a=10，b=a--.后，x、a、b的值依次为', '10,10,9', '10,9,9', '9,10,9', '10,9,10', 'D', '2', '26', '2017年9月二级《C语言》冲刺提分卷', '4', '无解析');
INSERT INTO `exercises` VALUES ('32', '以下选项中非法的表达式是', 'a+1=a+1', 'a=b==0', '(Char.(100+ 100.', '7<=X<60', 'A', '2', '26', '2017年9月二级《C语言》冲刺提分卷', '5', '无解析');
INSERT INTO `exercises` VALUES ('33', '在以下选项中，不正确的赋值语句是', 'i++ ;', 'n1=(n2=(n3=0..;', 'm+n=1;', 'i=k==j ;', 'C', '2', '7', '2015年3月计算机二级考试《C语言》真题及解析', '3', '无解析');
INSERT INTO `exercises` VALUES ('34', '若有说明，double*m,n; 则能通过sCanf语句正确给输入项读人数据的程序段是', '*m= &n;scanf(\"%lf*m);', 'm= (double* )mallo (1 0);sc anf(\"%6f\'m);', 'm = &n;scant(%l*,n);', 'm = &n;scanf(\"%le\"\'m);', 'D', '2', '8', '2014年9月计算机二级考试《C语言》真题及解析', '3', '无解析');
INSERT INTO `exercises` VALUES ('35', '表示关系M<=N<=P的C语言表达式为', '(M<=N.AND(N<=P.', '(M<=N.&&(N<=P.', '(M<=N<=P.', '(M<=N.&(N<=P.', 'B', '2', '2', '第2章_C程序设计的初步知识', '4', '无解析');
INSERT INTO `exercises` VALUES ('36', '以下叙述中正确的是', '在scanf函数的格式串中，必须有与输入项一一对应的格式转换说明符', '只能在prinf函数中指定输入数据的宽度，而不能在scanf函数中指定输入数据占的宽度', 'scanf函数中的字符串，是提示程序员的，输入数据时不必管它', '复合语句也被称为语句块，它至少要包含两条语句', 'A', '2', '2', '第2章_C程序设计的初步知识', '2', '无解析');
INSERT INTO `exercises` VALUES ('37', '以下叙述中正确的是', '在scanf函数中的格式控制字符串是为了输入数据用的，不会输出到屏幕上', '在使用scanf函数输入整故或实故时，输入数据之间5 ?能用空格来分隔', '在Printf函数中，各个输出项只能是变量', '使用Printf函数无法输出百分号%', 'A', '2', '2', '第2章_C程序设计的初步知识', '3', '无解析');
INSERT INTO `exercises` VALUES ('38', '下列描述中正确的是', '算法是指对解题方案的准确而完整的描述', '算法的有穷性是指算法程序的长度是有限的', '算法是否有效与拥有的情报无关', '算法的基本特征有可行性、确定性和有穷性', 'A', '1', '29', '第1章_程序设计基本概念', '2', '无解析');
INSERT INTO `exercises` VALUES ('39', '下列数据结构中属于非线性结构的是', '队列', '线性表', '二叉树', '栈', 'C', '1', '29', '第1章_程序设计基本概念', '2', '无解析');
INSERT INTO `exercises` VALUES ('40', '在C语言中，合法的长整型常数是', '0.123456', '4962717', '9L', '5.321e2', 'C', '2', '29', '第1章_程序设计基本概念', '3', '无解析');
INSERT INTO `exercises` VALUES ('41', '表示关系M<=N<=P的C语言表达式为', '(M<=N.AND(N<=P.', '(M<=N.&&(N<=P.', '(M<=N<=P.', '(M<=N.&(N<=P.', 'B', '2', '30', '第2章_C程序设计的初步知识', '4', '无解析');
INSERT INTO `exercises` VALUES ('42', '以下叙述中正确的是', '在scanf函数的格式串中，必须有与输入项一一对应的格式转换说明符', '只能在prinf函数中指定输入数据的宽度，而不能在scanf函数中指定输入数据占的宽度', 'scanf函数中的字符串，是提示程序员的，输入数据时不必管它', '复合语句也被称为语句块，它至少要包含两条语句', 'A', '2', '30', '第2章_C程序设计的初步知识', '2', '无解析');
INSERT INTO `exercises` VALUES ('58', '下列叙述中正确的是', '所谓算法就是计算方法', '程序可以作为算法的一种描述方法', '算法设计只需考虑得到计算结果', '算法设计可以忽略算法的运算时间', 'B', '1', '3', '2018年3月二级《C语言》临考猜想卷', null, '算法是指对解题方案的准确而完整的描述，算法不等于数学上的计算方法，也不等于程序,A选项错误。算法设计需要考虑可行性、确定性、有穷性与足够的情报，不能只考虑计算结果，C选项错误。算法设计有穷性是指操作步骤有限且能在有限时间内完成，如果一个算法执行耗费的时间太长，即使最终得出了正确结果，也是没有意义的，D选项错误。算法在实现时需要用具体的程序设计语言描述，所以程序可以作为算法的一种描述方法，B选项正确。');
INSERT INTO `exercises` VALUES ('59', '下列叙述中正确的是', '一个算法的空间复杂度大，则其时间复杂度也必定大', '一个算法的空间复杂度大，则其时间复杂度必定小   ', '一个算法的时间复杂度大，则其空间复杂度必定小', '算法的时间复杂度与空间复杂度没有直接关系', 'D', '1', '3', '2018年3月二级《C语言》临考猜想卷', null, '算法的空间复杂度是指算法在执行过程中所需要的内存空间，算法的时间复杂度，是指执行算法所需要的计算工作量，两者之间并没有直接关系，答案为D。');
INSERT INTO `exercises` VALUES ('60', '下列叙述中错误的是', '数据结构中的数据元素不能是另一数据结构', '数据结构中的数据元素可以是另一数据结构', '空数据结构可以是线性结构也可以是非线性结构', '非空数据结构可以没有根结点', 'A', '1', '3', '2018年3月二级《C语言》临考猜想卷', null, '数据元素是一个含义很广泛的概念，它是数据的“基本单位”，在计算机中通常作为一个整体进行考虑和处理。数据元素可以是一个数据也可以是被抽象出的具有一定结构数据集合，所以数据结构中的数据元素可以是另一数据结构。满足有且只有一个根结点并且每一个结点最多有一个前件，也最多有一个后件的非空的数据结构认为是线性结构，不满足条件的结构为非线性结构。空数据结构可以是线性结构也可以是非线性结构。非空数据结构可以没有根结点，如非性线结构“图”就没有根结点。故选A选项');
INSERT INTO `exercises` VALUES ('61', '结构化程序设计的基本原则不包括(　　)。', '多态性', '自顶向下', '模块化', '逐步求精', 'A', '1', '3', '2018年3月二级《C语言》临考猜想卷', null, '结构化程序设计的思想包括：自顶向下、逐步求精、模块化、限制使用goto语句，所以选择A。');
INSERT INTO `exercises` VALUES ('62', '结构化程序设计中，下面对goto语句使用描述正确的是', '禁止使用goto语句', '使用goto语句程序效率高', '应避免滥用goto语句', '以上说法均错误', 'C', '1', '3', '2018年3月二级《C语言》临考猜想卷', null, '结构化程序设计中，要注意尽量避免goto语句的使用，故选C。');
INSERT INTO `exercises` VALUES ('63', '下列叙述中正确的是', '软件是程序、数据和文档', '软件是程序和数据', '软件是算法和数据结构', '软件是算法和程序', 'A', '1', '3', '2018年3月二级《C语言》临考猜想卷', null, '计算机软件由两部分组成：一是机器可执行的程序和数据；二是机器不可执行的，与软件开发、运行、维护、使用等有关的文档。故选A选项');
INSERT INTO `exercises` VALUES ('64', '软件生命周期是指(　　)。', '软件产品从提出、实现、使用维护到停止使用退役的过程', '软件从需求分析、设计、实现到测试完成的过程', '软件的开发过程', '软件的运行维护过程', 'A', '1', '3', '2018年3月二级《C语言》临考猜想卷', null, '通常，将软件产品从提出、实现、使用维护到停止使用退役的过程称为软件生命周期。也就是说，软件产品从考虑其概念开始，到该软件产品不能使用为止的整个时期都属于软件生命周期');
INSERT INTO `exercises` VALUES ('65', '下面能作为软件需求分析工具的是', 'PAD图 ', '程序流程图 ', '甘特图 ', '数据流程图(DFD图)', 'D', '1', '3', '2018年3月二级《C语言》临考猜想卷', null, '软件需求分析方法包括结构化分析方法和面向对象的分析方法两大类，前者常用工具为数据流图（DFD）、数据字典（DD）、判定表、判定树等。故D选项正确。');
INSERT INTO `exercises` VALUES ('66', '在数据库管理系统提供的数据语言中，负责数据的查询、增加、删除和修改等操作的是', '数据定义语言', '数据管理语言', '数据操纵语言', '数据控制语言', 'D', '1', '3', '2018年3月二级《C语言》临考猜想卷', null, '数据库管理系统提供了相应的数据语言，它们是：数据定义语言，该语言负责数据的模式定义与数据的物理存取构建；数据操纵语言，该语言负责数据的操纵，包括查询与增、删、改等操作；数据控制语言，该语言负责数据完整性、安全性的定义与检查以及并发控制、故障恢复等功能。C选项正确。');
INSERT INTO `exercises` VALUES ('67', '在数据库系统中，考虑数据库实现的数据模型是', '概念数据模型', '逻辑数据模型', '物理数据模型', '关系数据模型', 'B', '1', '3', '2018年3月二级《C语言》临考猜想卷', null, '数据模型按照不同的应用层次分为以下３种类型：概念数据模型，它是一种面向客观世界、面向用户的模型，它与具体的数据库管理系统和具体的计算机平台无关；逻辑数据模型，是面向数据库系统的模型，着重于在数据库系统一级的实现；物理数据模型，是面向计算机物理实现的模型，此模型给出了数据模型在计算机上物理结构的表示。B选项正确。');
INSERT INTO `exercises` VALUES ('68', '以下叙述中错误的是(　　)。', '使用三种基本结构构成的程序只能解决简单问题', '结构化程序由顺序、分支、循环三种基本结构组成', 'C语言是一种结构化程序设计语言', '结构化程序设计提倡模块化的设计方法', 'A', '1', '3', '2018年3月二级《C语言》临考猜想卷', null, '使用顺序，选择(分支)，循环三种基本结构构成的程序可以解决所有问题，而不只是解决简单问题，所以A错误。');
INSERT INTO `exercises` VALUES ('69', '以下选项中叙述正确的是', '函数体必须由 { 开始', 'C程序必须由main语句开始', 'C程序中的注释可以嵌套', 'C程序中的注释必须在一行完成', 'A', '2', '3', '2018年3月二级《C语言》临考猜想卷', null, '函数体是函数首部下面的花括号内的部分，所以函数体必须由{开始，A选项正确。一个源程序文件可以包括预处理命令、全局声明、函数定义，程序总是从main函数开始执行的，不是main语句，B选项错误。C程序中的允许两种注释，以//开头的单行注释；以/*开始，以*/结束的块式注释，D选项错误。函数可以嵌套，注释不能嵌套，C选项错误。');
INSERT INTO `exercises` VALUES ('70', '以下叙述正确的是', 'C编译程序把文件后缀为.c的源程序文件编译成文件后缀为.obj的二进制文件', 'C编译程序把文件后缀为.c的源程序文件编译成文件后缀为.exe的可执行文件', 'C编译程序把文件后缀为.obj的二进制文件编译成文件后缀为.exe的可执行文件', '链接程序把文件后缀为.c的源程序文件链接成文件后缀为.exe的可执行文件', 'A', '2', '3', '2018年3月二级《C语言》临考猜想卷', null, 'C编译程序把文件后缀为.c的源程序文件编译成文件后缀为.obj的二进制文件，链接将一个或多个目标文件与程序用到的库文件连接起来,形成一个可以在操作系统直接运行的执行程序.exe，故排除B,C,D选项，答案选A选项。');
INSERT INTO `exercises` VALUES ('71', '按照C语言规定的用户标识符命名规则，不能出现在标识符中的是(　　)。', '大写字母', '下划线', '数字字符', '连接符', 'D', '2', '3', '2018年3月二级《C语言》临考猜想卷', null, 'C语言中标识符由字母、下划线、数字组成，且开头必须是字母或下划线。所以D选项中的连接符不合法。');
INSERT INTO `exercises` VALUES ('72', '下列定义变量的语句中错误的是', 'int  _int;', 'double  int_;', 'char  For;', 'float  US$;', 'D', '2', '3', '2018年3月二级《C语言》临考猜想卷', null, 'C语言规定,变量命名必须符合标识符的命名规则｡D选项中包含了非法字符\"$\",所以错误｡标识符由字母､数字或下划线组成,且第一个字符必须是大小写英文字母或者下划线,而不能是数字｡大写字符与小写字符被认为是两个不同的字符,所以For不是关键字for｡');
INSERT INTO `exercises` VALUES ('73', 'C语言中的标识符分为关键字、预定义标识符和用户标识符，以下叙述正确的是', '关键字可用作用户标识符，但失去原有含义', '预定义标识符可用作用户标识符，但失去原有含义', '在标识符中大写字母和小写字母被认为是相同的字符', '用户标识符可以由字母和数字任意顺序组成', 'B', '2', '3', '2018年3月二级《C语言》临考猜想卷', null, '关键字不可用作C语言的标识符,所以A错误｡在标识符中大写字母与小写字母作为不同字符处理,所以C错误｡标识符由下划线､字母､数字组成,且必须以下划线和字母开始,所以D错误｡');
INSERT INTO `exercises` VALUES ('74', '以下选项中合法的常量是', '9  9  9', '2.7e', '0Xab', '123E 0.2', 'C', '2', '3', '2018年3月二级《C语言》临考猜想卷', null, '析】A选项中含有非法的空格,所以错误｡C语言中十六进制常量以0x开头,所以C正确｡实型常量中e的前后必须均有数据,且其后必须为整数,所以B和D错误｡');
INSERT INTO `exercises` VALUES ('75', '有以下程序\r\n#include <stdio.h>\r\nmain()\r\n{  int  k=33; \r\n   printf(\"%d,%o,%x\\n\", k, k, k);\r\n}程序的运行结果是', '33,41,21 ', '33,33,33 ', '41,33,21 ', '33,21,41', 'A', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '整型常量有３种表示方法，分别是十进制数表示法、八进制数表示法和十六进制数表示法。十进制整型常量没有前缀，输出格式控制符为%d；八进制整型常量以０作为前缀，输出格式控制符为%o；十六进制整型常量以0X或0x作为前缀，输出格式控制符为%x。整型33用八进制表示为41，十六进制表示为21，A选项正确。');
INSERT INTO `exercises` VALUES ('76', '以下选项中，合法的一组C语言数值常量是(　　)。', '12.　0Xa23　4.5e0', '028　.5e-3　-0xf', '.177　4e1.5　0abc', '0x8A　10,000　3.e5', 'A', '2', '3', '2018年3月二级《C语言》临考猜想卷', null, 'C语言中八进制整型常量的开头是数字0，十六进制整型常量的开头数字是0x。C语言中的实型常量有两种表示形式：小数形式，小数形式表示的实型常量必须要有小数点；指数形式，以\"e\"或\"E\"后跟一个整数来表示以10为底数的幂数，且规定字母e或E之前必须要有数字，且e或E后面的指数必须为整数。B选项中 028错误，八进制中没有数字8。C选项中4e1.5中e后面的指数不是整数。D选项中数字“10，000”不能用逗号。');
INSERT INTO `exercises` VALUES ('77', '已知大写字母A的ASCII码是65，小写字母a的ASCII码是97。以下不能将变量c中的大写字母转换为对应小写字母的语句是()。', 'c=(\'A\'+c)%26-\'a\'', 'c=c+32', 'c=c-\'A\'+\'a\'', 'c=(c-\'A\')%26 +\'a\'', 'A', '2', '3', '2018年3月二级《C语言》临考猜想卷', null, '根据题意可知,小写字母比与之对应的大写字母的ASCII码大32｡A选项中字符A加上c表示的大写字符再对字母个数26取余,本身这个表达式没有任何含义所以选择A选项｡');
INSERT INTO `exercises` VALUES ('78', '若有定义：double  a, b, c; 能正确给a,b,c输入数据的语句是()。', 'scanf(\" %lf %lf %lf\" &a, &b, &c )', 'scanf(\" %f %f %f\",&a, &b, &c );', 'scanf(\" %lf %lf %lf\",a, b, c );', 'scanf(\" %lf %lf %lf\",&a, &b, &c );', 'D', '2', '3', '2018年3月二级《C语言》临考猜想卷', null, '%lf,%le是针对double的，如果仅用%f，输入的数据可能不完全接收，数据的精度可能不足。%f主要针对float类型的变量的输入,因此选项B错误。根据题目格式可知A,C错误。故答案为D选项。');
INSERT INTO `exercises` VALUES ('79', '若有以下程序段\r\n    double x=5.16894;\r\n    printf(\"%f\\n\",  (int)(x*1000+0.5)/(double)1000  );\r\n则程序段的输出结果是', '5.170000', '5.175000', '5.169000', '5.168000', 'C', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '%f的输出格式是以带小数点的数学形式输出浮点数。首先计算x*1000，结果为5168.94然后+0.5,结果为5169.44,然后进行强制类型转换,转换成整型为5169,然后除以双精度数据1000,结果也为双精度数据5.169,输出时按照%f的格式输出，所以输出结果为5.169000｡');
INSERT INTO `exercises` VALUES ('80', '若变量已正确定义，在if (W) printf(\"%d\\n\" ，k )； 中，以下不可替代W的是(　　)。', 'a<>b+c', 'ch=getchar()', 'a==b+c', 'a++', 'A', '2', '3', '2018年3月二级《C语言》临考猜想卷', null, '选项A是非法的表达式，C语言中没有<>运算符。');
INSERT INTO `exercises` VALUES ('81', '#include   <stdio.h>\r\nmain()\r\n{　int  x， y， z；\r\n　 x＝y＝1；\r\n　 z＝x++，y++，++y；\r\n　 printf(\"%d,%d,%d\\n\",x,y,z)；\r\n}\r\n程序运行后的输出结果是(　　)。', '2,3,3', '2,3,2', '2,3,1', '2,2,1', 'C', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, 'z＝x++，y++，++y；因为赋值运算符的优先级高于逗号运算符的优先级，所以可以将上式表示成(z＝x++)，(y++)，(++y)。然后从左向右先计算表达式z＝x++，因为x++先使用后自增，所以z的值为1，x的值为2。再计算逗号表达式第二个表达式y++，此时y的值为2，最后计算第三个表达式++y，y的值为3。');
INSERT INTO `exercises` VALUES ('82', '有如下程序\r\n#include <stdio.h>\r\nmain() \r\n{\r\n    int a = 0, b = 1;\r\n    if (a++ && b++) \r\n        printf(\"T\");\r\n    else\r\n        printf(\"F\");\r\n    printf(\"a=%d,b=%d\\n\", a, b);\r\n}\r\n程序运行后的输出结果是', 'Ta=1,b=2', 'Fa=0,b=2', 'Fa=1,b=1', 'Ta=0,b=1', 'C', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '题目中判断if条件是否成立，a++先取值为0，则(a++ && b++)为0，且不计算b++，而后a自增得a=1，if条件不成立执行else函数体，输出F。最后执行语句printf(\"a=%d,b=%d\\n\", a, b);按照格式输出a=1,b=1。C选项正确。');
INSERT INTO `exercises` VALUES ('83', '有以下程序\r\n    #include <stdio.h>\r\n    main()\r\n    {  char *s=\"120119110\";\r\n       int n0,n1,n2,nn,i;\r\n       n0=n1=n2=nn=i=0;\r\n       do{\r\n            switch(s[i++])\r\n            {  default   : nn++;\r\n               case  \'0\' : n0++;\r\n               case  \'1\' : n1++;\r\n               case  \'2\' : n2++;\r\n             }\r\n           } while(s[i]);\r\n      printf(\"n0=%d,n1=%d,n2=%d,nn=%d\\n\",n0,n1,n2,nn);\r\n    }\r\n   程序的运行结果是()。', 'n0=3,n1=8,n2=9,nn=1', 'n0=2,n1=5,n2=1,nn=1', 'n0=2,n1=7,n2=10,nn=1', 'n0=4,n1=8,n2=9,nn=1', 'A', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '本题执行过程为，s[0]=\'1\'，匹配case\'1\'，n1=1，n2=1；s[1]=\'2\'，匹配case\'2\'， n2=2；s[2]=\'0\'，匹配case\'0\'，n0=1，n1=2，n2=3；s[3]=\'1\'，匹配case\'1\'，n1=3，n2=4；s[4]=\'1\'，匹配case\'1\'，n1=4，n2=5；s[5]=\'9\'，匹配default，nn=1，n0=2，n1=5，n2=6；s[6]=\'1\'，匹配case\'1\'，n1=6，n2=7；s[7]=\'1\'，匹配case\'1\'，n1=7，n2=8；s[8]=\'0\'，匹配case\'0\'，n0=3，n1=8，n2=9；s[9]=\'\\0\'，退出循环。输出n0,n1,n2,nn为3,8,9,1，A选项正确。');
INSERT INTO `exercises` VALUES ('84', '有以下程序\r\n#include <stdio.h>\r\nmain( )\r\n{  int i,j = 0; \r\n   char a[] = \"How are you\", b[10] = {0};\r\n   for (i=0; a[i]; i++)\r\n     if (a[i] == \' \')\r\n        b[j++] = a[i+1];\r\n   printf(\"%s\\n\",b);\r\n}\r\n程序运行后的输出结果是()。', 'Hay', 'Howareyou  ', 'we ', 'ay', 'D', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, 'for语句循环体执行功能是，每次当a[i]元素为\' \'时，自动将a[i]下一个元素赋值给b[j]，赋值完成后，j值加1，因此a[i]的\'a\'和\'y\'分别赋值给b[0],b[1]，答案为D选项。');
INSERT INTO `exercises` VALUES ('85', '有以下程序\r\n#include  <stdio.h>\r\nmain()\r\n{  char  a=3, b=6, c;\r\n   c=(a^b)<<2;\r\n   printf(\"%d \\n\", c );\r\n}\r\n程序运行后的输出结果是()。', '5', '1', '20', '18', 'C', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '^运算符为按位异或运算符，即0^1=1,1^0=1,1^1=0,0^0=0,因此a^b=101在进行<<操作，变为101002=2010，因此答案为C选项。');
INSERT INTO `exercises` VALUES ('86', '有如下程序\r\n#include <stdio.h>\r\nmain() \r\n{\r\n    int i, *ptr;\r\n    int array[5] = {5,3,1};\r\n    for (ptr=array, i=0; i<5; i++, ptr++)\r\n    {\r\n        if (*ptr == 0)\r\n            putchar(\'X\');\r\n        else\r\n            putchar(\'A\' + *ptr);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n程序运行后的输出结果是', 'FDBXX', 'FFFXX', 'FDBBB', 'ABCDE', 'A', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '在对数组进行初始化时，如果对数组的全部元素赋以初值，定义时可以不指定数组长度，如果被定义数组的长度与初值个数不同，则数组长度不能省略；如果在说明数组时给出了长度，但没有给所有的元素赋予初始值，而只依次给前面的几个数组元素赋予初值，那么Ｃ语言将自动对余下的元素赋初值，则array={5,3,1,0,0}。程序执行过程为：执行for循环，将数组首地址赋给指针ptr，依次遍历每一个元素，如果数组元素为0则输出‘X’，如果不为0则按照字母表输出字符‘A’后第array[i]个字符。程序运行后的输出结果为：FDBXX，A选项正确。');
INSERT INTO `exercises` VALUES ('87', '有以下程序\r\n#include <stdio.h>\r\nmain()\r\n{  \r\n    char  *s=\"12134\";\r\n    int  k=0, a=0 ;\r\n    while( s[ k +1 ] )\r\n    {  \r\n        k++;\r\n        if ( k % 2 ==0 ) \r\n        {\r\n             a = a + ( s[ k ] - \'0\' +1 ) ; \r\n             continue; \r\n        }\r\n        a = a + ( s[ k ] - \'0\' );\r\n    }\r\n    printf (\" k=%d a=%d\\n\", k, a );\r\n}\r\n程序运行后的输出结果是()。', 'k=5 a=15', 'k=4 a=12', 'k=6 a=11', 'k=3 a=14', 'B', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '当k=0时，执行while一次，得到k=1，a为2；当k=1时，执行while一次，得到k=2，a为4；当k=2时，执行while一次，得到k=3，a为7；当k=3时，执行while一次，得到k=4，a为12；所以答案为B选项。');
INSERT INTO `exercises` VALUES ('88', '有以下程序\r\n    #include <stdio.h>\r\n    main()\r\n    {  int  a, b;     \r\n       for( a=1,b=1; a<=100; a++ )\r\n       {  if(b>=20) break;\r\n          if(b % 3==1) {  b=b+3; continue; }\r\n          b=b-5;\r\n       }\r\n       printf(\"%d\\n\",a);\r\n    }\r\n程序的输出结果是()。', '10', '9', '8', '7', 'C', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '首先注意for循环的控制条件当b>=20或者a>100则跳出for循环也即b<20且a<=100时执行for循环；第一次进入循环a=1,b=1均满足循环条件，但b%3==1条件满足，故执行b=b+3，得到b=4,注意有continue，所以后面语句不执行，直接跳转到a++这个语句，所以第一次循环完之后a=2,b=4；进入第二轮循环，b%3==1也是满足的，故再次b=b+3，此轮循环执行之后a=3,b=7,进入下一轮。此后和前面循环同理，都是b%3==1满足，因为每次都是加3，而之后又去模3，且都跳过for后面语句直接执行a++，所以，一直循环到b=22跳出for循环。此时a为8. 综合起来就是，每次循环b增加3，a增加1，且当b>22时跳出循环，结束程序。所以b从1增加到22，有(22-1)/3=7,所以a=1+7=8. 因此C选项正确。');
INSERT INTO `exercises` VALUES ('89', '设有一个M*N的矩阵已经存放在一个M行N列的数组x中，且有以下程序段\r\n       sum=0;\r\n       for(i=0;i<M;i++)  sum+=x[i][0]+x[i][N-1];\r\n       for(j=1;j<N-1;j++) sum+=x[0][j]+x[M-1][j];\r\n以上程序段计算的是', '矩阵两条对角线元素之和', '矩阵所有不靠边元素之和', '矩阵所有元素之和 ', '矩阵所有靠边元素之和', 'D', '2', '3', '2018年3月二级《C语言》临考猜想卷', null, '程序执行过程为：第一个for循环实现对第一列和第N列求和。第二个for循环在上一个for循环结果上实现对第一行和第M行从第二个元素到第N-1个元素的求和，总体来说，就是矩阵所有靠边元素之和，D选项正确。');
INSERT INTO `exercises` VALUES ('90', '若有以下程序\r\n     #include <stdio.h>\r\n     void fun(int  a[ ], int  n)\r\n     {  int  t, i, j;\r\n        for ( i=0;  i<n;  i+=2 )\r\n           for ( j=i+2;  j<n;  j+=2 )\r\n             if ( a[i] > a[j] ) {  t=a[i];  a[i]=a[j];  a[j]=t; }\r\n     }\r\n     main()\r\n     {  int  c[10]={10,9,8,7,6,5,4,3,2,1},i;\r\n        fun(c, 10);\r\n        for ( i=0; i<10;  i++ )  printf(\"%d,\", c[i]);\r\n        printf(\"\\n\");\r\n     }\r\n则程序的输出结果是()。', '1,10,3,8,5,6,7,4,9,2,', '10,9,8,7,6,5,4,3,2,1,', '10,1,8,3,6,5,4,7,2,9,', '2,9,4,7,6,5,8,3,10,1,', 'D', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '该题首先对一维数组进行初始化,c[0]到c[9]依次赋值为10到1;fun(c, 10);语句调用fun函数,fun函数的功能是将一维数组奇数位元素的数值由小到大排序;最后将排好序的新的一维数组进行输出｡因此D选项正确｡');
INSERT INTO `exercises` VALUES ('91', '若有以下程序\r\n     #include <stdio.h>\r\n     #define  N  4\r\n     void fun( int  a[][N], int  b[], int  flag )\r\n     {  int  i,j;\r\n        for( i=0; i<N; i++ ) \r\n        {  b[i] = a[0][i];\r\n           for( j=1; j<N; j++ )\r\n              if (flag ? (b[i] > a[j][i]) : (b[i] < a[j][i]))       b[i] = a[j][i];\r\n        }\r\n     }\r\n     main()\r\n     {  int  x[N][N]={1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16}, y[N],i;\r\n        fun(x, y, 1);\r\n        for (i=0;i<N; i++)   printf(\"%d,\", y[i]);\r\n        fun(x, y, 0);\r\n        for (i=0;i<N; i++)   printf(\"%d,\", y[i]);\r\n        printf(\"\\n\"); \r\n     }\r\n则程序的输出结果是', '4,8,12,16,1,5,9,13,', '1,2,3,4,13,14,15,16,', '1,5,9,13,4,8,12,16,', '13,14,15,16,1,2,3,4,', 'B', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '该题首先初始化二维数组，if (flag ? (b[i] > a[i][j]) : (b[i] < a[i][j]))条件语句的条件表达式使用了条件运算符构成的选择结构，即flag为真时，以(b[i] > a[i][j])作为条件表达式的值，否则以(b[i] < a[i][j])作为条件表达式的值，fun函数功能是给一维数组赋值。fun(x, y, 1);该函数调用后，即当flag为真时，使一维数组获得二维数组第1行的数值；fun(x, y, 0);该函数调用后，即当flag为假时，使一维数组获得二维数组第4行的数值；因此B选项正确。');
INSERT INTO `exercises` VALUES ('92', '有以下程序\r\n#include <stdio.h>\r\nvoid fun1(char *p)\r\n{ \r\n    char  *q;\r\n    q=p;\r\n    while(*q!=\'\\0\')\r\n    {  \r\n        (*q)++;  \r\n        q++;  \r\n    }\r\n}\r\nmain()\r\n{ \r\n    char  a[]={\"Program\"}, *p;\r\n    p=&a[3];  \r\n    fun1(p);  \r\n    printf(\"%s\\n\",a);\r\n\r\n}\r\n程序执行后的输出结果是()。', 'Prphsbn', 'Prohsbn', 'Progsbn', 'Program', 'B', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '(*q)++是q所指的字符加1，q++就是指针移到下一个字符。因此B选项正确。');
INSERT INTO `exercises` VALUES ('93', '有以下程序\r\n#include  <stdio.h>\r\n#include  <string.h>\r\nvoid  fun( char *s, int m1, int m2 )\r\n{  char  t, *p;\r\n   p=s + m1;  s= s+m2;\r\n   while( s<p )\r\n   {  t=*s;  *s=*p;  *p=t; \r\n      s++;   p--;\r\n   }\r\n}\r\nmain()\r\n{   char  ss[10]=\"012345678\";\r\n    int  n=6;\r\n    fun( ss,0,n-1 );\r\n    fun( ss,9,n );\r\n    fun( ss,0,9 );\r\n    printf(\"%s\\n\", ss );\r\n}\r\n程序运行后的输出结果是()。', '012345', '876543210', '876543', '012345678', 'A', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, 'fun(*ss, m1, m2 )的作用是，如果m1>m2交换数组元素ss[m1]，ss[m2]。因此，fun(ss,0,5)后ss的0,1,2,3,4,5,6,7,8,\\0。fun(ss,9,6) 后ss的0,1,2,3,4,5, \\0,8,7,6。fun(ss,0,9)后ss的0,1,2,3,4,5,\\0,8,7,6。因此打印结果012345。故答案为A选项');
INSERT INTO `exercises` VALUES ('94', '有以下程序\r\n#include   <stdio.h>\r\ntypedef  struct  stu {\r\n                       char  name[10];\r\n                       char  gender;\r\n                       int  score; \r\n                     } STU;\r\nvoid  f( STU  a, STU  *b, STU  c )\r\n{  *b = c =a;\r\n   printf( \"%s,%c,%d,\", b->name, b->gender, b->score );\r\n   printf( \"%s,%c,%d,\", c.name, c.gender, c.score );\r\n}\r\nmain( )\r\n{  STU  a={\"Zhao\", \'m\', 290}, b={\"Qian\", \'f\', 350}, c={\"Sun\", \'m\', 370};\r\n   f( a, &b, c );\r\n   printf( \"%s,%c,%d,\", b.name, b.gender, b.score );\r\n   printf( \"%s,%c,%d\\n\", c.name, c.gender, c.score );\r\n}\r\n程序运行后的输出结果是()。', 'Zhao,m,290,Zhao,m,290,Zhao,m,290,Sun,m,370', 'Zhao,m,290,Zhao,m,290,Zhao,m,290,Zhao,m,290', 'Zhao,m,290,Zhao,m,290,Qian,f,350,Sun,m,370', 'Zhao,m,290,Zhao,m,290,Qian,f,350,Zhao,m,290', 'A', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, 'C语言函数参数传递分为：1、值传递过程中，被调函数的形参作为被调函数的局部变量处理，即在内存的堆栈中开辟空间以存放由主调函数放进来的实参的值，从而成为了实参的一个拷贝。值传递的特点是被调函数对形参的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。2、地址传递过程中，被调函数的形参虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。题设中，参数b是地址传递，因此会直接影响实参变量。a,c是值传递，传递是a,c的拷贝，不会a,c实参产生影响，因此，调用函数返回，c没有被修改，b被修改了。故答案为A选项。');
INSERT INTO `exercises` VALUES ('95', '有以下程序：\r\n#include   <stdio.h>\r\n#include   <stdlib.h>\r\nint  fun(int   n)\r\n{　 int  *p；\r\n　　p ＝ (int*)malloc(sizeof(int))；\r\n　　*p＝n；    return  *p；\r\n}\r\nmain()\r\n{　 int   a；\r\n　　a ＝ fun(10)；    printf(\"%d\\n\"，a＋fun(10))；\r\n}\r\n程序的运行结果是(　　)。', '0', '10', '20', '出错', 'C', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, 'malloc(sizeof(int))的作用是开辟一个长度为sizeof(int)存储空间，并通过强制类型转换(int*)将此存储空间的地址赋给了一个整型的指针变量p。然后执行语句*p＝n，使得*p的值为10，并通过return返回此值，即a的值为10。然后在主函数中输出a＋fun(10)＝10＋10＝20。');
INSERT INTO `exercises` VALUES ('96', '有以下程序\r\n#include <stdio.h>\r\n#define f(x) x*x*x\r\nmain()\r\n{  \r\n    int a=3,s,t ;\r\n    s=f(a+1); \r\n    t=f((a+1));\r\n    printf(\"%d,%d\\n\",s,t);\r\n}程序运行后的输出结果是()。', '10,64', '10,10', '64,10', '64,64', 'A', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, '本题考查宏定义的用法，宏定义只是做个简单的替换，所以本题中执行f(a+1)=a+1*a+1*a+1=3*a+1=10,f((a+1))=(a+1)*(a+1)*(a+1)=64,所以答案为A选项。');
INSERT INTO `exercises` VALUES ('97', '有以下程序\r\n#include   <stdio.h>\r\nmain( ) \r\n{\r\n    int  i;\r\n    FILE*  fp;\r\n    for (i=0; i<3; i++)\r\n    {\r\n        fp = fopen(\"res.txt\", \"w\");\r\n        fputc(\'K\' + i, fp);\r\n        fclose(fp);\r\n    }\r\n}\r\n程序运行后，在当前目录下会生成一个res.txt文件，其内容是()。', 'EOF', 'M', 'KLM', 'L', 'B', '3', '3', '2018年3月二级《C语言》临考猜想卷', null, 'for循环中，每次都执行打开文件res.txt、写入文件、再关闭文件的操作，由于fopen函数使用\'w\'模式写文件，所以每次打开res.txt后，都删除文件中的原有数据，再重新写入新数据。所以文件最终的内容只与最后一次for循环有关，最后一次for循环是向文件res.txt写入\'K\'+2， 即M，正确答案是B选项。');
INSERT INTO `exercises` VALUES ('98', '算法空间复杂度的度量方法是', '算法程序的长度', '算法所处理的数据量', '执行算法所需要的工作单元', '执行算法所需要的存储空间', 'D', '1', '4', '2018年3月二级《C语言》考前猜想卷', null, '算法的空间复杂度是指执行这个算法所需要的内存空间，。算法执行期间所需的存储空间包括3个部分：输入数据所占的存储空间；程序本身所占的存储空间；算法执行过程中所需要的额外空间。D选项正确。');
INSERT INTO `exercises` VALUES ('99', '下列叙述中正确的是', '循环队列属于队列的链式存储结构', '双向链表是二叉树的链式存储结构', '非线性结构只能采用链式存储结构', '有的非线性结构也可以采用顺序存储结构', 'D', '1', '4', '2018年3月二级《C语言》考前猜想卷', null, '循环队列是队列的一种顺序存储结构，A选项错误。双向链表为顺序存储结构，二叉树通常采用链式存储结构，B选项错误。完全二叉树是属于非线性结构，但其最佳存储方式是顺序存储方式，C选项错误，D选项正确。');
INSERT INTO `exercises` VALUES ('100', '下列叙述中正确的是(　　)。', '顺序存储结构的存储一定是连续的，链式存储结构的存储空间不一定是连续的', '顺序存储结构只针对线性结构，链式存储结构只针对非线性结构', '顺序存储结构能存储有序表，链式存储结构不能存储有序表', '链式存储结构比顺序存储结构节省存储空间', 'A', '1', '4', '2018年3月二级《C语言》考前猜想卷', null, '链式存储结构既可以针对线性结构也可以针对非线性结构，所以B)与C)错误。链式存储结构中每个结点都由数据域与指针域两部分组成，增加了存储空间，所以D)错误。');
INSERT INTO `exercises` VALUES ('101', '下列关于栈的叙述中，正确的是', '栈底元素一定是最后入栈的元素', '栈顶元素一定是最先入栈的元素', '栈操作遵循先进后出的原则', '以上说法均错误', 'C', '1', '4', '2018年3月二级《C语言》考前猜想卷', null, '栈顶元素总是后被插入的元素，从而也是最先被删除的元素；栈底元素总是最先被插入的元素，从而也是最后才能被删除的元素。栈的修改是按后进先出的原则进行的。因此，栈称为先进后出表，或\"后进先出\"表，所以选择C。');
INSERT INTO `exercises` VALUES ('102', '在软件设计中不使用的工具是(　　)。', '系统结构图 ', 'PAD图', '数据流图(DFD图) ', '程序流程图', 'C', '1', '4', '2018年3月二级《C语言》考前猜想卷', null, '系统结构图是对软件系统结构的总体设计的图形显示。在需求分析阶段，已经从系统开发的角度出发，把系统按功能逐次分割成层次结构，是在概要设计阶段用到的。PAD图是在详细设计阶段用到的。程序流程图是对程序流程的图形表示，在详细设计过程中用到。数据流图是结构化分析方法中使用的工具，它以图形的方式描绘数据在系统中流动和处理的过程，由于它只反映系统必须完成的逻辑功能，所以它是一种功能模型，是在可行性研究阶段用到的而非软件设计时用到，所以选择C)。');
INSERT INTO `exercises` VALUES ('103', '下面对类-对象主要特征描述正确的是（）。', '对象唯一性 ', '对象无关性 ', '类的单一性    ', '类的依赖性', 'A', '1', '4', '2018年3月二级《C语言》考前猜想卷', null, '对象的基本特点是：标识唯一性、分类性、多态性、封装性、模块独立性好。类是具有共同属性、共同方法的对象的集合，是关于对象的抽象描述，反映属于该对象类型的所有对象的性质。对象具有的性质，类也具有。故A选项正确。');
INSERT INTO `exercises` VALUES ('104', '在软件开发中，需求分析阶段产生的主要文档是(　　)。', '可行性分析报告 ', '软件需求规格说明书', '概要设计说明书', '集成测试计划', 'B', '1', '4', '2018年3月二级《C语言》考前猜想卷', null, 'A)错误，可行性分析阶段产生可行性分析报告。C)错误，概要设计说明书是总体设计阶段产生的文档。D)错误，集成测试计划是在概要设计阶段编写的文档。B)正确，需求规格说明书是后续工作如设计、编码等需要的重要参考文档。');
INSERT INTO `exercises` VALUES ('105', '下面对软件测试描述错误的是（）。', '严格执行测试计划，排除测试的随意性', '随机地选取测试数据', '测试根本目的是尽可能多地发现并排除软件中隐藏的错误', '软件测试是保证软件质量的重要手段', 'B', '1', '4', '2018年3月二级《C语言》考前猜想卷', null, '在测试之前制定测试计划，并严格执行，测试用例的选择不可随意，应选择有代表性的，尽可能发现迄今为止尚未发现的错误，A选项叙述正确，B选项叙述错误。测试根本目的是尽可能多地发现并排除软件中隐藏的错误，C选项叙述正确。软件测试是保证软件质量、可靠性的关键步骤，D选项叙述正确。故正确答案为B选项。');
INSERT INTO `exercises` VALUES ('106', '在数据库系统中，用于对客观世界中复杂事物的结构及它们之间的联系进行描述的是', '概念数据模型', '逻辑数据模型', '物理数据模型', '关系数据模型', 'A', '1', '4', '2018年3月二级《C语言》考前猜想卷', null, '数据模型按照不同的应用层次分为以下3种类型：概念数据模型，着重于对客观世界复杂事物的描述及对它们内在联系的刻画；逻辑数据模型，是面向数据库系统的模型，着重于在数据库系统一级的实现；物理数据模型，是面向计算机物理实现的模型，此模型给出了数据模型在计算机上物理结构的表示。A选项正确。');
INSERT INTO `exercises` VALUES ('107', '公司中有多个部门和多名职员，每个职员只能属于一个部门，一个部门可以有多名职员。则实体部门和职员间的联系是', '1：1联系', 'm：1联系', '1：m联系', 'm：n联系', 'C', '1', '4', '2018年3月二级《C语言》考前猜想卷', null, '两个实体集间的联系实际上是实体集间的函数关系，主要有一对一联系（1:1）、一对多联系（1:m）、多对一联系（m:1）、多对多联系（m:n）。对于每一个实体部门，都有多名职员，则其对应的联系为一对多联系（1:m），答案选C。');
INSERT INTO `exercises` VALUES ('108', '关于程序中的注释，以下叙述正确的是（）。', '注释的内容必须放在一对/* 和 */之间', '注释必须置于所说明的语句前或语句后', '注释中间可以嵌套另一个注释 ', '注释内容错误会导致编译出错', 'A', '1', '4', '2018年3月二级《C语言》考前猜想卷', null, '程序中，注释可以出现在程序的任何位置，B选项错误；注释中间不能嵌套另一个注释，C选项错误；注释内容不影响程序编译，D选项错误，答案为A选项。');
INSERT INTO `exercises` VALUES ('109', '有以下程序\r\n#include <stdio.h>\r\nmain()\r\n{  int  k=-17; \r\n   printf(\"%d,%o,%x\\n\", k, 1-k, 1-k);\r\n}\r\n程序的运行结果是（）。', '-17,22,12', '-17,12,22', '-17,-22,-12', '17,22,12', 'A', '2', '4', '2018年3月二级《C语言》考前猜想卷', null, '整型常量有3种表示方法，分别是十进制数表示法、八进制数表示法和十六进制数表示法。十进制整常量没有前缀，输出格式控制符为%d；八进制整常量以０作为前缀，输出格式控制符为%o；十六进制整常量以0X或0x作为前缀，输出格式控制符为%x。1-k=18，整型常量18用八进制表示为22，十六进制表示为12，A选项正确。');
INSERT INTO `exercises` VALUES ('110', '以下定义语句中正确的是（）。', 'int  a=b=0;', 'char  A=65+1,b=\'b\';', 'float  a=1,*b=&a,*c=&b;', 'double  a=0.0; b=1.1;', 'B', '2', '4', '2018年3月二级《C语言》考前猜想卷', null, 'A选项语句中b变量还没有定义不能直接用于给a变量赋值｡C选项语句中*b､*c表示的是一个实型变量的地址,不能再将&b赋值给指针型变量c｡D选项语句中a=0.0后面应该为逗号,不能是分号｡');
INSERT INTO `exercises` VALUES ('111', '有以下程序：\r\n#include  <stdio.h>\r\nmain()\r\n{　 int s，t，A＝10； double B＝6；\r\n　　s＝sizeof(A)； t＝sizeof(B)；\r\n　　printf(\"%d，%d\\n\"，s，t)；\r\n}\r\n在VC6.0平台上编译运行，程序运行后的输出结果是(　　)。', '10,6', '4,4 ', '2,4', '4,8', 'D', '2', '4', '2018年3月二级《C语言》考前猜想卷', null, 'C语言中利用sizeof()函数判断数据类型长度，在VC6.0平台中，整型int占有4个字节，double型数据占有8个字节。');
INSERT INTO `exercises` VALUES ('112', '表达式：(int)((double)9/2)- 9%2 的值是（）。', '0', '3', '4', '5', 'B', '2', '4', '2018年3月二级《C语言》考前猜想卷', null, '先将整型数据9强制转换成double型,然后除以2得到的结果与double型保持一致,即为4.5,然后将4.5强制转换成整型数据4,然后计算9%2的值为1,最后计算4-1的值为3,所以选择B选项｡');
INSERT INTO `exercises` VALUES ('113', '设有定义：int x=11,y=12,z=0;，以下表达式值不等于12的是（）。', '(z,x,y)', '(z=x,y)', 'z=(x,y)', 'z=(x==y)', 'D', '2', '4', '2018年3月二级《C语言》考前猜想卷', null, '逗号表达式的计算过程是从左到右逐个求每个表达式的值，取最右边一个表达式的值作为该逗号表达式的值。赋值运算结合性为由右向左结合，赋值运算符左值为变量，右值为变量或常量，且左右两边数据类型相同才能实现赋值。成功实现赋值后以左值为返回值。逻辑表达式成立则返回1，不成立返回0。A选项逻辑表达式x==y不成立，则z=0，表达式值为0。B选项中逗号表达式x,y取y值为表达式值，然后赋值给z=12，表达式值为12。C选项逗号表达式(x,y)取y值为表达式值，然后赋值给z=12，表达式值为12。D选项逗号表达式(z,x,y)取y值为表达式值12。选择D选项。');
INSERT INTO `exercises` VALUES ('114', '若有定义：int a=0,b=0,c=0,d=0; ，有C语言表达式 (a++ && b++) ? c++ : d++,以下关于其执行顺序的叙述正确是（）。', '先执行a++，表达式a++的值为0，由此即可确定（a++&&b++)的值为0，因此执行d++', '先执行a++，表达式a++的值为0；再执行b++，表达式b++的值为0，由此可确定(a++ && b++)值为0，因此执行d++', '先执行a++，表确定(a++ && b++)值为1，因此执行c++达式a++的值为1；再执行b++，表达式b++的值为1，由此可', '先执行b++，表达式b++的值为1；再执行a++，表达式a++的值为1，由此可确定(a++ && b++)值为1，因此执行c++', 'A', '2', '4', '2018年3月二级《C语言》考前猜想卷', null, '表达式1？表达式2：表达式3，若表达式1为真，则执行表达式2，否则执行表达式3。逻辑与运算符遵循\"短路求值\"策略，即只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解右操作数，表达式(a++&&b++)中，左操作数a++的值为0，已经可以确定整个逻辑表达式的结果为0，因此右操作数b++不再求解，直接执行表达式3，即d++，答案为A选项');
INSERT INTO `exercises` VALUES ('115', '有以下程序：\r\n# include   <stdio.h>\r\nmain()\r\n{ unsigned char  a＝2， b＝4， c＝5， d；\r\n  d ＝ a | b；    d &＝ c；    printf(\"%d\\n\"， d)；     }\r\n程序运行后的输出结果是(　　)。', '3', '4', '5', '6', 'B', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '& 按位与，如果两个相应的二进制位都为1，则该位的结果值为1，否则为0。| 按位或，两个相应的二进制位中只要有一个为1，该位的结果值为1。2的二进制为00000010,4的二进制为00000100，所以做或运算结果为00000110，该数与5即00000101做与操作结果为00000100，即4');
INSERT INTO `exercises` VALUES ('116', '有以下程序\r\n#include <stdio.h>\r\nmain( )\r\n{  char c;\r\n   c=getchar();\r\n   do {\r\n      putchar(c++);\r\n   } while((c=getchar()) != \'#\');\r\n}\r\n程序运行时从第一列开始输入：abcdefg##<回车>，则输出结果是（）。', 'bcdefgh$', 'bcdefgh', 'abcdefg#', 'abcdefg', 'D', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '运算符\"++\"放在变量后面时，先参与其他操作，再对变量+1。putchar(c++)表示先输出当前c值，再对c值+1，当输入abcdef##时，在while语句中，程序输入\"#\"，循环退出。因此输出为abcdefg，答案为D选项。');
INSERT INTO `exercises` VALUES ('117', '若有定义：char  c; int  d; ，程序运行时输入： 1,2 <回车>，能把值1输入给变量c、值2输入给变量d的输入语句是', 'scanf(\"%c,%d\", &c,&d);', 'scanf(\"%c%d\", &c,&d);', 'scanf(\"%d,%f\", &c,&d);', 'scanf(\"%d%d\", &c,&d);', 'A', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, 'scanf函数的调用格式为：scanf(格式控制串，地址列表)；，格式控制串，由%开头，后跟格式字符，如c对应字符型变量，d对应整型变量。地址表列需要读入的是所有变量的地址或字符串的首地址。如果除了格式说明字符和附加格式字符外，如果还有其他字符，则在输入数据时要求按一一对应的位置原样输入这些字符，比如两个格式说明之间有一个逗号，则从键盘输入时输入量之间也应照原样输入逗号。A选项正确。');
INSERT INTO `exercises` VALUES ('118', '有以下程序\r\n#include <stdio.h>\r\nmain()\r\n{  int a=1,b=2,c=3,d=0;\r\n   if (a==1 && b++==2)\r\nif (b!=2||c--!=3)\r\nprintf(\"%d,%d,%d\\n\",a,b,c);\r\n      else  printf(\"%d,%d,%d\\n\",a,b,c);\r\n   else  printf(\"%d,%d,%d\\n\",a,b,c);\r\n}\r\n程序运行后的输出结果是（）。', '1,3,2', '1,3,3', '1,2,3', '3,2,1', 'B', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, 'else总是和最近的if配对,所以进入第一个if语句中条件判断时,因为是逻辑与操作需要两边运算对象的值均为非零值,才为真,所以需要逐个执行判断的结果为1,不再执行第二个case语句中的操作｡而是进入第二个if语句条件判断,因为b!=2条件成立所以整个条件表达式的值为真,所以不再执行逻辑或的第二个运算对象(c-- !=3)c的值不变,也不再执行第一个else语句｡打印a的值1,b的值3,c的值3｡');
INSERT INTO `exercises` VALUES ('119', '有以下程序\r\n    #include <stdio.h>\r\n    main()\r\n    {   int  s;\r\n        scanf(\"%d\", &s);\r\n        while( s>0 )  \r\n        {  switch(s) \r\n           {  case 1: printf(\"%d\", s+5);\r\n             case 2: printf(\"%d\", s+4); break;\r\n             case 3: printf(\"%d\", s+3);\r\n             default: printf(\"%d\", s+1); break; \r\n           }\r\n           scanf(\"%d\", &s);\r\n        }\r\n    }\r\n运行时，若输入1 2 3 4 5 0<回车>，则输出结果是（）。', '66656', '6566456', '66666', '6666656', 'B', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, 'switch语句的执行流程是:首先计算switch后面圆括号中表达式的值,然后用此值依次与各个case的常量表达式比较,若圆括号中表达式的值与某个case后面的常量表达式的值相等,就执行此case后面的语句,执行后遇break语句就退出switch语句;若圆括号中表达式的值与所有case后面的常量表达式都不等,则执行default后面的语句｡然后退出｡所以输入1时打印65,输入2时打印6,输入3时打印64,输入4时打印5,输入5时打印6｡');
INSERT INTO `exercises` VALUES ('120', '设有以下代码\r\ndo {\r\n   while (条件表达式1)\r\n        循环体A;\r\n} while (条件表达式2);\r\nwhile (条件表达式1)\r\n{\r\n   do {\r\n      循环体B;\r\n   } while (条件表达式2);\r\n}\r\n其中，循环体A与循环体B相同，以下叙述正确的是（）。', '循环体A与循环体B的执行次数相同', '循环体A比循环体B的执行次数多一次', '循环体A比循环体B的执行次数少一次', '循环体A与循环体B的执行次数不确定', 'A', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, 'while循环语句一般形式为：while(表达式){循环体}，执行过程为：首先判断表达式，成立（非0）则执行循环体，不成立（0）则退出循环。do…while循环语句一般形式为：do{循环体}while(表达式)，执行过程为：首先执行循环体，之后判断表达式，成立（非0）则再一次执行循环体，不成立（0）则退出循环。假设表达式1与表达式2成立次数为n1与n2。若n1>n2，则循环体A执行次数为n2+1，B执行次数n2+1；若n1<n2，则循环体A执行次数为n1，B执行次数n1，A选项正确。');
INSERT INTO `exercises` VALUES ('121', '有以下程序\r\n#include <stdio.h>\r\nmain( )\r\n{  int a=0, b=0;\r\n   for(; a<5; a++)\r\n   {  if (a%2==0) continue;\r\n      b += a;\r\n      break;\r\n   }\r\n   printf(\"%d \\n\", b);\r\n}\r\n程序运行后的输出结果是（）。', '1', '4', '0', '10', 'A', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, 'for语句中，当a=0时，满足for循环中if语句的条件，执行continue继续下一次循环，a+1后再进入for语句循环，此时a=1不满足if语句，执行b=b+a为1，接着执行break语句，终止循环，最后输出b=1,故答案为A选项。');
INSERT INTO `exercises` VALUES ('122', '有以下程序\r\n    #include <stdio.h>\r\n    main()\r\n    {  int   i=5;\r\n       do\r\n       {  if (i%3==1)\r\n            if (i%5==2)\r\n            {  printf(\"*%d\", i);  break;  }\r\n          i++;\r\n       }  while(i!=0);\r\n       printf(\"\\n\");\r\n    }\r\n\r\n程序的运行结果是', '*2*6', '*3*5', '*5', '*7', 'D', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, 'do...while语句是先执行后判断,所以第一次先执行循环体,判断i%3= =1的条件,由于i为5所以余数为2,条件不成立,执行i++,i的值为6,判断while条件为真,第二次执行循环体,同第一次循环体的执行过程一样,i的值变为7,判断while条件为真,第三次执行循环体,此时i%3= =1条件成立,判断i%5==2也成立,打印*与i的值,即*7,然后执行break语句,跳出循环｡所以选择D选项｡');
INSERT INTO `exercises` VALUES ('123', '有以下程序\r\n     #include <stdio.h>\r\n     main()\r\n     {  int  c[6]={10,20,30,40,50,60},  *p,*s;\r\n        p = c;    s = &c[5];\r\n        printf(\"%d\\n\", s-p );\r\n     }\r\n程序运行后的输出结果是（）。', '5', '50', '6', '60', 'A', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '首先初始化一维数组c[6]，语句p = c;指将c[0]元素的地址赋给指针变量p；语句s = &c[5];指将c[5] 元素的地址赋给指针变量s。程序最后输出s-p，即结果为5。因此A选项正确。');
INSERT INTO `exercises` VALUES ('124', '有以下程序\r\n#include  <stdio.h>\r\nvoid  fun( int  a[ ], int  n, int  flag )\r\n{  int  i=0,j, t;\r\n   for ( i=0; i<n-1; i++ )\r\n      for ( j=i+1; j<n; j++ )\r\n        if ( flag )\r\n\r\n        {   if ( a[i] < a[j] )\r\n            {  t = a[i];  a[i] = a[j];  a[j] = t;  }\r\n        }\r\n       else\r\n       {   if ( a[i] > a[j] )\r\n           {  t = a[i];  a[i] = a[j];  a[j] = t;  }\r\n       }\r\n}\r\nmain( )\r\n{  int  c[10]={ 7,9,10,8,3,5,1,6,2,4 },i;\r\n   fun( c, 4, 1 );\r\n   fun( c+4, 6, 0 );\r\n   for ( i=0;i<10; i++ )    printf( \"%d,\", c[i] );\r\n   printf(\"\\n\");\r\n}\r\n程序运行后的输出结果是（）。', '7,8,9,10,6,5,4,3,2,1', '10,9,8,7,6,5,4,3,2,1', '10,9,8,7,1,2,3,4,5,6,', '1,2,3,4,5,6,7,8,9,10,', 'C', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, 'fun()函数作用冒泡法排序，flag控制升序（0）或者降序（1）。n为参与排序的个数。a为数组的起始地址。因此，fun(a,4,1),数组的前四个降序排序，fun(a+4,6,0)从数组的第四项，后六个升序排序。故结果为10,9,8,7,1,2,3,4,5,6。答案为C选项');
INSERT INTO `exercises` VALUES ('125', '下列选项中，能正确定义数组的语句是（）。', 'int num[0...2008];', 'int num[];', 'int N=2008;\r\nint num[N];', '#define N 2008\r\nint num[N];', 'D', '2', '4', '2018年3月二级《C语言》考前猜想卷', null, 'C语言不允许定义动态数组，定义数组的大小必须为常量表达式。A选项错误，C语言中数组没有此类型的定义方法；B选项错误，定义数组应指明数组大小，如果不指明数组大小，需要给定初值的个数；C选项错误，N为变量，不能用来定义数组大小。因此D选项正确。');
INSERT INTO `exercises` VALUES ('126', '有以下程序\r\n    #include <stdio.h>\r\n    main()\r\n    { \r\n        int  a[4][4]={{1,4,3,2},\r\n                      {8,6,5,7},\r\n                      {3,7,2,5},\r\n                      {4,8,6,1}};\r\n        int i, j, k, t;\r\n        for (i=0; i<4; i++)\r\n            for (j=0; j<3; j++)\r\n                for (k=j+1; k<4; k++)\r\n                    if (a[j][i] > a[k][i]) \r\n                       { \r\n                           t=a[j][i]; \r\n                           a[j][i] = a[k][i]; \r\n                           a[k][i] = t;\r\n                       } /* 按列排序 */\r\n        for (i=0; i<4; i++) \r\n            printf(\"%d, \",a[i][i]);\r\n    }\r\n程序运行后的输出结果是（）。', '1, 6, 2, 1,', '8, 7, 3, 1,', '4, 7, 5, 2,', '1, 6, 5, 7,', 'D', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '首先对二维数组进行赋值操作，a[0][0]、a[0][1]、…、a[3][2]、a[3][3]的值为1、4、…、6、1。通过for语句和if语句，对二维数组各列元素进行由小到大的排序操作，程序最后通过for语句输出二维数组对角线上的元素。因此D选项正确。');
INSERT INTO `exercises` VALUES ('127', '有以下程序\r\n#include <stdio.h>\r\nmain( )\r\n{  char w[20], a[5][10] = {\"abcdef\", \"ghijkl\", \"mnopq\", \"rstuv\", \"wxyz\"};\r\n   int i,j;\r\n   for (i=0; i<5; i++)\r\n   {   j=0;\r\n       while (a[i][j]!=\'\\0\')  j++;\r\n       w[i] = a[i][j/2+1];\r\n   }\r\n   w[5]= \'\\0\';\r\n   puts(w);\r\n}\r\n程序运行后的输出结果是（）。', 'ekpuz ', 'agmrw ', 'flqvz ', 'djoty', 'A', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '在for循环中，执行完while语句，j值为字符串数组a的每行字符串的长度，因此w[i] = a[i][j/2+1]，数组a的元素a[i][j/2+1]的值赋给一维数组w[i]。比如i=0;j=6;a[i][j/2+1]=a[0][4]=\'e\'，将此值赋给w[0]。循环依次给数组W赋值最后输出w，答案为A选项。');
INSERT INTO `exercises` VALUES ('128', '有以下程序（strcpy为字符串复制函数，strcat为字符串连接函数) \r\n     #include <stdio.h>\r\n     #include <string.h>\r\n     main()\r\n     { char  a[10] = \"abc\", b[10] = \"012\", c[10] = \"xyz\";\r\n       strcpy( a+1, b+2 );\r\n       puts( strcat( a, c+1 ) );\r\n     }\r\n程序运行后的输出结果是（）。', 'a12xyz', 'bc2yz', 'a2yz', '12yz', 'C', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '本题考查字符串处理函数strcpy和strcat，执行完strcpy( a+1, b+2 );后，a变为a2，执行完strcat( a, c+1 )后，a变为a2yz，所以答案为C选项。');
INSERT INTO `exercises` VALUES ('129', '有以下程序\r\n     #include <stdio.h>\r\n     int f(int  n)\r\n     { int  t = 0,   a=5; \r\n       if (n/2) {int  a=6;    t += a++;  }\r\n       else    {int  a=7;     t += a++;  }\r\n       return  t + a++;\r\n     }\r\n     main()\r\n     { int  s=0, i=0;     \r\n       for (; i<2;i++)  s += f(i);\r\n       printf(\"%d\\n\", s);\r\n     }\r\n程序运行后的输出结果是', '28', '24', '32', '36', 'B', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '在主函数main()中定义了两个变量s和i，同时给s和i赋初值0。当i=0时。执行\"s+＝f(i)；\"语句，调用f()并将i的初值 0传递给形参n。首先执行if语句中内条件：n/2,条件为假。则执行else下的语句，a＝7,t＝7+0＝7，使用return返回t，t＝7+(a++)＝7+5＝12，此时a运算完后自增1,变为6；返回主函数中，s＝0+12＝12。当i=1时，执行\"s+=f(i)；\"语句，调用f()并将i的初值1传递给形参n。首先执行if语句中的条件：n/2，条件为真，执行if下面的语句，t＝0，a＝6 t＝0+6＝6，使用return返回t，t=6+6=12，返回主函数中，s＝12+12=24。最后输出的结果为24。因此B选项正确。');
INSERT INTO `exercises` VALUES ('130', '有以下程序\r\n     #include <stdio.h>\r\n     void fun( int *a,int *b)\r\n     { int *c;\r\n       c=a;a=b;b=c;\r\n     }\r\n     main()\r\n     { int  x=3, y=5, *p=&x, *q=&y ;\r\n       fun(p,q);  printf(\"%d,%d,\",*p,*q);\r\n       fun(&x,&y); printf(\"%d,%d\\n\",*p,*q);\r\n     }\r\n程序运行后的输出结果是（）。', '3,5,3,5', '3,5,5,3', '5,3,3,5', '5,3,5,3', 'A', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, 'fun函数的功能是交换形式参数的值，即交换指针变量a和b的值，但是fun函数并不能够交换实参的值，因此fun(p,q)不能交换p和q的值，所以第一个printf语句的输出为3,5。第二个fun函数对x和y的地址进行了操作，同样不能交换x和y的值，并不能影响p和q指针指向的数据，因此第二个printf语句的输出也是3,5。因此A选项正确。');
INSERT INTO `exercises` VALUES ('131', '有以下程序：\r\n#include  <stdio.h>\r\nint f(int x)；\r\nmain()\r\n{ int n＝1，m；\r\n　m＝f(f(f(n)))； printf(\"%d\\n\"，m)；\r\n}\r\nint f(int x)\r\n{ return x*2； }\r\n程序运行后的输出结果是(　　)。', '8', '2', '4', '1', 'A', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '第一次调用m＝f(f(f(1)))，第二次为m＝f(f(2))，第三次为m＝f(4)，即返回值为8。');
INSERT INTO `exercises` VALUES ('132', '设有如下函数定义：\r\n#include  <stdio.h>\r\nint  fun( int  k )\r\n{　 if (k<1)  return  0；\r\n　　else  if (k＝＝1)  return  1；\r\n　　else  return  fun(k－1)＋1；\r\n}\r\n若执行调用语句：n＝fun(3)；，则函数fun总共被调用的次数是(　　)。', '2', '3', '4', '5', 'B', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '首先 n＝fun(3),3被当作参数传递进去，这就进行了一次调用，3被当做参数传进去后，程序会执行这句 else return fun(k－1)＋1； 这就调用了第二次，而参数是3－1也就是2。2被当做参数传进去后，程序会执行这句 else return fun(k－1)＋1； 这就调用了第三次，而参数是2－1也就是1。1被当做参数传进去后，程序会执行这句 else if(k＝＝1) return 1； 不再递归调用，所以最终结果为3次。');
INSERT INTO `exercises` VALUES ('133', '以下与存储类别有关的四组说明符中，全部属于静态类的一组是（）。', 'extern和static', 'auto和static', 'register和static', 'register和extern', 'A', '2', '4', '2018年3月二级《C语言》考前猜想卷', null, 'auto用于声明变量的生存期为自动，即将不在任何类、结构、枚举、联合和函数中定义的变量视为全局变量，而在函数中定义的变量视为局部变量。这个关键字通常会被省略，因为所有的变量默认就是auto的。\r\nregister定义的变量告诉编译器尽可能的将变量存在CPU内部寄存器中而不是通过内存寻址访问以提高效率。\r\nstatic变量会被放在程序的全局存储区中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。当static用来修饰全局变量时，它就改变了全局变量的作用域。\r\nextern限制在了当前文件里，但是没有改变其存放位置，还是在全局静态储存区。extern 外部声明, 该变量在其他地方有被定义过。因此，答案为A选项');
INSERT INTO `exercises` VALUES ('134', '以下选项中的编译预处理命令行，正确的是（）。', '#define    E      2.38', '##define   PI_2   1.56', '#define    int    INT ', '#DEFINE    TRUE', 'A', '2', '4', '2018年3月二级《C语言》考前猜想卷', null, '无参宏定义格式：#define 标识符 字符串，标识符与C语言规定相同，因此，可知选项B，多了#,选项C使用c语言的关键字，选项D 格式不对。因此答案为A选项。');
INSERT INTO `exercises` VALUES ('135', '有以下程序\r\n#include <stdio.h>\r\n#define  S(x)  x/x*x\r\nmain( )\r\n{  int  k=6, j=3;\r\n   printf(\"%d,%d\\n\", S(k+j), S(j+k));\r\n}\r\n程序运行后的输出结果是（）。', '27,27', '9,9', '27,29', '29,29', 'C', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '析】定义一个带参数的宏时，字符串内的形参通常要用圆括号括起来，以避免出错，本题中，S（k+j）相当于执行运算k+j/k+j*k+j，将k,j值代入运算后取整为27，S(j+k)同理，因此答案为C选项。');
INSERT INTO `exercises` VALUES ('136', '若有以下程序段\r\n    struct  st{ int n; struct st *next; };\r\n    struct st a[3]={ 5,&a[1],7,&a[2],9,\'\\0\' },  *p;\r\n    p=&a[0];\r\n则以下选项中值为6的表达式是（）。', 'p->n', '(*p).n', 'p->n++', '++(p->n)', 'D', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '本题考查结构体变量的引用，其中a为定义的结构体数组，D选项中p->n为5，++（p->n）为6，所以D选项正确。');
INSERT INTO `exercises` VALUES ('137', '有以下程序\r\n    #include <stdio.h>\r\n    main()\r\n    {  FILE  *fp;\r\n       int   a[10]={1,2,3,0,0}, i;\r\n       fp = fopen(\"d2.dat\", \"wb\");\r\n       fwrite(a, sizeof(int), 5, fp);\r\n       fwrite(a, sizeof(int), 5, fp);\r\n       fclose(fp);\r\n       fp = fopen(\"d2.dat\", \"rb\");\r\n       fread(a, sizeof(int), 10, fp);\r\n       fclose(fp);\r\n       for (i=0; i<10; i++)\r\n            printf(\"%d,\", a[i]);\r\n    }\r\n程序的运行结果是', '1,2,3,0,0,0,0,0,0,0,', '1,2,3,1,2,3,0,0,0,0,', '123,0,0,0,0,123,0,0,0,0,', '1,2,3,0,0,1,2,3,0,0,', 'D', '3', '4', '2018年3月二级《C语言》考前猜想卷', null, '本题考查文件操作函数，两次fwrite后，fp文件中已经写入1,2,3,0,0,1,2,3,0,0然后将文件fp中的内容重新写入数组a中，最后输出a为1,2,3,0,0,1,2,3,0,0，所以选项D正确。');
INSERT INTO `exercises` VALUES ('138', '设数据集合为D={ 1,3,5,7,9 }，D上的关系为R，下列数据结构B=（D，R）中为非线性结构的是', 'R={ (5,1), (7,9), (1,7), (9,3) }', 'R={ (9,7), (1,3), (7,1), (3,5) }', 'R={ (1,9), (9,7), (7,5), (5,3) }', 'R={ (1,3), (3,5), (5,9) }', 'D', '1', '5', '2018年3月二级《C语言》考前必做题', null, '一个非空的数据结构如果满足以下两个条件：有且只有一个根结点；每一个结点最多有一个前件，也最多有一个后件，则称为线性结构，在数据结构中习惯称为线性表。A选项中，5为根结点，线性表为51793。B选项中，9为根结点，线性表为97135。C选项中，1为根结点，线性表为19753。D选项，结点1与7都是根结点，属于非线性结构，故D选项正确。');
INSERT INTO `exercises` VALUES ('139', '设栈的顺序存储空间为S(1: 50),初始状态为top=0。现经过一系列入栈与退栈运算后，top=20，则当前栈中的元素个数为', '30', '29', '20', '19', 'C', '1', '5', '2018年3月二级《C语言》考前必做题', null, '栈是一种特殊的线性表，它所有的插入与删除都限定在表的同一端进行。入栈运算即在栈顶位置插入一个新元素，退栈运算即是取出栈顶元素赋予指定变量。当栈为空时，栈顶指针top=0，经过入栈和退栈运算，指针始终指向栈顶元素。top=20，则当前栈中有20个元素，C选项正确。');
INSERT INTO `exercises` VALUES ('140', '设循环队列的存储空间为Q(1: 35)，初始状态为front=rear=35。现经过一系列入队与退队运算后，front=15，rear=15，则循环队列中的元素个数为', '15', '16', '20', '0或35', 'D', '1', '5', '2018年3月二级《C语言》考前必做题', null, '在循环队列中，用队尾指针rear指向队列中的队尾元素，用排头指针front指向排头元素的前一个位置。在循环队列中进行出队、入队操作时，头尾指针仍要加１，朝前移动。只不过当头尾指针指向向量上界时，其加１操作的结果是指向向量的下界０。由于入队时尾指针向前追赶头指针，出队时头指针向前追赶尾指针，故队空和队满时，头尾指针均相等。答案为D选项。');
INSERT INTO `exercises` VALUES ('141', '面向对象方法中，继承是指(　　)。', '一组对象所具有的相似性质', '一个对象具有另一个对象的性质', '各对象之间的共同性质', '类之间共享属性和操作的机制', 'D', '1', '5', '2018年3月二级《C语言》考前必做题', null, '继承是面向对象的方法的一个主要特征，是使用已有的类的定义作为基础建立新类的定义技术。广义的说，继承是指能够直接获得已有的性质和特征，而不必重复定义它们，所以说继承是指类之间共享属性和操作的机制。');
INSERT INTO `exercises` VALUES ('142', '下面不属于对象基本特点的是', '标识唯一性', '可复用性', '多态性', '封装性', 'B', '1', '5', '2018年3月二级《C语言》考前必做题', null, '对象的基本特点如下：\r\n特  点	描  述\r\n标识唯一性	一个对象通常可由对象名、属性和操作三部分组成\r\n分类性	指可以将具有相同属性和操作的对象抽象成类\r\n多态性	指同一个操作可以是不同对象的行为，不同对象执行同一操作产生不同的结果\r\n封装性	从外面看只能看到对象的外部特性，对象的内部对外是不可见的\r\n模块独立性好	由于完成对象功能所需的元素都被封装在对象内部，所以模块独立性好\r\n可知B选项正确。');
INSERT INTO `exercises` VALUES ('143', '数据流图中带有箭头的线段表示的是(　　)。', '控制流', '事件驱动', '模块调用', '数据流', 'D', '1', '5', '2018年3月二级《C语言》考前必做题', null, '数据流图中带箭头的线段表示的是数据流，即沿箭头方向传送数据的通道，一般在旁边标注数据流名。');
INSERT INTO `exercises` VALUES ('144', '耦合性和内聚性是对模块独立性度量的两个标准。下列叙述中正确的是(　　)。', '提高耦合性降低内聚性有利于提高模块的独立性', '降低耦合性提高内聚性有利于提高模块的独立性', '耦合性是指一个模块内部各个元素间彼此结合的紧密程度', '内聚性是指模块间互相连接的紧密程度', 'B', '1', '5', '2018年3月二级《C语言》考前必做题', null, '模块独立性是指每个模块只完成系统要求的独立的子功能，并且与其他模块的联系最少且接口简单。一般较优秀的软件设计，应尽量做到高内聚，低耦合，即减弱模块之间的耦合性和提高模块内的内聚性，有利于提高模块的独立性，所以A)错误，B)正确。耦合性是模块间互相连接的紧密程度的度量而内聚性是指一个模块内部各个元素间彼此结合的紧密程度，所以C)与D)错误。');
INSERT INTO `exercises` VALUES ('145', '某系统结构图如下图所示\r\n \r\n该系统结构图的最大扇出数是', 'n', '1', '3', '4', 'A', '1', '5', '2018年3月二级《C语言》考前必做题', null, '扇出指的是由一个模块直接调用的其他模块数。题干中某系统为一个模块，其扇出数目为n(n>3)，功能1与功能n模块扇出数均为2，故A选项正确。');
INSERT INTO `exercises` VALUES ('146', '有表示公司和职员及工作的三张表，职员可在多家公司兼职。其中公司C（公司号，公司名，地址，注册资本，法人代表，员工数），职员S（职员号，姓名，性别，年龄，学历），工作W（公司号，职员号，工资），则表W的键（码）为', '公司号，职员号', '职员号，工资', '职员号', '公司号，职员号，工资', 'A', '1', '5', '2018年3月二级《C语言》考前必做题', null, '由于职员可以再多加公司兼职，表W的键（码）应为公司关系和职员关系的主码，即公司号和职员号。');
INSERT INTO `exercises` VALUES ('147', '以下叙述中错误的是', '书写风格良好的程序执行效率高', '书写风格良好的程序易读性好', 'C程序可以在一行上写多条语句', 'C程序允许将一条语句分写在多行上', 'A', '1', '5', '2018年3月二级《C语言》考前必做题', null, '书写风格良好的程序易读性好，方便团队合作，分模块来完成复杂的程序设计，B选项叙述正确。但是书写风格与程序执行效率无关，程序执行效率与程序的数据结构有关，由算法的时间复杂度和空间复杂度决定，A选项叙述错误。C语言程序书写规范中，良好的书写习惯中一般一行上写一条语句，这样方便阅读，但是一行写多条语句是符合C程序编写规则的，C选项叙述正确。C程序允许将一条较长的语句分写在多行，D选项叙述正确。叙述中错误的是A选项,故选择A选项。');
INSERT INTO `exercises` VALUES ('148', '关于算法，以下叙述中错误的是（）。', '某个算法可能会没有输入', '同一个算法对于相同的输入必须得出相同的结果', '一个算法对于某个输入的循环次数是可以事先估计出来的', '任何算法都能转换成计算机高级语言的程序，并在有限时间内运行完毕', 'D', '1', '5', '2018年3月二级《C语言》考前必做题', null, '算法的特征:①有穷性｡一个算法(对任何合法的输入)在执行有穷步后能够结束,并且在有限的时间内完成｡②确定性｡算法中的每一步都有确切的含义｡③可行性｡算法中的操作能够用已经实现的基本运算执行有限次来实现｡④输入:一个算法有零个或者多个输入,零个输入就是算法本身确定了初始条件｡⑤输出:一个算法有一个或者多个输出,以反映出数据加工的结果｡所以选择D选项｡');
INSERT INTO `exercises` VALUES ('149', '下面选项中合法的字符常量是', '\"X\"', '\'X\'', ' \'abc\'', '\'\\\'', 'B', '2', '5', '2018年3月二级《C语言》考前必做题', null, '字符常量是用单引号括起来的一个字符。A选项中，使用双引号，所以是错误的； C选项中，\'abc\'是字符串，字符常量只能是单个字符，不能是字符串；D选项中，以反斜线\"\\\"开头的是转义字符。因此B选项正确。');
INSERT INTO `exercises` VALUES ('150', '有以下程序\r\n#include <stdio.h>\r\nmain()\r\n{\r\n   int  a, b, c=241;\r\n   a = c/100 % 9;\r\n   b = ( -1 )&&( -1 );\r\n   printf(\"%d, %d\\n\", a, b );\r\n}\r\n程序运行后的输出结果是', '2,1 ', '6,1 ', '6,0 ', '2,0', 'A', '3', '5', '2018年3月二级《C语言》考前必做题', null, '程序执行过程为：c=241，c/100=2,2%9=2,得a=2;“=”优先级低于“&&”，非0值为真，0值为假，即（-1）为真，逻辑与表达式（-1）&&（-1）为真，得b=1。A选项正确。');
INSERT INTO `exercises` VALUES ('151', '有以下程序\r\n#include   <stdio.h>\r\nint sub(double  a, double  b)\r\n{\r\n    return (int)(a - b - 1.3);\r\n}\r\nmain( )\r\n{\r\n    printf(\"%d\\n\", sub(3.2, 4.1));\r\n}\r\n程序运行后的输出结果是（）。', '-2 ', '1.7 ', '-3  ', '2.0', 'A', '3', '5', '2018年3月二级《C语言》考前必做题', null, 'sub函数输出(int)(a - b - 1.3)将结果强制转化为整型，因此可以排除B、D选项，sub(3.2,4.1)=-2,故答案为A选项。');
INSERT INTO `exercises` VALUES ('152', '若有定义：int  a=0,b=0,c=0,d=0;，以下关于C语言表达式：(++a || ++b) ? ++c : ++d 执行顺序的叙述正确的是（）。', '先执行++a，表达式++a的值为1；再执行++b，表达式++b的值为1，由此可确定(++a || ++b)值为1，因此执行++c', '先执行++a，表达式++a的值为1，由此可确定(++a || ++b)值为1，因此执行++c', '先执行++b，表达式++b的值为1；再执行++a，表达式++a的值为1，由此可确定(++a || ++b)值为1，因此执行++c', '先执行++b，表达式++b的值为1，由此可确定(++a || ++b)值为1，因此执行++c', 'B', '2', '5', '2018年3月二级《C语言》考前必做题', null, '表达式1？表达式2：表达式3，若表达式1为真，则执行表达式2，否则执行表达式3，++a表示先将变量a+1，再执行其他操作，逻辑或运算符遵循\"短路求值\"策略，即只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解右操作数，表达式(++a || ++b)中，左操作数++a的值为1，已经可以确定整个逻辑表达式的结果为1，因此右操作数++b不再求解，直接执行表达式2，即++c，答案为B选项。');
INSERT INTO `exercises` VALUES ('153', '若有定义语句：\r\n    int  a=3,b=2,c=1; \r\n以下选项中错误的赋值表达式是（）。', 'a=(b=4)=3;', 'a=b=c+1;', 'a=(b=4) +c;', 'a=1+(b=c=4);', 'A', '2', '5', '2018年3月二级《C语言》考前必做题', null, '不能将变量或常量赋给一个表达式,所以A选项中(b=4)=3是错误的');
INSERT INTO `exercises` VALUES ('154', '有以下程序\r\n     #include <stdio.h>\r\n     main()\r\n     {  int  i=0;\r\n        i = ~ i;\r\n        printf(\"%d\\n\",i);\r\n     }\r\n程序运行后的输出结果是（）。', '8', '0', '1', '-1', 'D', '3', '5', '2018年3月二级《C语言》考前必做题', null, '本题考查位运算中按位取反，0按位取反就是-1，所以选项D正确。');
INSERT INTO `exercises` VALUES ('155', '有以下程序\r\n    #include <stdio.h>\r\n    main()\r\n    { \r\n        char  c1,c2,c3,c4,c5,c6;\r\n        scanf(\"%c%c%c%c\", &c1,&c2,&c3,&c4);\r\n        c5=getchar();    \r\n        c6=getchar();\r\n        putchar(c1);         \r\n        putchar(c2);\r\n        printf(\"%c%c\\n\",c5,c6);\r\n    }\r\n程序运行后，若从键盘输入（从第1列开始) \r\n     123<回车>\r\n     45678<回车>\r\n则输出结果是（）。', '1245', '1256', '1278', '1267', 'A', '3', '5', '2018年3月二级《C语言》考前必做题', null, 'Scanf按照格式字符进行输入,所以123与回车的值分别送入了c1､c2､c3､c4变量的存储空间｡getchar()函数的功能是从键盘输入的字符串中读入一个字符,所以4送入了变量c5的存储空间,5送入了变量c6的存储空间｡所以打印时结果为1245｡');
INSERT INTO `exercises` VALUES ('156', '设有定义：\r\nint n = 1234;  \r\ndouble x = 3.1415;\r\n\r\n则语句 \r\nprintf(\"%3d,%1.3f\\n\", n, x); \r\n的输出结果是', '1234,3.142', '123,3.142', '1234,3.141', '123,3.141', 'A', '2', '5', '2018年3月二级《C语言》考前必做题', null, '函数printf()中，%md指输出带符号的十进制整数，给定最小宽度为m位，不足m位左端补空格，超过m位按实际位数输出，%.nf表示以小数形式输出实数，小数占n位，对应题目，答案为A选项。');
INSERT INTO `exercises` VALUES ('157', '设变量均已正确定义，若要通过\r\n    scanf(\"%d%c%d%c\",&a1,&c1,&a2,&c2);\r\n语句为变量a1和a2赋数值10和20，为变量c1和c2赋字符X和Y。以下所示的输入形式中正确的是（注：□代表空格字符）', '10□X<回车>\r\n20□Y<回车>', '10□X20□Y<回车>', '10X<回车>\r\n20Y<回车>', '10□X□20□Y<回车>', 'C', '2', '5', '2018年3月二级《C语言》考前必做题', null, '输入数据的格式必须与scanf()的格式控制串完全匹配,如果A、B､D选项中在数字10后面均输入了空格,则会将空格赋给变量c1,而不是把X赋给c1,所以选择C选项｡');
INSERT INTO `exercises` VALUES ('158', '有以下程序\r\n#include <stdio.h>\r\nmain()\r\n{  char b[3][10];  int i;\r\n   for (i=0; i<2; i++)\r\n      scanf(\"%s\", b[i]);\r\n   gets(b[2]);\r\n   printf(\"%s%s%s\\n\", b[0],b[1],b[2]);\r\n}\r\n执行时若从第一列输入:Fig flower is red. <回车>\r\n则输出结果是', 'Figflower is red.', 'Figfloweris red.', 'Figflowerisred.', 'Fig flower is red.', 'A', '3', '5', '2018年3月二级《C语言》考前必做题', null, 'scanf()函数从输入设备按照指定的类型输入对应类型的若干个数据，遇到空格、制表符和回车时，读取结束。gets()函数从标准输入设备键盘上读取1个字符串（可以包含空格），并将其存储到字符数组中去。此函数的读取结束符是换行符，即当遇到一个换行符时，就停止读操作，并且换行符不能够作为字符串的内容来存储，系统会自动用“\\0”来代替。可知读到第一个空格时b[0]赋值结束，为Fig，读到第二个空格时b[1]赋值结束，为flower，退出for循环执行gets()函数，空格为有效字符，b[2]=“ is red.” ，之后打印三个字符串，A选项正确。');
INSERT INTO `exercises` VALUES ('159', '若有以下程序\r\n    #include <stdio.h>\r\n    main()\r\n    {  int  a=1,b=2,c=3,d=4;\r\n       if ((a=2) || (b=1)) c=2;\r\n       if ((c==3) && (d=-1)) a=5;\r\n       printf(\"%d,%d,%d,%d\\n\", a,b,c,d);\r\n    }\r\n\r\n则程序的输出结果是（）。', '1,2,3,4', '2,1,2,-1', '5,1,2,-1', '2,2,2,4', 'D', '3', '5', '2018年3月二级《C语言》考前必做题', null, '第一个if语句的判断条件中是逻辑或表达式,所以只要有一个运算对象为真结果就为真,且如果前面的已经为真,后面的表达式不再进行执行判断｡执行第一个if判断条件时a的值为2,整个表达式的值为真,b的值不变,c的值为2｡判断第二个if条件为逻辑与表达式,只有两个运算对象均非零,才为真,第一个表达式c==3,不成立,不再判断第二个运算对象,所以不执行d=-1操作和a=5操作｡所以结果为选项D｡');
INSERT INTO `exercises` VALUES ('160', '有以下程序：\r\n#include  <stdio.h>\r\nmain()\r\n{　int   x＝1， y＝0， a＝0， b＝0；\r\n　　 switch (x)\r\n　　 {　case   1：\r\n　　　　switch(y)\r\n　　　　{　case   0：  a++；  break；\r\n　　　　　 case   1：  b++；  break；\r\n　　　　　　}\r\n　　　　 case 2：  a++；  b++；  break；\r\n　　　　 case 3：  a++；  b++；\r\n　　}\r\n　　printf(\"a＝%d， b＝%d\\n\"， a， b)；\r\n}\r\n程序的运行结果是(　　)。', 'a＝2，b＝2', 'a＝2，b＝1', 'a＝1，b＝1', 'a＝1，b＝0', 'B', '3', '5', '2018年3月二级《C语言》考前必做题', null, 'case常量表达式只是起语句标号作用，并不是该处进行条件判断。在执行switch语句时，根据switch的表达式，找到与之匹配的case语句，就从此case子句执行下去，不在进行判断，直到碰到break或函数结束为止。所以执行内层switch(y)时只执行了a++，此时a的值为1。然后执行外层case 2语句的a++；b++；a为2，b为1。所以结果为B)。');
INSERT INTO `exercises` VALUES ('161', '有以下程序\r\n#include   <stdio.h>\r\nmain( )\r\n{  int  m,n;\r\n   scanf(\"%d%d\", &m,&n);\r\n   while(m!=n)\r\n   {   while(m>n) { m=m-n; }\r\n       while(n>m) { n=n-m; }\r\n   }\r\n   printf(\"%d\\n\",m);\r\n} \r\n该程序的功能是（）。', '计算m和n的最小公倍数', '计算m和n的最大公约数', '计算m和n的差值', '找出m和n中的较大值', 'B', '3', '5', '2018年3月二级《C语言》考前必做题', null, '题目使用更相减损术求最大公约数，其思想：1、任意给定两个正整数，判断它们是否都是偶数。若是，则用2约简，若不是则执行第二步。\r\n第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。\r\n则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。\r\n因此。故答案为B选项');
INSERT INTO `exercises` VALUES ('162', '有以下程序\r\n#include  <stdio.h>\r\nmain( )\r\n{  int a=1, b=0;\r\n   for(; a<5; a++)\r\n   {  if (a%2 == 0) break;\r\n      continue;\r\n      b += a;\r\n   }\r\n   printf(\"%d \\n\", b);\r\n}\r\n程序运行后的输出结果是（）。', '0', '1', '10', '4', 'A', '3', '5', '2018年3月二级《C语言》考前必做题', null, '题干中for循环有break和continue语句，且均放在b+=a语句前面，无论if条件是否满足，b+=a都不会被执行，因此b值始终为0，答案为A选项。');
INSERT INTO `exercises` VALUES ('163', '若有以下定义\r\n    int  x[10],  *pt=x;\r\n则对x数组元素的正确引用是（）。', 'pt+3', '*&x[10]', '*(pt+10)', '*(x+3)', 'D', '2', '5', '2018年3月二级《C语言》考前必做题', null, '没有A选项的引用形式。*与&放在一起作用抵消，所以B选项错误，最大只能引用到x[9]。*(pt+i)表示引用指针pt所指元素后的第i个元素，所以C选项错误，最大只能为*(pt+9)。因此D选项正确。');
INSERT INTO `exercises` VALUES ('164', '有以下程序\r\n    #include <stdio.h>\r\n    main()\r\n    { \r\n        int  a[4][4]={ {1,4,3,2},{8,6,5,7},{3,7,2,5},{4,8,6,1}}, i, k, t;\r\n        for (i=0; i<3; i++)\r\n            for (k=i+1; k<4; k++)  \r\n                if (a[i][i] < a[k][k]) \r\n                { t=a[i][i]; a[i][i]=a[k][k]; a[k][k]=t;}\r\n        for (i=0; i<4; i++) \r\n            printf(\"%d,\", a[0][i]);\r\n    }\r\n程序运行后的输出结果是（）', '1,1,2,6,', '6,2,1,1,', '6,4,3,2,', '2,3,4,6,', 'C', '3', '5', '2018年3月二级《C语言》考前必做题', null, '首先对二维数组进行赋值操作，a[0][0]、a[0][1]、…、a[3][2]、a[3][3]的值为1、4、…、6、1。通过for嵌套循环语句和if条件语句，对二维数组对角线元素进行由大到小的排序操作，程序最后通过for语句输出二维数组第1行的4个元素。因此C选项正确。');
INSERT INTO `exercises` VALUES ('165', '有以下程序\r\n     #include <stdio.h>\r\n     main()\r\n     {  int  a[3][4]={ 1,3,5,7,9,11,13,15,17,19,21,23}, (*p)[4]=a,i,j,k=0;\r\n        for( i=0; i<3; i++ )\r\n          for( j=0; j<2; j++ )  k=k+*(*(p+i)+j);\r\n        printf(\"%d\\n\", k );\r\n     }\r\n\r\n程序运行后的输出结果是', '108', '68', '99', '60', 'D', '3', '5', '2018年3月二级《C语言》考前必做题', null, '该题首先给二维数组赋值a[3][4]={{1,3,5,7}{9,11,13,15}{17,19,21,23}}；(*p)[4]=a指针p指向二维数组a的首地址，接下来执行for循环，首先 i=0，j=0时k=k+*（*（p+0）+0）=1（a[0][0]）；然后 i=0，j=1时k=k+*（*（p+0）+1）=4（a[0][1]）；然后j=2时，跳出j的循环，执行i的循环i=1，j=0 时k=k+*（*（p+1）+0）=13(a[1][0])；依次类推一直到i=3时跳出全部循环。循环语句在这里的功能是累加二维数组第1列和第2列的元素，累加结果为60。');
INSERT INTO `exercises` VALUES ('166', '有以下程序\r\n#include    <stdio.h>\r\n#include    <string.h>\r\nmain( )\r\n{  char  a[] = \"TEXT\", *b = \"++\", c[3] = \"1\";\r\n   printf(\"%d,%d,\", strlen(a), sizeof(a));\r\n   printf(\"%d,%d,\", strlen(b), sizeof(b));\r\n   printf(\"%d,%d,\\n\", strlen(c), sizeof(c));\r\n}\r\n程序运行后的输出结果是（）。', '4,5,2,4,1,3,', '4,4,2,2,1,1,', '5,5,3,3,2,2,', '4,4,2,2,1,3', 'A', '3', '5', '2018年3月二级《C语言》考前必做题', null, 'sizeof(　)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。strlen(*char)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL，返回的长度大小不包括NULL。sizeof(a)求数组a所占空间的大小，包括字符串最后的＇\\0＇，所以sizeof(a)=5，strlen()遇到＇\\0＇就结束，strlen(a)=4。strlen(b)是指针指向的字符串长度，sizeof(b)是指针的大小。strlen(c)是字符串的长度,sizeof(c)是数组的长度。因此，输出4,5,2,4,1,3。故答案为A选项');
INSERT INTO `exercises` VALUES ('167', '有以下程序\r\n#include   <stdio.h>\r\n#include   <string.h>\r\nmain( )\r\n{ char  a[20]=\"ab\",b[20]=\"cdef\";\r\n  int  k=0;\r\n  strcat(a,b);\r\n  while(a[k]!=\'\\0\') { b[k]=a[k]; k++;}\r\n  puts(b);\r\n}\r\n程序的运行结果是（）。', 'abcdef ', 'cbcdef   ', 'cdef', 'ab', 'A', '3', '5', '2018年3月二级《C语言》考前必做题', null, 'strcat(字符串1， 字符串2)函数是把字符串2连接到字符串1的后面，最终结果存放到字符组1中，因此本题把a,b字符串连接起来放在a数组中，while语句完成功能是再将a字符串赋给b字符串，因此答案为A选项。');
INSERT INTO `exercises` VALUES ('168', '以下叙述中正确的是（）', '函数名允许用数字开头', '函数调用时，不必区分函数名称的大小写', '调用函数时，函数名必须与被调用的函数名完全一致', '在函数体中只能出现一次return语句', 'C', '2', '5', '2018年3月二级《C语言》考前必做题', null, 'B选项中，函数调用时，函数名称是需要区分大小写的；A选项中，函数名不允许以数字开头；D选项中，在函数中允许有多个return语句，但每次调用只能有一个return 语句被执行。因此C选项正确。');
INSERT INTO `exercises` VALUES ('169', '有以下程序\r\n    #include <stdio.h>\r\n    int f(int x);\r\n    main()\r\n    { int n=1,m;\r\n      m=f(f(f(n))); printf(\"%d\\n\",m);\r\n    }\r\n    int f(int x)\r\n    { return x*2; }\r\n程序运行后的输出结果是（）。', '4', '2', '8', '1', 'C', '3', '5', '2018年3月二级《C语言》考前必做题', null, '在C语言中，需要在main函数后面定义函数，需要提前声明，否则调用报错，无法找到该函数。m=f(f(f(n))),一共调用3次f()函数，f()函数是对n*2,因此，结果是n*2*2*2,得到结果为8。故答案为C选项。');
INSERT INTO `exercises` VALUES ('170', '有以下程序\r\n#include <stdio.h>\r\nint  d=1;\r\nvoid  fun( int  p )\r\n{  \r\n    int  d=5;\r\n    d += p++;\r\n    printf(\"%d  \", d );\r\n}\r\nmain()\r\n{  \r\n    int  a=3;\r\n    fun( a );\r\n    d += a++;\r\n    printf(\"%d\\n\",d);\r\n}\r\n程序的输出结果是（）', '8  4', '9  6', '9  4', '8  5', 'A', '3', '5', '2018年3月二级《C语言》考前必做题', null, '本题主要考查局部变量和全局变量的区别，题目中函数之外定义的d为全局变量，函数fun内定义的d为局部变量，所以执行fun函数后，打印出8，执行完d += a++;后d变为4，所以答案为A。');
INSERT INTO `exercises` VALUES ('171', '函数fun的功能是在a所指的具有n个元素的数组中查找最大值并返回给调用函数，函数不完整。\r\nint  fun(int  *a,int  n)\r\n{  int  *p,*s;\r\n   for( p=a,s=a; p-a<n;p++ )\r\n   if(__________)  s=p;\r\n   return  *s;\r\n}\r\n在if语句下划线处应填入的选项是（）。', 'p>s', '*p>*s', 'a[p]>a[s]', 'p-a>p-s', 'B', '2', '5', '2018年3月二级《C语言》考前必做题', null, '函数fun的功能是在a所指的具有n个元素的数组中查找最大值并返回。通过for比较，s始终指向最大值的那个元素。取指针的值，使用*p，因此比较使用*p和*s，又因为找最大值，当*s<*p时，修改指针s的指向，因此答案为B选项');
INSERT INTO `exercises` VALUES ('172', '设有以下函数：\r\n    void fun(int n,char *s)\r\n    {  ……  }\r\n则下面对函数指针的定义和赋值均正确的是（）。', 'void (*pf)(int,char);     pf=&fun;', 'void  *pf();      pf=fun;', 'void  *pf();     *pf=fun;', 'void  (*pf)(int, char*);    pf=fun;', 'D', '3', '5', '2018年3月二级《C语言》考前必做题', null, '函数的参数可以是指针类型。它的作用是将一个变量的地址传送到另一个函数中。函数名代表函数的入口地址，指向函数的指针应该定义为void (*pf)()。如果定义为void *pf()，则表示函数pf返回值为一个基类型为void的指针。因此D选项正确。');
INSERT INTO `exercises` VALUES ('173', '有以下程序\r\n     #include <stdio.h>\r\n     #define  SUB( X, Y )   (X+1)*Y\r\n     main()\r\n     {  int  a=3, b=4;\r\n        printf(\"%d\\n\",SUB(a++ ,b++ )); \r\n     }\r\n程序运行后的输出结果是（）。', '25', '20', '12', '16', 'D', '3', '5', '2018年3月二级《C语言》考前必做题', null, '本题考查宏定义，宏定义只是做个简单的替换，执行SUB(a++ ,b++)=(a++ +1)*b++=16,选项D正确。');
INSERT INTO `exercises` VALUES ('174', '若有定义\r\n    typedef  int  *T;\r\n    T  a[20];\r\n则以下与上述定义中a类型完全相同的是（）。', 'int  *a[20]; ', 'int  (*a)[20];', 'int  a[20]; ', 'int  **a[20];', 'A', '2', '5', '2018年3月二级《C语言》考前必做题', null, '“typedef　类型名　新类型名”表示为一个已有定义的类型标识符重新定义一个类型名，题中选项A代表的意思是数组指针，即指向数组的指针，B选项是指针数组，即数组存放的元素是整型指针，首先为整型指针类型命名为T，再通过T定义了一个整形指针数组*a[20]，等价于int *a[20]，答案为A选项。');
INSERT INTO `exercises` VALUES ('175', '为了建立如图所示的存储结构（即每个结点含两个域，data是数据域，next是指向结点的指针域）则在（）处填入的选项是（   ）。\r\n  struct link{ char data;（）}node;\r\n	\r\n   data next ', 'struct link *next;', 'link next;', 'link *next;', 'struct link next;', 'A', '2', '5', '2018年3月二级《C语言》考前必做题', null, '存储结构用链式存储。链式结构每个节点有个指针域，指针域指向下一个链式结构的节点，因此指针域的结构应该是该结构形式，因此应定义为struct link* next,故答案为A选项。struct是结构体的说明符，不能省略');
INSERT INTO `exercises` VALUES ('176', '有以下程序段\r\n      FILE *fp;\r\n      if( (fp=fopen(\"test.txt\"，\"w\")) == NULL)\r\n        {   printf(\"不能打开文件！\");\r\n            exit(0);}\r\n      else\r\n           printf(\"成功打开文件！\");\r\n  若指定文件test.txt不存在，且无其他异常，则以下叙述错误的是', '输出\"不能打开文件！\"', '输出\"成功打开文件！\"', '系统将按指定文件名新建文件', '系统将为写操作建立文本文件', 'A', '3', '5', '2018年3月二级《C语言》考前必做题', null, 'fopen函数以一定方式打开指定文件，返回一个指向文件的文件指针，如果不能实现打开指定文件的操作，则返回一个空指针NULL。如果指定文件不存在则创建一个文件名为指定文件名的新文件，然后打开它。在指定文件有错误或者指定文件不存在却不能创建新文件的情况下，打开文件操作错误，返回空指针。本题程序中，文件test.txt不存在，但无其他异常，表示可以建立新文件，命名为test.txt，C选项叙述正确，并以只写方式打开它，D选项叙述正确，返回指向文件的指针，if条件不成立，输出“成功打开文件！”，B选项叙述正确，A选项叙述错误。所以选择A选项。');
INSERT INTO `exercises` VALUES ('177', '有以下程序\r\n#include <stdio.h>\r\nmain( )\r\n{  FILE *fp;\r\n   int i, a[6] = {1,2,3,4,5,6}, k;\r\n\r\n   fp = fopen(\"data.dat\", \"w+\");\r\n   fprintf(fp, \"%d\\n\", a[0]);\r\n   for (i=1; i<6; i++)\r\n   {   rewind(fp);\r\n       fprintf(fp, \"%d\\n\", a[i]);\r\n   }\r\n   rewind(fp);\r\n   fscanf(fp, \"%d\", &k);\r\n   fclose(fp); \r\n   printf(\"%d\\n\", k);\r\n}\r\n程序运行后的输出结果是()。', '6', '21', '123456   ', '654321', 'A', '3', '5', '2018年3月二级《C语言》考前必做题', null, '本题首先定义文件指针变量fp和一个数组a[]，再打开一个文件\"data.dat\"，随后先给文件写入数据a[0]，由于rewind函数是将文件指针从当前位置重新指向文件开始位置，所以for循环依次将数组a中的数据写入文件开始位置，退出循环后，文件中的数据顺序为：654321，重新使指针指向文件开始位置，将此时fp指向的数据(即文件中第一个数据6)写入变量k中，关闭文件，输出k值，答案为A选项。');
INSERT INTO `exercises` VALUES ('178', '有以下程序段\r\n      FILE *fp;\r\n      if( (fp=fopen(\"test.txt\"，\"w\")) == NULL)\r\n        {   printf(\"不能打开文件！\");\r\n            exit(0);}\r\n      else\r\n           printf(\"成功打开文件！\");\r\n  若指定文件test.txt不存在，且无其他异常，则以下叙述错误的是', '输出', '输出', '系统将按指定文件名新建文件', '系统将为写操作建立文本文件', 'A', '3', '34', '第一章 C语言程序设计概述1', null, 'fopen函数以一定方式打开指定文件，返回一个指向文件的文件指针，如果不能实现打开指定文件的操作，则返回一个空指针NULL。如果指定文件不存在则创建一个文件名为指定文件名的新文件，然后打开它。在指定文件有错误或者指定文件不存在却不能创建新文件的情况下，打开文件操作错误，返回空指针。本题程序中，文件test.txt不存在，但无其他异常，表示可以建立新文件，命名为test.txt，C选项叙述正确，并以只写方式打开它，D选项叙述正确，返回指向文件的指针，if条件不成立，输出“成功打开文件！”，B选项叙述正确，A选项叙述错误。所以选择A选项。');
INSERT INTO `exercises` VALUES ('179', '有以下程序\r\n#include <stdio.h>\r\nmain( )\r\n{  FILE *fp;\r\n   int i, a[6] = {1,2,3,4,5,6}, k;\r\n\r\n   fp = fopen(\"data.dat\", \"w+\");\r\n   fprintf(fp, \"%d\r\n\", a[0]);\r\n   for (i=1; i<6; i++)\r\n   {   rewind(fp);\r\n       fprintf(fp, \"%d\r\n\", a[i]);\r\n   }\r\n   rewind(fp);\r\n   fscanf(fp, \"%d\", &k);\r\n   fclose(fp); \r\n   printf(\"%d\r\n\", k);\r\n}\r\n程序运行后的输出结果是()。', '6', '21', '123456   ', '654321', 'A', '3', '34', '第一章 C语言程序设计概述1', null, '本题首先定义文件指针变量fp和一个数组a[]，再打开一个文件\"data.dat\"，随后先给文件写入数据a[0]，由于rewind函数是将文件指针从当前位置重新指向文件开始位置，所以for循环依次将数组a中的数据写入文件开始位置，退出循环后，文件中的数据顺序为：654321，重新使指针指向文件开始位置，将此时fp指向的数据(即文件中第一个数据6)写入变量k中，关闭文件，输出k值，答案为A选项。');
INSERT INTO `exercises` VALUES ('180', '下列叙述中正确的是', '所谓算法就是计算方法', '程序可以作为算法的一种描述方法', '算法设计只需考虑得到计算结果 ', '算法设计可以忽略算法的运算时间', 'B', null, '25', '2018年3月二级《C语言》高频考点卷', null, '算法是指对解题方案的准确而完整的描述，算法不等于数学上的计算方法，也不等于程序,A选项错误。算法设计需要考虑可行性、确定性、有穷性与足够的情报，不能只考虑计算结果，C选项错误。算法设计有穷性是指操作步骤有限且能在有限时间内完成，如果一个算法执行耗费的时间太长，即使最终得出了正确结果，也是没有意义的，D选项错误。算法在实现时需要用具体的程序设计语言描述，所以程序可以作为算法的一种描述方法，B选项正确。');
INSERT INTO `exercises` VALUES ('181', '下列叙述中正确的是', '一个算法的空间复杂度大，则其时间复杂度也必定大', '一个算法的空间复杂度大，则其时间复杂度必定小   ', '一个算法的时间复杂度大，则其空间复杂度必定小', '算法的时间复杂度与空间复杂度没有直接关系', 'D', null, '25', '2018年3月二级《C语言》高频考点卷', null, '算法的空间复杂度是指算法在执行过程中所需要的内存空间，算法的时间复杂度，是指执行算法所需要的计算工作量，两者之间并没有直接关系，答案为D。');
INSERT INTO `exercises` VALUES ('182', '下列叙述中错误的是', '数据结构中的数据元素不能是另一数据结构', '数据结构中的数据元素可以是另一数据结构', '空数据结构可以是线性结构也可以是非线性结构', '非空数据结构可以没有根结点', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '数据元素是一个含义很广泛的概念，它是数据的“基本单位”，在计算机中通常作为一个整体进行考虑和处理。数据元素可以是一个数据也可以是被抽象出的具有一定结构数据集合，所以数据结构中的数据元素可以是另一数据结构。\r\n满足有且只有一个根结点并且每一个结点最多有一个前件，也最多有一个后件的非空的数据结构认为是线性结构，不满足条件的结构为非线性结构。\r\n空数据结构可以是线性结构也可以是非线性结构。非空数据结构可以没有根结点，如非性线结构“图”就没有根结点。故选A选项');
INSERT INTO `exercises` VALUES ('183', '结构化程序设计的基本原则不包括(　　)。', '多态性', '自顶向下', '模块化', '逐步求精', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '结构化程序设计的思想包括：自顶向下、逐步求精、模块化、限制使用goto语句，所以选择A)。');
INSERT INTO `exercises` VALUES ('184', '结构化程序设计中，下面对goto语句使用描述正确的是', '禁止使用goto语句', '使用goto语句程序效率高', '应避免滥用goto语句', '以上说法均错误', 'C', null, '25', '2018年3月二级《C语言》高频考点卷', null, '结构化程序设计中，要注意尽量避免goto语句的使用，故选C。');
INSERT INTO `exercises` VALUES ('185', '下列叙述中正确的是', '软件是程序、数据和文档', '软件是程序和数据', '软件是算法和数据结构', '软件是算法和程序', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '计算机软件由两部分组成：一是机器可执行的程序和数据；二是机器不可执行的，与软件开发、运行、维护、使用等有关的文档。故选A选项');
INSERT INTO `exercises` VALUES ('186', '软件生命周期是指(　　)。', '软件产品从提出、实现、使用维护到停止使用退役的过程', '软件从需求分析、设计、实现到测试完成的过程', '软件的开发过程', '软件的运行维护过程', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '通常，将软件产品从提出、实现、使用维护到停止使用退役的过程称为软件生命周期。也就是说，软件产品从考虑其概念开始，到该软件产品不能使用为止的整个时期都属于软件生命周期');
INSERT INTO `exercises` VALUES ('187', '下面能作为软件需求分析工具的是', 'PAD图   ', '程序流程图 ', '甘特图 ', '数据流程图(DFD图)', 'D', null, '25', '2018年3月二级《C语言》高频考点卷', null, '软件需求分析方法包括结构化分析方法和面向对象的分析方法两大类，前者常用工具为数据流图（DFD）、数据字典（DD）、判定表、判定树等。故D选项正确。');
INSERT INTO `exercises` VALUES ('188', '在数据库管理系统提供的数据语言中，负责数据的查询、增加、删除和修改等操作的是', '数据定义语言', '数据管理语言', '数据操纵语言', '数据控制语言', 'C', null, '25', '2018年3月二级《C语言》高频考点卷', null, '数据库管理系统提供了相应的数据语言，它们是：数据定义语言，该语言负责数据的模式定义与数据的物理存取构建；数据操纵语言，该语言负责数据的操纵，包括查询与增、删、改等操作；数据控制语言，该语言负责数据完整性、安全性的定义与检查以及并发控制、故障恢复等功能。C选项正确。');
INSERT INTO `exercises` VALUES ('189', '在数据库系统中，考虑数据库实现的数据模型是', '概念数据模型', '逻辑数据模型', '物理数据模型', '关系数据模型', 'B', null, '25', '2018年3月二级《C语言》高频考点卷', null, '数据模型按照不同的应用层次分为以下３种类型：概念数据模型，它是一种面向客观世界、面向用户的模型，它与具体的数据库管理系统和具体的计算机平台无关；逻辑数据模型，是面向数据库系统的模型，着重于在数据库系统一级的实现；物理数据模型，是面向计算机物理实现的模型，此模型给出了数据模型在计算机上物理结构的表示。B选项正确。');
INSERT INTO `exercises` VALUES ('190', '以下叙述中错误的是(　　)。', '使用三种基本结构构成的程序只能解决简单问题', '结构化程序由顺序、分支、循环三种基本结构组成', 'C语言是一种结构化程序设计语言', '结构化程序设计提倡模块化的设计方法', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '使用顺序，选择(分支)，循环三种基本结构构成的程序可以解决所有问题，而不只是解决简单问题，所以A)错误。');
INSERT INTO `exercises` VALUES ('191', '以下选项中叙述正确的是', '函数体必须由 { 开始', 'C程序必须由main语句开始', 'C程序中的注释可以嵌套', 'C程序中的注释必须在一行完成', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '函数体是函数首部下面的花括号内的部分，所以函数体必须由{开始，A选项正确。一个源程序文件可以包括预处理命令、全局声明、函数定义，程序总是从main函数开始执行的，不是main语句，B选项错误。C程序中的允许两种注释，以//开头的单行注释；以/*开始，以*/结束的块式注释，D选项错误。函数可以嵌套，注释不能嵌套，C选项错误。');
INSERT INTO `exercises` VALUES ('192', '以下叙述正确的是', 'C编译程序把文件后缀为.c的源程序文件编译成文件后缀为.obj的二进制文件', 'C编译程序把文件后缀为.c的源程序文件编译成文件后缀为.exe的可执行文件', 'C编译程序把文件后缀为.obj的二进制文件编译成文件后缀为.exe的可执行文件', '链接程序把文件后缀为.c的源程序文件链接成文件后缀为.exe的可执行文件', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, 'C编译程序把文件后缀为.c的源程序文件编译成文件后缀为.obj的二进制文件，链接将一个或多个目标文件与程序用到的库文件连接起来,形成一个可以在操作系统直接运行的执行程序.exe，故排除B,C,D选项，答案选A选项。');
INSERT INTO `exercises` VALUES ('193', '按照C语言规定的用户标识符命名规则，不能出现在标识符中的是(　　)。', '大写字母', '下划线', '数字字符', '连接符', 'D', null, '25', '2018年3月二级《C语言》高频考点卷', null, 'C语言中标识符由字母、下划线、数字组成，且开头必须是字母或下划线。所以D)选项中的连接符不合法。');
INSERT INTO `exercises` VALUES ('194', '下列定义变量的语句中错误的是', 'int  _int;', 'double  int_;', 'char  For;', 'float  US$;', 'D', null, '25', '2018年3月二级《C语言》高频考点卷', null, 'C语言规定,变量命名必须符合标识符的命名规则｡D选项中包含了非法字符\"$\",所以错误｡标识符由字母､数字或下划线组成,且第一个字符必须是大小写英文字母或者下划线,而不能是数字｡大写字符与小写字符被认为是两个不同的字符,所以For不是关键字for｡');
INSERT INTO `exercises` VALUES ('195', 'C语言中的标识符分为关键字、预定义标识符和用户标识符，以下叙述正确的是', '关键字可用作用户标识符，但失去原有含义', '预定义标识符可用作用户标识符，但失去原有含义', '在标识符中大写字母和小写字母被认为是相同的字符', '用户标识符可以由字母和数字任意顺序组成', 'B', null, '25', '2018年3月二级《C语言》高频考点卷', null, '关键字不可用作C语言的标识符,所以A错误｡在标识符中大写字母与小写字母作为不同字符处理,所以C错误｡标识符由下划线､字母､数字组成,且必须以下划线和字母开始,所以D错误｡');
INSERT INTO `exercises` VALUES ('196', '以下选项中合法的常量是', '9  9  9', '2.7e', '0Xab', '123E 0.2', 'C', null, '25', '2018年3月二级《C语言》高频考点卷', null, 'A选项中含有非法的空格,所以错误｡C语言中十六进制常量以0x开头,所以C正确｡实型常量中e的前后必须均有数据,且其后必须为整数,所以B和D错误｡');
INSERT INTO `exercises` VALUES ('197', '有以下程序\r\n#include <stdio.h>\r\nmain()\r\n{  int  k=33; \r\n   printf(\"%d,%o,%x\\n\", k, k, k);\r\n}程序的运行结果是', '33,41,21', '33,33,33', '41,33,21', '33,21,41', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '整型常量有３种表示方法，分别是十进制数表示法、八进制数表示法和十六进制数表示法。十进制整型常量没有前缀，输出格式控制符为%d；八进制整型常量以０作为前缀，输出格式控制符为%o；十六进制整型常量以0X或0x作为前缀，输出格式控制符为%x。整型33用八进制表示为41，十六进制表示为21，A选项正确。');
INSERT INTO `exercises` VALUES ('198', '以下选项中，合法的一组C语言数值常量是(　　)。', '12.　0Xa23　4.5e0', '028　.5e-3　-0xf', '.177　4e1.5　0abc', '0x8A　10,000　3.e5', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, 'C语言中八进制整型常量的开头是数字0，十六进制整型常量的开头数字是0x。C语言中的实型常量有两种表示形式：小数形式，小数形式表示的实型常量必须要有小数点；指数形式，以\"e\"或\"E\"后跟一个整数来表示以10为底数的幂数，且规定字母e或E之前必须要有数字，且e或E后面的指数必须为整数。B)选项中 028错误，八进制中没有数字8。C)选项中4e1.5中e后面的指数不是整数。D)选项中数字“10，000”不能用逗号。');
INSERT INTO `exercises` VALUES ('199', '已知大写字母A的ASCII码是65，小写字母a的ASCII码是97。以下不能将变量c中的大写字母转换为对应小写字母的语句是（）。', 'c=(\'A\'+c)%26-\'a\'', 'c=c+32', 'c=c-\'A\'+\'a\'', 'c=(c-\'A\')%26 +\'a\'', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '根据题意可知,小写字母比与之对应的大写字母的ASCII码大32｡A选项中字符A加上c表示的大写字符再对字母个数26取余,本身这个表达式没有任何含义所以选择A选项｡');
INSERT INTO `exercises` VALUES ('200', '若有定义：double  a, b, c; 能正确给a,b,c输入数据的语句是（）。', 'scanf(\" %lf %lf %lf\" &a, &b, &c )', 'scanf(\" %f %f %f\",&a, &b, &c );', 'scanf(\" %lf %lf %lf\",a, b, c );', 'scanf(\" %lf %lf %lf\",&a, &b, &c );', 'D', null, '25', '2018年3月二级《C语言》高频考点卷', null, '%lf,%le是针对double的，如果仅用%f，输入的数据可能不完全接收，数据的精度可能不足。%f主要针对float类型的变量的输入,因此选项B错误。根据题目格式可知A,C错误。故答案为D选项。');
INSERT INTO `exercises` VALUES ('201', '若有以下程序段\r\n    double x=5.16894;\r\n    printf(\"%f\\n\",  (int)(x*1000+0.5)/(double)1000  );\r\n则程序段的输出结果是', '5.170000', '5.175000', '5.169000', '5.168000', 'C', null, '25', '2018年3月二级《C语言》高频考点卷', null, '%f的输出格式是以带小数点的数学形式输出浮点数。首先计算x*1000，结果为5168.94然后+0.5,结果为5169.44,然后进行强制类型转换,转换成整型为5169,然后除以双精度数据1000,结果也为双精度数据5.169,输出时按照%f的格式输出，所以输出结果为5.169000｡');
INSERT INTO `exercises` VALUES ('202', '若变量已正确定义，在if (W) printf(\"%d\\n\" ，k )； 中，以下不可替代W的是(　　)。', 'a<>b+c', 'ch=getchar()', 'a==b+c', 'a++', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '选项A)是非法的表达式，C语言中没有<>运算符。');
INSERT INTO `exercises` VALUES ('203', '#include   <stdio.h>\r\nmain()\r\n{　int  x， y， z；\r\n　 x＝y＝1；\r\n　 z＝x++，y++，++y；\r\n　 printf(\"%d,%d,%d\\n\",x,y,z)；\r\n}\r\n程序运行后的输出结果是(　　)。', '2,3,3', '2,3,2', '2,3,1', '2,2,1', 'C', null, '25', '2018年3月二级《C语言》高频考点卷', null, 'z＝x++，y++，++y；因为赋值运算符的优先级高于逗号运算符的优先级，所以可以将上式表示成(z＝x++)，(y++)，(++y)。然后从左向右先计算表达式z＝x++，因为x++先使用后自增，所以z的值为1，x的值为2。再计算逗号表达式第二个表达式y++，此时y的值为2，最后计算第三个表达式++y，y的值为3。');
INSERT INTO `exercises` VALUES ('204', '有如下程序\r\n#include <stdio.h>\r\nmain() \r\n{\r\n    int a = 0, b = 1;\r\n    if (a++ && b++) \r\n        printf(\"T\");\r\n    else\r\n        printf(\"F\");\r\n    printf(\"a=%d,b=%d\\n\", a, b);\r\n}\r\n程序运行后的输出结果是', 'Ta=1,b=2', 'Fa=0,b=2', 'Fa=1,b=1', 'Ta=0,b=1', 'C', null, '25', '2018年3月二级《C语言》高频考点卷', null, '题目中判断if条件是否成立，a++先取值为0，则(a++ && b++)为0，且不计算b++，而后a自增得a=1，if条件不成立执行else函数体，输出F。最后执行语句printf(\"a=%d,b=%d\\n\", a, b);按照格式输出a=1,b=1。C选项正确。');
INSERT INTO `exercises` VALUES ('205', '有以下程序\r\n    #include <stdio.h>\r\n    main()\r\n    {  char *s=\"120119110\";\r\n       int n0,n1,n2,nn,i;\r\n       n0=n1=n2=nn=i=0;\r\n       do{\r\n            switch(s[i++])\r\n            {  default   : nn++;\r\n               case  \'0\' : n0++;\r\n               case  \'1\' : n1++;\r\n               case  \'2\' : n2++;\r\n             }\r\n           } while(s[i]);\r\n      printf(\"n0=%d,n1=%d,n2=%d,nn=%d\\n\",n0,n1,n2,nn);\r\n    }\r\n   程序的运行结果是（）。', 'n0=3,n1=8,n2=9,nn=1', 'n0=2,n1=5,n2=1,nn=1', 'n0=2,n1=7,n2=10,nn=1', 'n0=4,n1=8,n2=9,nn=1', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '本题执行过程为，s[0]=\'1\'，匹配case\'1\'，n1=1，n2=1；s[1]=\'2\'，匹配case\'2\'， n2=2；s[2]=\'0\'，匹配case\'0\'，n0=1，n1=2，n2=3；s[3]=\'1\'，匹配case\'1\'，n1=3，n2=4；s[4]=\'1\'，匹配case\'1\'，n1=4，n2=5；s[5]=\'9\'，匹配default，nn=1，n0=2，n1=5，n2=6；s[6]=\'1\'，匹配case\'1\'，n1=6，n2=7；s[7]=\'1\'，匹配case\'1\'，n1=7，n2=8；s[8]=\'0\'，匹配case\'0\'，n0=3，n1=8，n2=9；s[9]=\'\\0\'，退出循环。输出n0,n1,n2,nn为3,8,9,1，A选项正确。');
INSERT INTO `exercises` VALUES ('206', '有以下程序\r\n#include <stdio.h>\r\nmain( )\r\n{  int i,j = 0; \r\n   char a[] = \"How are you\", b[10] = {0};\r\n   for (i=0; a[i]; i++)\r\n     if (a[i] == \' \')\r\n        b[j++] = a[i+1];\r\n   printf(\"%s\\n\",b);\r\n}\r\n程序运行后的输出结果是（）。', 'Hay', 'Howareyou  ', 'we ', 'ay', 'D', null, '25', '2018年3月二级《C语言》高频考点卷', null, 'for语句循环体执行功能是，每次当a[i]元素为\' \'时，自动将a[i]下一个元素赋值给b[j]，赋值完成后，j值加1，因此a[i]的\'a\'和\'y\'分别赋值给b[0],b[1]，答案为D选项。');
INSERT INTO `exercises` VALUES ('207', '有以下程序\r\n#include  <stdio.h>\r\nmain()\r\n{  char  a=3, b=6, c;\r\n   c=(a^b)<<2;\r\n   printf(\"%d \\n\", c );\r\n}\r\n程序运行后的输出结果是（）。', '5', '1', '20', '18', 'C', null, '25', '2018年3月二级《C语言》高频考点卷', null, '^运算符为按位异或运算符，即0^1=1,1^0=1,1^1=0,0^0=0,因此a^b=101在进行<<操作，变为101002=2010，因此答案为C选项。');
INSERT INTO `exercises` VALUES ('208', '有如下程序\r\n#include <stdio.h>\r\nmain() \r\n{\r\n    int i, *ptr;\r\n    int array[5] = {5,3,1};\r\n    for (ptr=array, i=0; i<5; i++, ptr++)\r\n    {\r\n        if (*ptr == 0)\r\n            putchar(\'X\');\r\n        else\r\n            putchar(\'A\' + *ptr);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n程序运行后的输出结果是', 'FDBXX', 'FFFXX ', 'FDBBB', 'ABCDE', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '在对数组进行初始化时，如果对数组的全部元素赋以初值，定义时可以不指定数组长度，如果被定义数组的长度与初值个数不同，则数组长度不能省略；如果在说明数组时给出了长度，但没有给所有的元素赋予初始值，而只依次给前面的几个数组元素赋予初值，那么Ｃ语言将自动对余下的元素赋初值，则array={5,3,1,0,0}。程序执行过程为：执行for循环，将数组首地址赋给指针ptr，依次遍历每一个元素，如果数组元素为0则输出‘X’，如果不为0则按照字母表输出字符‘A’后第array[i]个字符。程序运行后的输出结果为：FDBXX，A选项正确。A');
INSERT INTO `exercises` VALUES ('209', '有以下程序\r\n#include <stdio.h>\r\nmain()\r\n{  \r\n    char  *s=\"12134\";\r\n    int  k=0, a=0 ;\r\n    while( s[ k +1 ] )\r\n    {  \r\n        k++;\r\n        if ( k % 2 ==0 ) \r\n        {\r\n             a = a + ( s[ k ] - \'0\' +1 ) ; \r\n             continue; \r\n        }\r\n        a = a + ( s[ k ] - \'0\' );\r\n    }\r\n    printf (\" k=%d a=%d\\n\", k, a );\r\n}\r\n程序运行后的输出结果是（）。', 'k=5 a=15', 'k=4 a=12', 'k=6 a=11', 'k=3 a=14', 'B', null, '25', '2018年3月二级《C语言》高频考点卷', null, '当k=0时，执行while一次，得到k=1，a为2；当k=1时，执行while一次，得到k=2，a为4；当k=2时，执行while一次，得到k=3，a为7；当k=3时，执行while一次，得到k=4，a为12；所以答案为B选项。');
INSERT INTO `exercises` VALUES ('210', '有以下程序\r\n    #include <stdio.h>\r\n    main()\r\n    {  int  a, b;     \r\n       for( a=1,b=1; a<=100; a++ )\r\n       {  if(b>=20) break;\r\n          if(b % 3==1) {  b=b+3; continue; }\r\n          b=b-5;\r\n       }\r\n       printf(\"%d\\n\",a);\r\n    }\r\n程序的输出结果是（）。', '10', '9', '8', '7', 'C', null, '25', '2018年3月二级《C语言》高频考点卷', null, '首先注意for循环的控制条件当b>=20或者a>100则跳出for循环也即b<20且a<=100时执行for循环；第一次进入循环a=1,b=1均满足循环条件，但b%3==1条件满足，故执行b=b+3，得到b=4,注意有continue，所以后面语句不执行，直接跳转到a++这个语句，所以第一次循环完之后a=2,b=4；进入第二轮循环，b%3==1也是满足的，故再次b=b+3，此轮循环执行之后a=3,b=7,进入下一轮。此后和前面循环同理，都是b%3==1满足，因为每次都是加3，而之后又去模3，且都跳过for后面语句直接执行a++，所以，一直循环到b=22跳出for循环。此时a为8. 综合起来就是，每次循环b增加3，a增加1，且当b>22时跳出循环，结束程序。所以b从1增加到22，有（22-1）/3=7,所以a=1+7=8. 因此C选项正确。');
INSERT INTO `exercises` VALUES ('211', '设有一个M*N的矩阵已经存放在一个M行N列的数组x中，且有以下程序段\r\n       sum=0;\r\n       for(i=0;i<M;i++)  sum+=x[i][0]+x[i][N-1];\r\n       for(j=1;j<N-1;j++) sum+=x[0][j]+x[M-1][j];\r\n以上程序段计算的是', '矩阵两条对角线元素之和', '矩阵所有不靠边元素之和', '矩阵所有元素之和 ', '矩阵所有靠边元素之和', 'D', null, '25', '2018年3月二级《C语言》高频考点卷', null, '程序执行过程为：第一个for循环实现对第一列和第N列求和。第二个for循环在上一个for循环结果上实现对第一行和第M行从第二个元素到第N-1个元素的求和，总体来说，就是矩阵所有靠边元素之和，D选项正确。');
INSERT INTO `exercises` VALUES ('212', '若有以下程序\r\n     #include <stdio.h>\r\n     void fun(int  a[ ], int  n)\r\n     {  int  t, i, j;\r\n        for ( i=0;  i<n;  i+=2 )\r\n           for ( j=i+2;  j<n;  j+=2 )\r\n             if ( a[i] > a[j] ) {  t=a[i];  a[i]=a[j];  a[j]=t; }\r\n     }\r\n     main()\r\n     {  int  c[10]={10,9,8,7,6,5,4,3,2,1},i;\r\n        fun(c, 10);\r\n        for ( i=0; i<10;  i++ )  printf(\"%d,\", c[i]);\r\n        printf(\"\\n\");\r\n     }\r\n则程序的输出结果是（）。', '1,10,3,8,5,6,7,4,9,2,', '10,9,8,7,6,5,4,3,2,1,', '10,1,8,3,6,5,4,7,2,9,', '2,9,4,7,6,5,8,3,10,1,', 'D', null, '25', '2018年3月二级《C语言》高频考点卷', null, '该题首先对一维数组进行初始化,c[0]到c[9]依次赋值为10到1;fun(c, 10);语句调用fun函数,fun函数的功能是将一维数组奇数位元素的数值由小到大排序;最后将排好序的新的一维数组进行输出｡因此D选项正确｡');
INSERT INTO `exercises` VALUES ('213', '若有以下程序\r\n     #include <stdio.h>\r\n     #define  N  4\r\n     void fun( int  a[][N], int  b[], int  flag )\r\n     {  int  i,j;\r\n        for( i=0; i<N; i++ ) \r\n        {  b[i] = a[0][i];\r\n           for( j=1; j<N; j++ )\r\n              if (flag ? (b[i] > a[j][i]) : (b[i] < a[j][i]))       b[i] = a[j][i];\r\n        }\r\n     }\r\n     main()\r\n     {  int  x[N][N]={1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16}, y[N],i;\r\n        fun(x, y, 1);\r\n        for (i=0;i<N; i++)   printf(\"%d,\", y[i]);\r\n        fun(x, y, 0);\r\n        for (i=0;i<N; i++)   printf(\"%d,\", y[i]);\r\n        printf(\"\\n\"); \r\n     }\r\n则程序的输出结果是', '4,8,12,16,1,5,9,13,', '1,2,3,4,13,14,15,16,', '1,5,9,13,4,8,12,16,', '13,14,15,16,1,2,3,4,', 'B', null, '25', '2018年3月二级《C语言》高频考点卷', null, '该题首先初始化二维数组，if (flag ? (b[i] > a[i][j]) : (b[i] < a[i][j]))条件语句的条件表达式使用了条件运算符构成的选择结构，即flag为真时，以(b[i] > a[i][j])作为条件表达式的值，否则以(b[i] < a[i][j])作为条件表达式的值，fun函数功能是给一维数组赋值。fun(x, y, 1);该函数调用后，即当flag为真时，使一维数组获得二维数组第1行的数值；fun(x, y, 0);该函数调用后，即当flag为假时，使一维数组获得二维数组第4行的数值；因此B选项正确。');
INSERT INTO `exercises` VALUES ('214', '有以下程序\r\n#include <stdio.h>\r\nvoid fun1(char *p)\r\n{ \r\n    char  *q;\r\n    q=p;\r\n    while(*q!=\'\\0\')\r\n    {  \r\n        (*q)++;  \r\n        q++;  \r\n    }\r\n}\r\nmain()\r\n{ \r\n    char  a[]={\"Program\"}, *p;\r\n    p=&a[3];  \r\n    fun1(p);  \r\n    printf(\"%s\\n\",a);\r\n\r\n}\r\n程序执行后的输出结果是（）。', 'Prphsbn', 'Prohsbn', 'Progsbn', 'Program', 'B', null, '25', '2018年3月二级《C语言》高频考点卷', null, '(*q)++是q所指的字符加1，q++就是指针移到下一个字符。因此B选项正确。');
INSERT INTO `exercises` VALUES ('215', '有以下程序\r\n#include  <stdio.h>\r\n#include  <string.h>\r\nvoid  fun( char *s, int m1, int m2 )\r\n{  char  t, *p;\r\n   p=s + m1;  s= s+m2;\r\n   while( s<p )\r\n   {  t=*s;  *s=*p;  *p=t; \r\n      s++;   p--;\r\n   }\r\n}\r\nmain()\r\n{   char  ss[10]=\"012345678\";\r\n    int  n=6;\r\n    fun( ss,0,n-1 );\r\n    fun( ss,9,n );\r\n    fun( ss,0,9 );\r\n    printf(\"%s\\n\", ss );\r\n}\r\n程序运行后的输出结果是（）。', '012345', '876543210', '876543', '012345678', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, 'fun(*ss, m1, m2 )的作用是，如果m1>m2交换数组元素ss[m1]，ss[m2]。因此，fun(ss,0,5)后ss的0,1,2,3,4,5,6,7,8,\\0。fun(ss,9,6) 后ss的0,1,2,3,4,5, \\0,8,7,6。fun(ss,0,9)后ss的0,1,2,3,4,5,\\0,8,7,6。因此打印结果012345。故答案为A选项');
INSERT INTO `exercises` VALUES ('216', '有以下程序\r\n#include   <stdio.h>\r\ntypedef  struct  stu {\r\n                       char  name[10];\r\n                       char  gender;\r\n                       int  score; \r\n                     } STU;\r\nvoid  f( STU  a, STU  *b, STU  c )\r\n{  *b = c =a;\r\n   printf( \"%s,%c,%d,\", b->name, b->gender, b->score );\r\n   printf( \"%s,%c,%d,\", c.name, c.gender, c.score );\r\n}\r\nmain( )\r\n{  STU  a={\"Zhao\", \'m\', 290}, b={\"Qian\", \'f\', 350}, c={\"Sun\", \'m\', 370};\r\n   f( a, &b, c );\r\n   printf( \"%s,%c,%d,\", b.name, b.gender, b.score );\r\n   printf( \"%s,%c,%d\\n\", c.name, c.gender, c.score );\r\n}\r\n程序运行后的输出结果是（）。', 'Zhao,m,290,Zhao,m,290,Zhao,m,290,Sun,m,370', 'Zhao,m,290,Zhao,m,290,Zhao,m,290,Zhao,m,290', 'Zhao,m,290,Zhao,m,290,Qian,f,350,Sun,m,370', 'Zhao,m,290,Zhao,m,290,Qian,f,350,Zhao,m,290', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, 'C语言函数参数传递分为：1、值传递过程中，被调函数的形参作为被调函数的局部变量处理，即在内存的堆栈中开辟空间以存放由主调函数放进来的实参的值，从而成为了实参的一个拷贝。值传递的特点是被调函数对形参的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。\r\n2、地址传递过程中，被调函数的形参虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。题设中，参数b是地址传递，因此会直接影响实参变量。a,c是值传递，传递是a,c的拷贝，不会a,c实参产生影响，因此，调用函数返回，c没有被修改，b被修改了。故答案为A选项。');
INSERT INTO `exercises` VALUES ('217', '有以下程序：\r\n#include   <stdio.h>\r\n#include   <stdlib.h>\r\nint  fun(int   n)\r\n{　 int  *p；\r\n　　p ＝ (int*)malloc(sizeof(int))；\r\n　　*p＝n；    return  *p；\r\n}\r\nmain()\r\n{　 int   a；\r\n　　a ＝ fun(10)；    printf(\"%d\\n\"，a＋fun(10))；\r\n}\r\n程序的运行结果是(　　)。', '0', '10', '20', '出错', 'C', null, '25', '2018年3月二级《C语言》高频考点卷', null, 'malloc(sizeof(int))的作用是开辟一个长度为sizeof(int)存储空间，并通过强制类型转换(int*)将此存储空间的地址赋给了一个整型的指针变量p。然后执行语句*p＝n，使得*p的值为10，并通过return返回此值，即a的值为10。然后在主函数中输出a＋fun(10)＝10＋10＝20。');
INSERT INTO `exercises` VALUES ('218', '有以下程序\r\n#include <stdio.h>\r\n#define f(x) x*x*x\r\nmain()\r\n{  \r\n    int a=3,s,t ;\r\n    s=f(a+1); \r\n    t=f((a+1));\r\n    printf(\"%d,%d\\n\",s,t);\r\n}程序运行后的输出结果是（）。', '10,64', '10,10', '64,10', '64,64', 'A', null, '25', '2018年3月二级《C语言》高频考点卷', null, '本题考查宏定义的用法，宏定义只是做个简单的替换，所以本题中执行f(a+1)=a+1*a+1*a+1=3*a+1=10,f((a+1))=(a+1)*(a+1)*(a+1)=64,所以答案为A选项。');
INSERT INTO `exercises` VALUES ('219', '有以下程序\r\n#include   <stdio.h>\r\nmain( ) \r\n{\r\n    int  i;\r\n    FILE*  fp;\r\n    for (i=0; i<3; i++)\r\n    {\r\n        fp = fopen(\"res.txt\", \"w\");\r\n        fputc(\'K\' + i, fp);\r\n        fclose(fp);\r\n    }\r\n}\r\n程序运行后，在当前目录下会生成一个res.txt文件，其内容是（）。', 'EOF', 'M', 'KLM', 'L', 'B', null, '25', '2018年3月二级《C语言》高频考点卷', null, 'for循环中，每次都执行打开文件res.txt、写入文件、再关闭文件的操作，由于fopen函数使用\'w\'模式写文件，所以每次打开res.txt后，都删除文件中的原有数据，再重新写入新数据。所以文件最终的内容只与最后一次for循环有关，最后一次for循环是向文件res.txt写入\'K\'+2， 即M，正确答案是B选项。');
INSERT INTO `exercises` VALUES ('314', '算法空间复杂度的度量方法是\n', '算法程序的长度', '算法所处理的数据量', '执行算法所需要的工作单元', '执行算法所需要的存储空间', 'D', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '算法的空间复杂度是指执行这个算法所需要的内存空间。算法执行期间所需的存储空间包括3个部分：输入数据所占的存储空间；程序本身所占的存储空间；算法执行过程中所需要的额外空间。D选项正确。\n');
INSERT INTO `exercises` VALUES ('315', '下列叙述中正确的是\n', '循环队列属于队列的链式存储结构', '双向链表是二叉树的链式存储结构', '非线性结构只能采用链式存储结构', '有的非线性结构也可以采用顺序存储结构', 'D', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '循环队列是队列的一种顺序存储结构，A选项错误。双向链表为顺序存储结构，二叉树通常采用链式存储结构，B选项错误。完全二叉树是属于非线性结构，但其最佳存储方式是顺序存储方式，C选项错误，D选项正确。\n');
INSERT INTO `exercises` VALUES ('316', '下列叙述中正确的是(　　)。\n', '顺序存储结构的存储一定是连续的，链式存储结构的存储空间不一定是连续的', '顺序存储结构只针对线性结构，链式存储结构只针对非线性结构', '顺序存储结构能存储有序表，链式存储结构不能存储有序表', '链式存储结构比顺序存储结构节省存储空间', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '链式存储结构既可以针对线性结构也可以针对非线性结构，所以B)与C)错误。链式存储结构中每个结点都由数据域与指针域两部分组成，增加了存储空间，所以D)错误。\n');
INSERT INTO `exercises` VALUES ('317', '下列关于栈的叙述中，正确的是\n', '栈底元素一定是最后入栈的元素', '栈顶元素一定是最先入栈的元素', '栈操作遵循先进后出的原则', '以上说法均错误', 'C', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '栈顶元素总是后被插入的元素，从而也是最先被删除的元素；栈底元素总是最先被插入的元素，从而也是最后才能被删除的元素。栈的修改是按后进先出的原则进行的。因此，栈称为先进后出表，或\"后进先出\"表，所以选择C。\n');
INSERT INTO `exercises` VALUES ('318', '在软件设计中不使用的工具是(　　)。\n', '系统结构图', 'PAD图', '数据流图(DFD图)', '程序流程图', 'C', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '系统结构图是对软件系统结构的总体设计的图形显示。在需求分析阶段，已经从系统开发的角度出发，把系统按功能逐次分割成层次结构，是在概要设计阶段用到的。PAD图是在详细设计阶段用到的。程序流程图是对程序流程的图形表示，在详细设计过程中用到。数据流图是结构化分析方法中使用的工具，它以图形的方式描绘数据在系统中流动和处理的过程，由于它只反映系统必须完成的逻辑功能，所以它是一种功能模型，是在可行性研究阶段用到的而非软件设计时用到，所以选择C)。\n');
INSERT INTO `exercises` VALUES ('319', '下面对类-对象主要特征描述正确的是（）。\n', '对象唯一性', '对象无关性', '类的单一性', '类的依赖性', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '对象的基本特点是：标识唯一性、分类性、多态性、封装性、模块独立性好。类是具有共同属性、共同方法的对象的集合，是关于对象的抽象描述，反映属于该对象类型的所有对象的性质。对象具有的性质，类也具有。故A选项正确。\n');
INSERT INTO `exercises` VALUES ('320', '在软件开发中，需求分析阶段产生的主要文档是(　　)。\n', '可行性分析报告', '软件需求规格说明书', '概要设计说明书', '集成测试计划', 'B', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'A)错误，可行性分析阶段产生可行性分析报告。C)错误，概要设计说明书是总体设计阶段产生的文档。D)错误，集成测试计划是在概要设计阶段编写的文档。B)正确，需求规格说明书是后续工作如设计、编码等需要的重要参考文档。\n');
INSERT INTO `exercises` VALUES ('321', '下面对软件测试描述错误的是（）。\n', '严格执行测试计划，排除测试的随意性', '随机地选取测试数据', '测试根本目的是尽可能多地发现并排除软件中隐藏的错误', '软件测试是保证软件质量的重要手段', 'B', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '在测试之前制定测试计划，并严格执行，测试用例的选择不可随意，应选择有代表性的，尽可能发现迄今为止尚未发现的错误，A选项叙述正确，B选项叙述错误。测试根本目的是尽可能多地发现并排除软件中隐藏的错误，C选项叙述正确。软件测试是保证软件质量、可靠性的关键步骤，D选项叙述正确。故正确答案为B选项。\n');
INSERT INTO `exercises` VALUES ('322', '在数据库系统中，用于对客观世界中复杂事物的结构及它们之间的联系进行描述的是\n', '概念数据模型', '逻辑数据模型', '物理数据模型', '关系数据模型', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '数据模型按照不同的应用层次分为以下3种类型：概念数据模型，着重于对客观世界复杂事物的描述及对它们内在联系的刻画；逻辑数据模型，是面向数据库系统的模型，着重于在数据库系统一级的实现；物理数据模型，是面向计算机物理实现的模型，此模型给出了数据模型在计算机上物理结构的表示。A选项正确。\n');
INSERT INTO `exercises` VALUES ('323', '公司中有多个部门和多名职员，每个职员只能属于一个部门，一个部门可以有多名职员。则实体部门和职员间的联系是\n', '1：1联系', 'm：1联系', '1：m联系', 'm：n联系', 'C', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '两个实体集间的联系实际上是实体集间的函数关系，主要有一对一联系（1:1）、一对多联系（1:m）、多对一联系（m:1）、多对多联系（m:n）。对于每一个实体部门，都有多名职员，则其对应的联系为一对多联系（1:m），答案选C。\n');
INSERT INTO `exercises` VALUES ('324', '关于程序中的注释，以下叙述正确的是（）。\n', '注释的内容必须放在一对/* 和 */之间', '注释必须置于所说明的语句前或语句后', '注释中间可以嵌套另一个注释', '注释内容错误会导致编译出错', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '程序中，注释可以出现在程序的任何位置，B选项错误；注释中间不能嵌套另一个注释，C选项错误；注释内容不影响程序编译，D选项错误，答案为A选项。\n');
INSERT INTO `exercises` VALUES ('325', '有以下程序\n#include <stdio.h>\nmain()\n{  int  k=-17; \n   printf(\"%d,%o,%x\\n\", k, 1-k, 1-k);\n}\n程序的运行结果是（）。\n', '-17,22,12', '-17,12,22', '-17,-22,-12', '17,22,12', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '整型常量有3种表示方法，分别是十进制数表示法、八进制数表示法和十六进制数表示法。十进制整常量没有前缀，输出格式控制符为%d；八进制整常量以０作为前缀，输出格式控制符为%o；十六进制整常量以0X或0x作为前缀，输出格式控制符为%x。1-k=18，整型常量18用八进制表示为22，十六进制表示为12，A选项正确。\n');
INSERT INTO `exercises` VALUES ('326', '以下定义语句中正确的是（）。\n', 'int  a=b=0;', 'char  A=65+1,b=\'b\';', 'float  a=1,*b=&a,*c=&b;', 'double  a=0.0; b=1.1;', 'B', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'A选项语句中b变量还没有定义不能直接用于给a变量赋值?C选项语句中*b?*c表示的是一个实型变量的地址,不能再将&b赋值给指针型变量c?D选项语句中a=0.0后面应该为逗号,不能是分号?\n');
INSERT INTO `exercises` VALUES ('327', '有以下程序：\n#include  <stdio.h>\nmain()\n{　 int s，t，A＝10； double B＝6；\n　　s＝sizeof(A)； t＝sizeof(B)；\n　　printf(\"%d，%d\\n\"，s，t)；\n}\n在VC6.0平台上编译运行，程序运行后的输出结果是(　　)。\n', '10,6', '4,4', '2,4', '4,8', 'D', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'C语言中利用sizeof()函数判断数据类型长度，在VC6.0平台中，整型int占有4个字节，double型数据占有8个字节。\n');
INSERT INTO `exercises` VALUES ('328', '表达式：(int)((double)9/2)- 9%2 的值是（）。\n', '0', '3', '4', '5', 'B', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '先将整型数据9强制转换成double型,然后除以2得到的结果与double型保持一致,即为4.5,然后将4.5强制转换成整型数据4,然后计算9%2的值为1,最后计算4-1的值为3,所以选择B选项?\n');
INSERT INTO `exercises` VALUES ('329', '设有定义：int x=11,y=12,z=0;，以下表达式值不等于12的是（）。\n', '(z,x,y)', '(z=x,y)', 'z=(x,y)', 'z=(x==y)', 'D', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '逗号表达式的计算过程是从左到右逐个求每个表达式的值，取最右边一个表达式的值作为该逗号表达式的值。赋值运算结合性为由右向左结合，赋值运算符左值为变量，右值为变量或常量，且左右两边数据类型相同才能实现赋值。成功实现赋值后以左值为返回值。逻辑表达式成立则返回1，不成立返回0。A选项逻辑表达式x==y不成立，则z=0，表达式值为0。B选项中逗号表达式x,y取y值为表达式值，然后赋值给z=12，表达式值为12。C选项逗号表达式(x,y)取y值为表达式值，然后赋值给z=12，表达式值为12。D选项逗号表达式(z,x,y)取y值为表达式值12。选择D选项。\n');
INSERT INTO `exercises` VALUES ('330', '若有定义：int a=0,b=0,c=0,d=0; ，有C语言表达式 (a++ && b++) ? c++ : d++,以下关于其执行顺序的叙述正确是（）。\n', '先执行a++，表达式a++的值为0，由此即可确定（a++&&b++)的值为0，因此执行d++', '先执行a++，表达式a++的值为0；再执行b++，表达式b++的值为0，由此可确定(a++ && b++)值为0，因此执行d++', '先执行a++，表确定(a++ && b++)值为1，因此执行c++达式a++的值为1；再执行b++，表达式b++的值为1，由此可', '先执行b++，表达式b++的值为1；再执行a++，表达式a++的值为1，由此可确定(a++ && b++)值为1，因此执行c++', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '表达式1？表达式2：表达式3，若表达式1为真，则执行表达式2，否则执行表达式3。逻辑与运算符遵循\"短路求值\"策略，即只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解右操作数，表达式(a++&&b++)中，左操作数a++的值为0，已经可以确定整个逻辑表达式的结果为0，因此右操作数b++不再求解，直接执行表达式3，即d++，答案为A选项\n');
INSERT INTO `exercises` VALUES ('331', '有以下程序：\n# include   <stdio.h>\nmain()\n{ unsigned char  a＝2， b＝4， c＝5， d；\n  d ＝ a | b；    d &＝ c；    printf(\"%d\\n\"， d)；     }\n程序运行后的输出结果是(　　)。\n', '3', '4', '5', '6', 'B', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '& 按位与，如果两个相应的二进制位都为1，则该位的结果值为1，否则为0。| 按位或，两个相应的二进制位中只要有一个为1，该位的结果值为1。2的二进制为00000010,4的二进制为00000100，所以做或运算结果为00000110，该数与5即00000101做与操作结果为00000100，即4\n');
INSERT INTO `exercises` VALUES ('332', '有以下程序\n#include <stdio.h>\nmain( )\n{  char c;\n   c=getchar();\n   do {\n      putchar(c++);\n   } while((c=getchar()) != \'#\');\n}\n程序运行时从第一列开始输入：abcdefg##<回车>，则输出结果是（）。\n', 'bcdefgh$', 'bcdefgh', 'abcdefg#', 'abcdefg', 'D', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '运算符\"++\"放在变量后面时，先参与其他操作，再对变量+1。putchar(c++)表示先输出当前c值，再对c值+1，当输入abcdef##时，在while语句中，程序输入\"#\"，循环退出。因此输出为abcdefg，答案为D选项。\n');
INSERT INTO `exercises` VALUES ('333', '若有定义：char  c; int  d; ，程序运行时输入： 1,2 <回车>，能把值1输入给变量c、值2输入给变量d的输入语句是\n', 'scanf(\"%c,%d\", &c,&d);', 'scanf(\"%c%d\", &c,&d);', 'scanf(\"%d,%f\", &c,&d);', 'scanf(\"%d%d\", &c,&d);', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'scanf函数的调用格式为：scanf(格式控制串，地址列表)；，格式控制串，由%开头，后跟格式字符，如c对应字符型变量，d对应整型变量。地址表列需要读入的是所有变量的地址或字符串的首地址。如果除了格式说明字符和附加格式字符外，如果还有其他字符，则在输入数据时要求按一一对应的位置原样输入这些字符，比如两个格式说明之间有一个逗号，则从键盘输入时输入量之间也应照原样输入逗号。A选项正确。\n');
INSERT INTO `exercises` VALUES ('334', '有以下程序\n#include <stdio.h>\nmain()\n{  int a=1,b=2,c=3,d=0;\n   if (a==1 && b++==2)\nif (b!=2||c--!=3)\nprintf(\"%d,%d,%d\\n\",a,b,c);\n      else  printf(\"%d,%d,%d\\n\",a,b,c);\n   else  printf(\"%d,%d,%d\\n\",a,b,c);\n}\n程序运行后的输出结果是（）。\n', '1,3,2', '1,3,3', '1,2,3', '3,2,1', 'B', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'else总是和最近的if配对,所以进入第一个if语句中条件判断时,因为是逻辑与操作需要两边运算对象的值均为非零值,才为真,所以需要逐个执行判断的结果为1,不再执行第二个case语句中的操作?而是进入第二个if语句条件判断,因为b!=2条件成立所以整个条件表达式的值为真,所以不再执行逻辑或的第二个运算对象(c-- !=3)c的值不变,也不再执行第一个else语句?打印a的值1,b的值3,c的值3?\n');
INSERT INTO `exercises` VALUES ('335', '有以下程序\n    #include <stdio.h>\n    main()\n    {   int  s;\n        scanf(\"%d\", &s);\n        while( s>0 )  \n        {  switch(s) \n           {  case 1: printf(\"%d\", s+5);\n             case 2: printf(\"%d\", s+4); break;\n             case 3: printf(\"%d\", s+3);\n             default: printf(\"%d\", s+1); break; \n           }\n           scanf(\"%d\", &s);\n        }\n    }\n运行时，若输入1 2 3 4 5 0<回车>，则输出结果是（）。\n', '66656', '6566456', '66666', '6666656', 'B', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'switch语句的执行流程是:首先计算switch后面圆括号中表达式的值,然后用此值依次与各个case的常量表达式比较,若圆括号中表达式的值与某个case后面的常量表达式的值相等,就执行此case后面的语句,执行后遇break语句就退出switch语句;若圆括号中表达式的值与所有case后面的常量表达式都不等,则执行default后面的语句?然后退出?所以输入1时打印65,输入2时打印6,输入3时打印64,输入4时打印5,输入5时打印6?\n');
INSERT INTO `exercises` VALUES ('336', '设有以下代码\ndo {\n   while (条件表达式1)\n        循环体A;\n} while (条件表达式2);\nwhile (条件表达式1)\n{\n   do {\n      循环体B;\n   } while (条件表达式2);\n}\n其中，循环体A与循环体B相同，以下叙述正确的是（）。\n', '循环体A与循环体B的执行次数相同', '循环体A比循环体B的执行次数多一次', '循环体A比循环体B的执行次数少一次', '循环体A与循环体B的执行次数不确定', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'while循环语句一般形式为：while(表达式){循环体}，执行过程为：首先判断表达式，成立（非0）则执行循环体，不成立（0）则退出循环。do…while循环语句一般形式为：do{循环体}while(表达式)，执行过程为：首先执行循环体，之后判断表达式，成立（非0）则再一次执行循环体，不成立（0）则退出循环。假设表达式1与表达式2成立次数为n1与n2。若n1>n2，则循环体A执行次数为n2+1，B执行次数n2+1；若n1<n2，则循环体A执行次数为n1，B执行次数n1，A选项正确。\n');
INSERT INTO `exercises` VALUES ('337', '有以下程序\n#include <stdio.h>\nmain( )\n{  int a=0, b=0;\n   for(; a<5; a++)\n   {  if (a%2==0) continue;\n      b += a;\n      break;\n   }\n   printf(\"%d \\n\", b);\n}\n程序运行后的输出结果是（）。\n', '1', '4', '0', '10', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'for语句中，当a=0时，满足for循环中if语句的条件，执行continue继续下一次循环，a+1后再进入for语句循环，此时a=1不满足if语句，执行b=b+a为1，接着执行break语句，终止循环，最后输出b=1,故答案为A选项。\n');
INSERT INTO `exercises` VALUES ('338', '有以下程序\n    #include <stdio.h>\n    main()\n    {  int   i=5;\n       do\n       {  if (i%3==1)\n            if (i%5==2)\n            {  printf(\"*%d\", i);  break;  }\n          i++;\n       }  while(i!=0);\n       printf(\"\\n\");\n    }\n\n程序的运行结果是\n', '*2*6', '*3*5', '*5', '*7', 'D', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'do...while语句是先执行后判断,所以第一次先执行循环体,判断i%3= =1的条件,由于i为5所以余数为2,条件不成立,执行i++,i的值为6,判断while条件为真,第二次执行循环体,同第一次循环体的执行过程一样,i的值变为7,判断while条件为真,第三次执行循环体,此时i%3= =1条件成立,判断i%5==2也成立,打印*与i的值,即*7,然后执行break语句,跳出循环?所以选择D选项?\n');
INSERT INTO `exercises` VALUES ('339', '有以下程序\n     #include <stdio.h>\n     main()\n     {  int  c[6]={10,20,30,40,50,60},  *p,*s;\n        p = c;    s = &c[5];\n        printf(\"%d\\n\", s-p );\n     }\n程序运行后的输出结果是（）。\n', '5', '50', '6', '60', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '首先初始化一维数组c[6]，语句p = c;指将c[0]元素的地址赋给指针变量p；语句s = &c[5];指将c[5] 元素的地址赋给指针变量s。程序最后输出s-p，即结果为5。因此A选项正确。\n');
INSERT INTO `exercises` VALUES ('340', '有以下程序\n#include  <stdio.h>\nvoid  fun( int  a[ ], int  n, int  flag )\n{  int  i=0,j, t;\n   for ( i=0; i<n-1; i++ )\n      for ( j=i+1; j<n; j++ )\n        if ( flag )\n\n        {   if ( a[i] < a[j] )\n            {  t = a[i];  a[i] = a[j];  a[j] = t;  }\n        }\n       else\n       {   if ( a[i] > a[j] )\n           {  t = a[i];  a[i] = a[j];  a[j] = t;  }\n       }\n}\nmain( )\n{  int  c[10]={ 7,9,10,8,3,5,1,6,2,4 },i;\n   fun( c, 4, 1 );\n   fun( c+4, 6, 0 );\n   for ( i=0;i<10; i++ )    printf( \"%d,\", c[i] );\n   printf(\"\\n\");\n}\n程序运行后的输出结果是（）。\n', '7,8,9,10,6,5,4,3,2,1', '10,9,8,7,6,5,4,3,2,1', '10,9,8,7,1,2,3,4,5,6,', '1,2,3,4,5,6,7,8,9,10,', 'C', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'fun()函数作用冒泡法排序，flag控制升序（0）或者降序（1）。n为参与排序的个数。a为数组的起始地址。因此，fun(a,4,1),数组的前四个降序排序，fun(a+4,6,0)从数组的第四项，后六个升序排序。故结果为10,9,8,7,1,2,3,4,5,6。答案为C选项\n');
INSERT INTO `exercises` VALUES ('341', '下列选项中，能正确定义数组的语句是（）。\n', 'int num[0...2008];', 'int num[];', 'int N=2008;', '#define N 2008', 'D', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'C语言不允许定义动态数组，定义数组的大小必须为常量表达式。A选项错误，C语言中数组没有此类型的定义方法；B选项错误，定义数组应指明数组大小，如果不指明数组大小，需要给定初值的个数；C选项错误，N为变量，不能用来定义数组大小。因此D选项正确。\n');
INSERT INTO `exercises` VALUES ('342', '有以下程序\n    #include <stdio.h>\n    main()\n    { \n        int  a[4][4]={{1,4,3,2},\n                      {8,6,5,7},\n                      {3,7,2,5},\n                      {4,8,6,1}};\n        int i, j, k, t;\n        for (i=0; i<4; i++)\n            for (j=0; j<3; j++)\n                for (k=j+1; k<4; k++)\n                    if (a[j][i] > a[k][i]) \n                       { \n                           t=a[j][i]; \n                           a[j][i] = a[k][i]; \n                           a[k][i] = t;\n                       } /* 按列排序 */\n        for (i=0; i<4; i++) \n            printf(\"%d, \",a[i][i]);\n    }\n程序运行后的输出结果是（）。\n', '1, 6, 2, 1,', '8, 7, 3, 1,', '4, 7, 5, 2,', '1, 6, 5, 7,', 'D', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '首先对二维数组进行赋值操作，a[0][0]、a[0][1]、…、a[3][2]、a[3][3]的值为1、4、…、6、1。通过for语句和if语句，对二维数组各列元素进行由小到大的排序操作，程序最后通过for语句输出二维数组对角线上的元素。因此D选项正确。\n');
INSERT INTO `exercises` VALUES ('343', '有以下程序\n#include <stdio.h>\nmain( )\n{  char w[20], a[5][10] = {\"abcdef\", \"ghijkl\", \"mnopq\", \"rstuv\", \"wxyz\"};\n   int i,j;\n   for (i=0; i<5; i++)\n   {   j=0;\n       while (a[i][j]!=\'\\0\')  j++;\n       w[i] = a[i][j/2+1];\n   }\n   w[5]= \'\\0\';\n   puts(w);\n}\n程序运行后的输出结果是（）。\n', 'ekpuz', 'agmrw', 'flqvz', 'djoty', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '在for循环中，执行完while语句，j值为字符串数组a的每行字符串的长度，因此w[i] = a[i][j/2+1]，数组a的元素a[i][j/2+1]的值赋给一维数组w[i]。比如i=0;j=6;a[i][j/2+1]=a[0][4]=\'e\'，将此值赋给w[0]。循环依次给数组W赋值最后输出w，答案为A选项。\n');
INSERT INTO `exercises` VALUES ('344', '有以下程序（strcpy为字符串复制函数，strcat为字符串连接函数) \n     #include <stdio.h>\n     #include <string.h>\n     main()\n     { char  a[10] = \"abc\", b[10] = \"012\", c[10] = \"xyz\";\n       strcpy( a+1, b+2 );\n       puts( strcat( a, c+1 ) );\n     }\n程序运行后的输出结果是（）。\n', 'a12xyz', 'bc2yz', 'a2yz', '12yz', 'C', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '本题考查字符串处理函数strcpy和strcat，执行完strcpy( a+1, b+2 );后，a变为a2，执行完strcat( a, c+1 )后，a变为a2yz，所以答案为C选项。\n');
INSERT INTO `exercises` VALUES ('345', '有以下程序\n     #include <stdio.h>\n     int f(int  n)\n     { int  t = 0,   a=5; \n       if (n/2) {int  a=6;    t += a++;  }\n       else    {int  a=7;     t += a++;  }\n       return  t + a++;\n     }\n     main()\n     { int  s=0, i=0;     \n       for (; i<2;i++)  s += f(i);\n       printf(\"%d\\n\", s);\n     }\n程序运行后的输出结果是\n', '28', '24', '32', '36', 'B', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '在主函数main()中定义了两个变量s和i，同时给s和i赋初值0。当i=0时。执行\"s+＝f(i)；\"语句，调用f()并将i的初值 0传递给形参n。首先执行if语句中内条件：n/2,条件为假。则执行else下的语句，a＝7,t＝7+0＝7，使用return返回t，t＝7+(a++)＝7+5＝12，此时a运算完后自增1,变为6；返回主函数中，s＝0+12＝12。当i=1时，执行\"s+=f(i)；\"语句，调用f()并将i的初值1传递给形参n。首先执行if语句中的条件：n/2，条件为真，执行if下面的语句，t＝0，a＝6 t＝0+6＝6，使用return返回t，t=6+6=12，返回主函数中，s＝12+12=24。最后输出的结果为24。因此B选项正确。\n');
INSERT INTO `exercises` VALUES ('346', '有以下程序\n     #include <stdio.h>\n     void fun( int *a,int *b)\n     { int *c;\n       c=a;a=b;b=c;\n     }\n     main()\n     { int  x=3, y=5, *p=&x, *q=&y ;\n       fun(p,q);  printf(\"%d,%d,\",*p,*q);\n       fun(&x,&y); printf(\"%d,%d\\n\",*p,*q);\n     }\n程序运行后的输出结果是（）。\n', '3,5,3,5', '3,5,5,3', '5,3,3,5', '5,3,5,3', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'fun函数的功能是交换形式参数的值，即交换指针变量a和b的值，但是fun函数并不能够交换实参的值，因此fun(p,q)不能交换p和q的值，所以第一个printf语句的输出为3,5。第二个fun函数对x和y的地址进行了操作，同样不能交换x和y的值，并不能影响p和q指针指向的数据，因此第二个printf语句的输出也是3,5。因此A选项正确。\n');
INSERT INTO `exercises` VALUES ('347', '有以下程序：\n#include  <stdio.h>\nint f(int x)；\nmain()\n{ int n＝1，m；\n　m＝f(f(f(n)))； printf(\"%d\\n\"，m)；\n}\nint f(int x)\n{ return x*2； }\n程序运行后的输出结果是(　　)。\n', '8', '2', '4', '1', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '第一次调用m＝f(f(f(1)))，第二次为m＝f(f(2))，第三次为m＝f(4)，即返回值为8。\n');
INSERT INTO `exercises` VALUES ('348', '设有如下函数定义：\n#include  <stdio.h>\nint  fun( int  k )\n{　 if (k<1)  return  0；\n　　else  if (k＝＝1)  return  1；\n　　else  return  fun(k－1)＋1；\n}\n若执行调用语句：n＝fun(3)；，则函数fun总共被调用的次数是(　　)。\n', '2', '3', '4', '5', 'B', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '首先 n＝fun(3),3被当作参数传递进去，这就进行了一次调用，3被当做参数传进去后，程序会执行这句 else return fun(k－1)＋1； 这就调用了第二次，而参数是3－1也就是2。2被当做参数传进去后，程序会执行这句 else return fun(k－1)＋1； 这就调用了第三次，而参数是2－1也就是1。1被当做参数传进去后，程序会执行这句 else if(k＝＝1) return 1； 不再递归调用，所以最终结果为3次。\n');
INSERT INTO `exercises` VALUES ('349', '以下与存储类别有关的四组说明符中，全部属于静态类的一组是（）。\n', 'extern和static', 'auto和static', 'register和static', 'register和extern', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, 'auto用于声明变量的生存期为自动，即将不在任何类、结构、枚举、联合和函数中定义的变量视为全局变量，而在函数中定义的变量视为局部变量。这个关键字通常会被省略，因为所有的变量默认就是auto的。\nregister定义的变量告诉编译器尽可能的将变量存在CPU内部寄存器中而不是通过内存寻址访问以提高效率。\nstatic变量会被放在程序的全局存储区中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。当static用来修饰全局变量时，它就改变了全局变量的作用域。\nextern限制在了当前文件里，但是没有改变其存放位置，还是在全局静态储存区。extern 外部声明, 该变量在其他地方有被定义过。因此，答案为A选项\n');
INSERT INTO `exercises` VALUES ('350', '以下选项中的编译预处理命令行，正确的是（）。\n', '#define    E      2.38', '##define   PI_2   1.56', '#define    int    INT', '#DEFINE    TRUE', 'A', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '无参宏定义格式：#define 标识符 字符串，标识符与C语言规定相同，因此，可知选项B，多了#,选项C使用c语言的关键字，选项D 格式不对。因此答案为A选项。\n');
INSERT INTO `exercises` VALUES ('351', '有以下程序\n#include <stdio.h>\n#define  S(x)  x/x*x\nmain( )\n{  int  k=6, j=3;\n   printf(\"%d,%d\\n\", S(k+j), S(j+k));\n}\n程序运行后的输出结果是（）。\n', '27,27', '9,9', '27,29', '29,29', 'C', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '定义一个带参数的宏时，字符串内的形参通常要用圆括号括起来，以避免出错，本题中，S（k+j）相当于执行运算k+j/k+j*k+j，将k,j值代入运算后取整为27，S(j+k)同理，因此答案为C选项。\n');
INSERT INTO `exercises` VALUES ('352', '若有以下程序段\n    struct  st{ int n; struct st *next; };\n    struct st a[3]={ 5,&a[1],7,&a[2],9,\'\\0\' },  *p;\n    p=&a[0];\n则以下选项中值为6的表达式是（）。\n', 'p->n', '(*p).n', 'p->n++', '++(p->n)', 'D', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '本题考查结构体变量的引用，其中a为定义的结构体数组，D选项中p->n为5，++（p->n）为6，所以D选项正确。\n');
INSERT INTO `exercises` VALUES ('353', '有以下程序\n    #include <stdio.h>\n    main()\n    {  FILE  *fp;\n       int   a[10]={1,2,3,0,0}, i;\n       fp = fopen(\"d2.dat\", \"wb\");\n       fwrite(a, sizeof(int), 5, fp);\n       fwrite(a, sizeof(int), 5, fp);\n       fclose(fp);\n       fp = fopen(\"d2.dat\", \"rb\");\n       fread(a, sizeof(int), 10, fp);\n       fclose(fp);\n       for (i=0; i<10; i++)\n            printf(\"%d,\", a[i]);\n    }\n程序的运行结果是\n', '1,2,3,0,0,0,0,0,0,0,', '1,2,3,1,2,3,0,0,0,0,', '123,0,0,0,0,123,0,0,0,0,', '1,2,3,0,0,1,2,3,0,0,', 'D', null, '26', '2018年3月二级《C语言》冲刺提分卷', null, '本题考查文件操作函数，两次fwrite后，fp文件中已经写入1,2,3,0,0,1,2,3,0,0然后将文件fp中的内容重新写入数组a中，最后输出a为1,2,3,0,0,1,2,3,0,0，所以选项D正确。\n');
INSERT INTO `exercises` VALUES ('355', '设数据集合为D={ 1,3,5,7,9 }，D上的关系为R，下列数据结构B=（D，R）中为非线性结构的是\n', 'R={ (5,1), (7,9), (1,7), (9,3) }', 'R={ (9,7), (1,3), (7,1), (3,5) }', 'R={ (1,9), (9,7), (7,5), (5,3) }', 'R={ (1,3), (3,5), (5,9) }', 'D', null, '27', '2018年3月二级《C语言》题库试题', null, '一个非空的数据结构如果满足以下两个条件：有且只有一个根结点；每一个结点最多有一个前件，也最多有一个后件，则称为线性结构，在数据结构中习惯称为线性表。A选项中，5为根结点，线性表为51793。B选项中，9为根结点，线性表为97135。C选项中，1为根结点，线性表为19753。D选项，结点1与7都是根结点，属于非线性结构，故D选项正确。\n');
INSERT INTO `exercises` VALUES ('356', '设栈的顺序存储空间为S(1: 50),初始状态为top=0。现经过一系列入栈与退栈运算后，top=20，则当前栈中的元素个数为\n', '30', '29', '20', '19', 'C', null, '27', '2018年3月二级《C语言》题库试题', null, '栈是一种特殊的线性表，它所有的插入与删除都限定在表的同一端进行。入栈运算即在栈顶位置插入一个新元素，退栈运算即是取出栈顶元素赋予指定变量。当栈为空时，栈顶指针top=0，经过入栈和退栈运算，指针始终指向栈顶元素。top=20，则当前栈中有20个元素，C选项正确。\n');
INSERT INTO `exercises` VALUES ('357', '设栈的顺序存储空间为S(1: 50),初始状态为top=0。现经过一系列入栈与退栈运算后，top=20，则当前栈中的元素个数为\n', '30', '29', '20', '19', 'C', null, '27', '2018年3月二级《C语言》题库试题', null, '栈是一种特殊的线性表，它所有的插入与删除都限定在表的同一端进行。入栈运算即在栈顶位置插入一个新元素，退栈运算即是取出栈顶元素赋予指定变量。当栈为空时，栈顶指针top=0，经过入栈和退栈运算，指针始终指向栈顶元素。top=20，则当前栈中有20个元素，C选项正确。\n');
INSERT INTO `exercises` VALUES ('358', '设循环队列的存储空间为Q(1: 35)，初始状态为front=rear=35。现经过一系列入队与退队运算后，front=15，rear=15，则循环队列中的元素个数为\n', '15', '16', '20', '0或35', 'D', null, '27', '2018年3月二级《C语言》题库试题', null, '在循环队列中，用队尾指针rear指向队列中的队尾元素，用排头指针front指向排头元素的前一个位置。在循环队列中进行出队、入队操作时，头尾指针仍要加１，朝前移动。只不过当头尾指针指向向量上界时，其加１操作的结果是指向向量的下界０。由于入队时尾指针向前追赶头指针，出队时头指针向前追赶尾指针，故队空和队满时，头尾指针均相等。答案为D选项。\n');
INSERT INTO `exercises` VALUES ('359', '面向对象方法中，继承是指(　　)。\n', '一组对象所具有的相似性质', '一个对象具有另一个对象的性质', '各对象之间的共同性质', '类之间共享属性和操作的机制', 'D', null, '27', '2018年3月二级《C语言》题库试题', null, '继承是面向对象的方法的一个主要特征，是使用已有的类的定义作为基础建立新类的定义技术。广义的说，继承是指能够直接获得已有的性质和特征，而不必重复定义它们，所以说继承是指类之间共享属性和操作的机制。\n');
INSERT INTO `exercises` VALUES ('360', '下面不属于对象基本特点的是\n', '标识唯一性', '可复用性', '多态性', '封装性', 'B', null, '27', '2018年3月二级《C语言》题库试题', null, '对象的基本特点如下：\n特  点	描  述\n标识唯一性	一个对象通常可由对象名、属性和操作三部分组成\n分类性	指可以将具有相同属性和操作的对象抽象成类\n多态性	指同一个操作可以是不同对象的行为，不同对象执行同一操作产生不同的结果\n封装性	从外面看只能看到对象的外部特性，对象的内部对外是不可见的\n模块独立性好	由于完成对象功能所需的元素都被封装在对象内部，所以模块独立性好\n可知B选项正确。\n');
INSERT INTO `exercises` VALUES ('361', '数据流图中带有箭头的线段表示的是(　　)。\n', '控制流', '事件驱动', '模块调用', '数据流', 'D', null, '27', '2018年3月二级《C语言》题库试题', null, '数据流图中带箭头的线段表示的是数据流，即沿箭头方向传送数据的通道，一般在旁边标注数据流名。\n');
INSERT INTO `exercises` VALUES ('362', '耦合性和内聚性是对模块独立性度量的两个标准。下列叙述中正确的是(　　)。\n', '提高耦合性降低内聚性有利于提高模块的独立性', '降低耦合性提高内聚性有利于提高模块的独立性', '耦合性是指一个模块内部各个元素间彼此结合的紧密程度', '内聚性是指模块间互相连接的紧密程度', 'B', null, '27', '2018年3月二级《C语言》题库试题', null, '模块独立性是指每个模块只完成系统要求的独立的子功能，并且与其他模块的联系最少且接口简单。一般较优秀的软件设计，应尽量做到高内聚，低耦合，即减弱模块之间的耦合性和提高模块内的内聚性，有利于提高模块的独立性，所以A)错误，B)正确。耦合性是模块间互相连接的紧密程度的度量而内聚性是指一个模块内部各个元素间彼此结合的紧密程度，所以C)与D)错误。\n');
INSERT INTO `exercises` VALUES ('363', '某系统结构图如下图所示\n \n该系统结构图的最大扇出数是\n', 'n', '1', '3', '4', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, '扇出指的是由一个模块直接调用的其他模块数。题干中某系统为一个模块，其扇出数目为n(n>3)，功能1与功能n模块扇出数均为2，故A选项正确。\n');
INSERT INTO `exercises` VALUES ('364', '有表示公司和职员及工作的三张表，职员可在多家公司兼职。其中公司C（公司号，公司名，地址，注册资本，法人代表，员工数），职员S（职员号，姓名，性别，年龄，学历），工作W（公司号，职员号，工资），则表W的键（码）为\n', '公司号，职员号', '职员号，工资', '职员号', '公司号，职员号，工资', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, '由于职员可以再多加公司兼职，表W的键（码）应为公司关系和职员关系的主码，即公司号和职员号。\n');
INSERT INTO `exercises` VALUES ('365', '以下叙述中错误的是\n', '书写风格良好的程序执行效率高', '书写风格良好的程序易读性好', 'C程序可以在一行上写多条语句', 'C程序允许将一条语句分写在多行上', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, '书写风格良好的程序易读性好，方便团队合作，分模块来完成复杂的程序设计，B选项叙述正确。但是书写风格与程序执行效率无关，程序执行效率与程序的数据结构有关，由算法的时间复杂度和空间复杂度决定，A选项叙述错误。C语言程序书写规范中，良好的书写习惯中一般一行上写一条语句，这样方便阅读，但是一行写多条语句是符合C程序编写规则的，C选项叙述正确。C程序允许将一条较长的语句分写在多行，D选项叙述正确。叙述中错误的是A选项,故选择A选项。\n');
INSERT INTO `exercises` VALUES ('366', '关于算法，以下叙述中错误的是（）。\n', '某个算法可能会没有输入', '同一个算法对于相同的输入必须得出相同的结果', '一个算法对于某个输入的循环次数是可以事先估计出来的', '任何算法都能转换成计算机高级语言的程序，并在有限时间内运行完毕', 'D', null, '27', '2018年3月二级《C语言》题库试题', null, '算法的特征:①有穷性?一个算法(对任何合法的输入)在执行有穷步后能够结束,并且在有限的时间内完成?②确定性?算法中的每一步都有确切的含义?③可行性?算法中的操作能够用已经实现的基本运算执行有限次来实现?④输入:一个算法有零个或者多个输入,零个输入就是算法本身确定了初始条件?⑤输出:一个算法有一个或者多个输出,以反映出数据加工的结果?所以选择D选项?\n');
INSERT INTO `exercises` VALUES ('367', '下面选项中合法的字符常量是\n', '\"X\"', '\'X\'', '\'abc\'', '\'\\\'', 'B', null, '27', '2018年3月二级《C语言》题库试题', null, '字符常量是用单引号括起来的一个字符。A选项中，使用双引号，所以是错误的； C选项中，\'abc\'是字符串，字符常量只能是单个字符，不能是字符串；D选项中，以反斜线\"\\\"开头的是转义字符。因此B选项正确。\n');
INSERT INTO `exercises` VALUES ('368', '有以下程序\n#include <stdio.h>\nmain()\n{\n   int  a, b, c=241;\n   a = c/100 % 9;\n   b = ( -1 )&&( -1 );\n   printf(\"%d, %d\\n\", a, b );\n}\n程序运行后的输出结果是\n', '2,1', '6,1', '6,0', '2,0', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, '程序执行过程为：c=241，c/100=2,2%9=2,得a=2;“=”优先级低于“&&”，非0值为真，0值为假，即（-1）为真，逻辑与表达式（-1）&&（-1）为真，得b=1。A选项正确。\n');
INSERT INTO `exercises` VALUES ('369', '有以下程序\n#include   <stdio.h>\nint sub(double  a, double  b)\n{\n    return (int)(a - b - 1.3);\n}\nmain( )\n{\n    printf(\"%d\\n\", sub(3.2, 4.1));\n}\n程序运行后的输出结果是（）。\n', '-2', '1.7', '-3', '2.0', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, 'sub函数输出(int)(a - b - 1.3)将结果强制转化为整型，因此可以排除B、D选项，sub(3.2,4.1)=-2,故答案为A选项。\n');
INSERT INTO `exercises` VALUES ('370', '若有定义：int  a=0,b=0,c=0,d=0;，以下关于C语言表达式：(++a || ++b) ? ++c : ++d 执行顺序的叙述正确的是（）。\n', '先执行++a，表达式++a的值为1；再执行++b，表达式++b的值为1，由此可确定(++a || ++b)值为1，因此执行++c', '先执行++a，表达式++a的值为1，由此可确定(++a || ++b)值为1，因此执行++c', '先执行++b，表达式++b的值为1；再执行++a，表达式++a的值为1，由此可确定(++a || ++b)值为1，因此执行++c', '先执行++b，表达式++b的值为1，由此可确定(++a || ++b)值为1，因此执行++c', 'B', null, '27', '2018年3月二级《C语言》题库试题', null, '表达式1？表达式2：表达式3，若表达式1为真，则执行表达式2，否则执行表达式3，++a表示先将变量a+1，再执行其他操作，逻辑或运算符遵循\"短路求值\"策略，即只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解右操作数，表达式(++a || ++b)中，左操作数++a的值为1，已经可以确定整个逻辑表达式的结果为1，因此右操作数++b不再求解，直接执行表达式2，即++c，答案为B选项。\n');
INSERT INTO `exercises` VALUES ('371', '若有定义语句：\n    int  a=3,b=2,c=1; \n以下选项中错误的赋值表达式是（）。\n', 'a=(b=4)=3;', 'a=b=c+1;', 'a=(b=4) +c;', 'a=1+(b=c=4);', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, '不能将变量或常量赋给一个表达式,所以A选项中(b=4)=3是错误的\n');
INSERT INTO `exercises` VALUES ('372', '有以下程序\n     #include <stdio.h>\n     main()\n     {  int  i=0;\n        i = ~ i;\n        printf(\"%d\\n\",i);\n     }\n程序运行后的输出结果是（）。\n', '8', '0', '1', '-1', 'D', null, '27', '2018年3月二级《C语言》题库试题', null, '本题考查位运算中按位取反，0按位取反就是-1，所以选项D正确。\n');
INSERT INTO `exercises` VALUES ('373', '有以下程序\n    #include <stdio.h>\n    main()\n    { \n        char  c1,c2,c3,c4,c5,c6;\n        scanf(\"%c%c%c%c\", &c1,&c2,&c3,&c4);\n        c5=getchar();    \n        c6=getchar();\n        putchar(c1);         \n        putchar(c2);\n        printf(\"%c%c\\n\",c5,c6);\n    }\n程序运行后，若从键盘输入（从第1列开始) \n     123<回车>\n     45678<回车>\n则输出结果是（）。\n', '1245', '1256', '1278', '1267', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, 'Scanf按照格式字符进行输入,所以123与回车的值分别送入了c1?c2?c3?c4变量的存储空间?getchar()函数的功能是从键盘输入的字符串中读入一个字符,所以4送入了变量c5的存储空间,5送入了变量c6的存储空间?所以打印时结果为1245?\n');
INSERT INTO `exercises` VALUES ('374', '设有定义：\nint n = 1234;  \ndouble x = 3.1415;\n\n则语句 \nprintf(\"%3d,%1.3f\\n\", n, x); \n的输出结果是\n', '1234,3.142', '123,3.142', '1234,3.141', '123,3.141', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, '函数printf()中，%md指输出带符号的十进制整数，给定最小宽度为m位，不足m位左端补空格，超过m位按实际位数输出，%.nf表示以小数形式输出实数，小数占n位，对应题目，答案为A选项。\n');
INSERT INTO `exercises` VALUES ('375', '设变量均已正确定义，若要通过\n    scanf(\"%d%c%d%c\",&a1,&c1,&a2,&c2);\n语句为变量a1和a2赋数值10和20，为变量c1和c2赋字符X和Y。以下所示的输入形式中正确的是（注：□代表空格字符）\n', '10□X<回车>', '10□X20□Y<回车>', '10X<回车>', '10□X□20□Y<回车>', 'C', null, '27', '2018年3月二级《C语言》题库试题', null, '输入数据的格式必须与scanf()的格式控制串完全匹配,如果A、B?D选项中在数字10后面均输入了空格,则会将空格赋给变量c1,而不是把X赋给c1,所以选择C选项?\n');
INSERT INTO `exercises` VALUES ('376', '有以下程序\n#include <stdio.h>\nmain()\n{  char b[3][10];  int i;\n   for (i=0; i<2; i++)\n      scanf(\"%s\", b[i]);\n   gets(b[2]);\n   printf(\"%s%s%s\\n\", b[0],b[1],b[2]);\n}\n执行时若从第一列输入:Fig flower is red. <回车>\n则输出结果是\n', 'Figflower is red.', 'Figfloweris red.', 'Figflowerisred.', 'Fig flower is red.', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, 'scanf()函数从输入设备按照指定的类型输入对应类型的若干个数据，遇到空格、制表符和回车时，读取结束。gets()函数从标准输入设备键盘上读取1个字符串（可以包含空格），并将其存储到字符数组中去。此函数的读取结束符是换行符，即当遇到一个换行符时，就停止读操作，并且换行符不能够作为字符串的内容来存储，系统会自动用“\\0”来代替。可知读到第一个空格时b[0]赋值结束，为Fig，读到第二个空格时b[1]赋值结束，为flower，退出for循环执行gets()函数，空格为有效字符，b[2]=“ is red.” ，之后打印三个字符串，A选项正确。\n\n');
INSERT INTO `exercises` VALUES ('377', '若有以下程序\n    #include <stdio.h>\n    main()\n    {  int  a=1,b=2,c=3,d=4;\n       if ((a=2) || (b=1)) c=2;\n       if ((c==3) && (d=-1)) a=5;\n       printf(\"%d,%d,%d,%d\\n\", a,b,c,d);\n    }\n\n则程序的输出结果是（）。\n', '1,2,3,4', '2,1,2,-1', '5,1,2,-1', '2,2,2,4', 'D', null, '27', '2018年3月二级《C语言》题库试题', null, '第一个if语句的判断条件中是逻辑或表达式,所以只要有一个运算对象为真结果就为真,且如果前面的已经为真,后面的表达式不再进行执行判断?执行第一个if判断条件时a的值为2,整个表达式的值为真,b的值不变,c的值为2?判断第二个if条件为逻辑与表达式,只有两个运算对象均非零,才为真,第一个表达式c==3,不成立,不再判断第二个运算对象,所以不执行d=-1操作和a=5操作?所以结果为选项D?\n');
INSERT INTO `exercises` VALUES ('378', '有以下程序：\n#include  <stdio.h>\nmain()\n{　int   x＝1， y＝0， a＝0， b＝0；\n　　 switch (x)\n　　 {　case   1：\n　　　　switch(y)\n　　　　{　case   0：  a++；  break；\n　　　　　 case   1：  b++；  break；\n　　　　　　}\n　　　　 case 2：  a++；  b++；  break；\n　　　　 case 3：  a++；  b++；\n　　}\n　　printf(\"a＝%d， b＝%d\\n\"， a， b)；\n}\n程序的运行结果是(　　)。\n', 'a＝2，b＝2', 'a＝2，b＝1', 'a＝1，b＝1', 'a＝1，b＝0', 'B', null, '27', '2018年3月二级《C语言》题库试题', null, 'case常量表达式只是起语句标号作用，并不是该处进行条件判断。在执行switch语句时，根据switch的表达式，找到与之匹配的case语句，就从此case子句执行下去，不在进行判断，直到碰到break或函数结束为止。所以执行内层switch(y)时只执行了a++，此时a的值为1。然后执行外层case 2语句的a++；b++；a为2，b为1。所以结果为B)。\n');
INSERT INTO `exercises` VALUES ('379', ' 有以下程序\n#include   <stdio.h>\nmain( )\n{  int  m,n;\n   scanf(\"%d%d\", &m,&n);\n   while(m!=n)\n   {   while(m>n) { m=m-n; }\n       while(n>m) { n=n-m; }\n   }\n   printf(\"%d\\n\",m);\n} \n该程序的功能是（）。\n', '计算m和n的最小公倍数', '计算m和n的最大公约数', '计算m和n的差值', '找出m和n中的较大值', 'B', null, '27', '2018年3月二级《C语言》题库试题', null, '题目使用更相减损术求最大公约数，其思想：1、任意给定两个正整数，判断它们是否都是偶数。若是，则用2约简，若不是则执行第二步。\n第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。\n则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。\n因此。故答案为B选项\n');
INSERT INTO `exercises` VALUES ('380', '有以下程序\n#include  <stdio.h>\nmain( )\n{  int a=1, b=0;\n   for(; a<5; a++)\n   {  if (a%2 == 0) break;\n      continue;\n      b += a;\n   }\n   printf(\"%d \\n\", b);\n}\n程序运行后的输出结果是（）。\n', '0', '1', '10', '4', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, '题干中for循环有break和continue语句，且均放在b+=a语句前面，无论if条件是否满足，b+=a都不会被执行，因此b值始终为0，答案为A选项。\n');
INSERT INTO `exercises` VALUES ('381', '若有以下定义\n    int  x[10],  *pt=x;\n则对x数组元素的正确引用是（）。\n', 'pt+3', '*&x[10]', '*(pt+10)', '*(x+3)', 'D', null, '27', '2018年3月二级《C语言》题库试题', null, '没有A选项的引用形式。*与&放在一起作用抵消，所以B选项错误，最大只能引用到x[9]。*(pt+i)表示引用指针pt所指元素后的第i个元素，所以C选项错误，最大只能为*(pt+9)。因此D选项正确。\n');
INSERT INTO `exercises` VALUES ('382', '有以下程序\n    #include <stdio.h>\n    main()\n    { \n        int  a[4][4]={ {1,4,3,2},{8,6,5,7},{3,7,2,5},{4,8,6,1}}, i, k, t;\n        for (i=0; i<3; i++)\n            for (k=i+1; k<4; k++)  \n                if (a[i][i] < a[k][k]) \n                { t=a[i][i]; a[i][i]=a[k][k]; a[k][k]=t;}\n        for (i=0; i<4; i++) \n            printf(\"%d,\", a[0][i]);\n    }\n程序运行后的输出结果是（）。\n', '1,1,2,6,', '6,2,1,1,', '6,4,3,2,', '2,3,4,6,', 'C', null, '27', '2018年3月二级《C语言》题库试题', null, '首先对二维数组进行赋值操作，a[0][0]、a[0][1]、…、a[3][2]、a[3][3]的值为1、4、…、6、1。通过for嵌套循环语句和if条件语句，对二维数组对角线元素进行由大到小的排序操作，程序最后通过for语句输出二维数组第1行的4个元素。因此C选项正确。\n');
INSERT INTO `exercises` VALUES ('383', '有以下程序\n     #include <stdio.h>\n     main()\n     {  int  a[3][4]={ 1,3,5,7,9,11,13,15,17,19,21,23}, (*p)[4]=a,i,j,k=0;\n        for( i=0; i<3; i++ )\n          for( j=0; j<2; j++ )  k=k+*(*(p+i)+j);\n        printf(\"%d\\n\", k );\n     }\n\n程序运行后的输出结果是\n', '108', '68', '99', '60', 'D', null, '27', '2018年3月二级《C语言》题库试题', null, '该题首先给二维数组赋值a[3][4]={{1,3,5,7}{9,11,13,15}{17,19,21,23}}；(*p)[4]=a指针p指向二维数组a的首地址，接下来执行for循环，首先 i=0，j=0时k=k+*（*（p+0）+0）=1（a[0][0]）；然后 i=0，j=1时k=k+*（*（p+0）+1）=4（a[0][1]）；然后j=2时，跳出j的循环，执行i的循环i=1，j=0 时k=k+*（*（p+1）+0）=13(a[1][0])；依次类推一直到i=3时跳出全部循环。循环语句在这里的功能是累加二维数组第1列和第2列的元素，累加结果为60。\n');
INSERT INTO `exercises` VALUES ('384', '有以下程序\n#include    <stdio.h>\n#include    <string.h>\nmain( )\n{  char  a[] = \"TEXT\", *b = \"++\", c[3] = \"1\";\n   printf(\"%d,%d,\", strlen(a), sizeof(a));\n   printf(\"%d,%d,\", strlen(b), sizeof(b));\n   printf(\"%d,%d,\\n\", strlen(c), sizeof(c));\n}\n程序运行后的输出结果是（）。\n', '4,5,2,4,1,3,', '4,4,2,2,1,1,', '5,5,3,3,2,2,', '4,4,2,2,1,3', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, 'sizeof(　)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。strlen(*char)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL，返回的长度大小不包括NULL。sizeof(a)求数组a所占空间的大小，包括字符串最后的＇\\0＇，所以sizeof(a)=5，strlen()遇到＇\\0＇就结束，strlen(a)=4。strlen(b)是指针指向的字符串长度，sizeof(b)是指针的大小。strlen(c)是字符串的长度,sizeof(c)是数组的长度。因此，输出4,5,2,4,1,3。故答案为A选项\n');
INSERT INTO `exercises` VALUES ('385', '有以下程序\n#include   <stdio.h>\n#include   <string.h>\nmain( )\n{ char  a[20]=\"ab\",b[20]=\"cdef\";\n  int  k=0;\n  strcat(a,b);\n  while(a[k]!=\'\\0\') { b[k]=a[k]; k++;}\n  puts(b);\n}\n程序的运行结果是（）。\n', 'abcdef', 'cbcdef', 'cdef', 'ab', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, 'strcat(字符串1， 字符串2)函数是把字符串2连接到字符串1的后面，最终结果存放到字符组1中，因此本题把a,b字符串连接起来放在a数组中，while语句完成功能是再将a字符串赋给b字符串，因此答案为A选项。\n');
INSERT INTO `exercises` VALUES ('386', '以下叙述中正确的是（）。\n', '函数名允许用数字开头', '函数调用时，不必区分函数名称的大小写', '调用函数时，函数名必须与被调用的函数名完全一致', '在函数体中只能出现一次return语句', 'C', null, '27', '2018年3月二级《C语言》题库试题', null, 'B选项中，函数调用时，函数名称是需要区分大小写的；A选项中，函数名不允许以数字开头；D选项中，在函数中允许有多个return语句，但每次调用只能有一个return 语句被执行。因此C选项正确。\n');
INSERT INTO `exercises` VALUES ('387', '有以下程序\n    #include <stdio.h>\n    int f(int x);\n    main()\n    { int n=1,m;\n      m=f(f(f(n))); printf(\"%d\\n\",m);\n    }\n    int f(int x)\n    { return x*2; }\n程序运行后的输出结果是（）。\n', '4', '2', '8', '1', 'C', null, '27', '2018年3月二级《C语言》题库试题', null, 'B选项中，函数调用时，函数名称是需要区分大小写的；A选项中，函数名不允许以数字开头；D选项中，在函数中允许有多个return语句，但每次调用只能有一个return 语句被执行。因此C选项正确。\n');
INSERT INTO `exercises` VALUES ('388', '有以下程序\n#include <stdio.h>\nint  d=1;\nvoid  fun( int  p )\n{  \n    int  d=5;\n    d += p++;\n    printf(\"%d  \", d );\n}\nmain()\n{  \n    int  a=3;\n    fun( a );\n    d += a++;\n    printf(\"%d\\n\",d);\n}\n程序的输出结果是（）。\n', '8  4', '9  6', '9  4', '8  5', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, '本题主要考查局部变量和全局变量的区别，题目中函数之外定义的d为全局变量，函数fun内定义的d为局部变量，所以执行fun函数后，打印出8，执行完d += a++;后d变为4，所以答案为A。\n\n');
INSERT INTO `exercises` VALUES ('389', '函数fun的功能是在a所指的具有n个元素的数组中查找最大值并返回给调用函数，函数不完整。\nint  fun(int  *a,int  n)\n{  int  *p,*s;\n   for( p=a,s=a; p-a<n;p++ )\n   if(__________)  s=p;\n   return  *s;\n}\n在if语句下划线处应填入的选项是（）。\n', 'p>s', '*p>*s', 'a[p]>a[s]', 'p-a>p-s', 'B', null, '27', '2018年3月二级《C语言》题库试题', null, '函数fun的功能是在a所指的具有n个元素的数组中查找最大值并返回。通过for比较，s始终指向最大值的那个元素。取指针的值，使用*p，因此比较使用*p和*s，又因为找最大值，当*s<*p时，修改指针s的指向，因此答案为B选项\n');
INSERT INTO `exercises` VALUES ('390', '设有以下函数：\n    void fun(int n,char *s)\n    {  ……  }\n则下面对函数指针的定义和赋值均正确的是（）。\n', 'void (*pf)(int,char);     pf=&fun;', 'void  *pf();      pf=fun;', 'void  *pf();     *pf=fun;', 'void  (*pf)(int, char*);    pf=fun;', 'D', null, '27', '2018年3月二级《C语言》题库试题', null, '函数的参数可以是指针类型。它的作用是将一个变量的地址传送到另一个函数中。函数名代表函数的入口地址，指向函数的指针应该定义为void (*pf)()。如果定义为void *pf()，则表示函数pf返回值为一个基类型为void的指针。因此D选项正确。\n');
INSERT INTO `exercises` VALUES ('391', '有以下程序\n     #include <stdio.h>\n     #define  SUB( X, Y )   (X+1)*Y\n     main()\n     {  int  a=3, b=4;\n        printf(\"%d\\n\",SUB(a++ ,b++ )); \n     }\n程序运行后的输出结果是（）。\n', '25', '20', '12', '16', 'D', null, '27', '2018年3月二级《C语言》题库试题', null, '本题考查宏定义，宏定义只是做个简单的替换，执行SUB(a++ ,b++)=(a++ +1)*b++=16,选项D正确。\n');
INSERT INTO `exercises` VALUES ('392', '若有定义\n    typedef  int  *T;\n    T  a[20];\n则以下与上述定义中a类型完全相同的是（）。\n', 'int  *a[20];', 'int  (*a)[20];', 'int  a[20];', 'int  **a[20];', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, '“typedef　类型名　新类型名”表示为一个已有定义的类型标识符重新定义一个类型名，题中选项A代表的意思是数组指针，即指向数组的指针，B选项是指针数组，即数组存放的元素是整型指针，首先为整型指针类型命名为T，再通过T定义了一个整形指针数组*a[20]，等价于int *a[20]，答案为A选项。\n');
INSERT INTO `exercises` VALUES ('393', '为了建立如图所示的存储结构（即每个结点含两个域，data是数据域，next是指向结点的指针域）则在（）处填入的选项是（   ）。\n  struct link{ char data;（）}node;\n	\n   data next \n', 'struct link *next;', 'link next;', 'link *next;', 'struct link next;', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, '存储结构用链式存储。链式结构每个节点有个指针域，指针域指向下一个链式结构的节点，因此指针域的结构应该是该结构形式，因此应定义为struct link* next,故答案为A选项。struct是结构体的说明符，不能省略\n');
INSERT INTO `exercises` VALUES ('394', '有以下程序段\n      FILE *fp;\n      if( (fp=fopen(\"test.txt\"，\"w\")) == NULL)\n        {   printf(\"不能打开文件！\");\n            exit(0);}\n      else\n           printf(\"成功打开文件！\");\n  若指定文件test.txt不存在，且无其他异常，则以下叙述错误的是\n', '输出\"不能打开文件！\"', '输出\"成功打开文件！\"', '系统将按指定文件名新建文件', '系统将为写操作建立文本文件', 'A', null, '27', '2018年3月二级《C语言》题库试题', null, 'fopen函数以一定方式打开指定文件，返回一个指向文件的文件指针，如果不能实现打开指定文件的操作，则返回一个空指针NULL。如果指定文件不存在则创建一个文件名为指定文件名的新文件，然后打开它。在指定文件有错误或者指定文件不存在却不能创建新文件的情况下，打开文件操作错误，返回空指针。本题程序中，文件test.txt不存在，但无其他异常，表示可以建立新文件，命名为test.txt，C选项叙述正确，并以只写方式打开它，D选项叙述正确，返回指向文件的指针，if条件不成立，输出“成功打开文件！”，B选项叙述正确，A选项叙述错误。所以选择A选项。\n');
INSERT INTO `exercises` VALUES ('396', '设栈的顺序存储空间为S(0:49)，栈底指针bottom=49，栈顶指针top=30（指向栈顶元素）。则栈中的元素个数为\n', '30', '29', '20', '19', 'C', null, '32', '2018年3月二级《C语言》题库试题', null, '栈是一种特殊的线性表，它所有的插入与删除都限定在表的同一端进行。入栈运算即在栈顶位置插入一个新元素，退栈运算即是取出栈顶元素赋予指定变量。元素依次存储在单元30：49中，个数为\n \n');
INSERT INTO `exercises` VALUES ('397', '下列叙述中错误的是\n', '在双向链表中，可以从任何一个结点开始直接遍历到所有结点', '在循环链表中，可以从任何一个结点开始直接遍历到所有结点', '在线性单链表中，可以从任何一个结点开始直接遍历到所有结点', '在二叉链表中，可以从根结点开始遍历到所有结点', 'C', null, '32', '2018年3月二级《C语言》题库试题', null, '线性单链表就是指线性表的链式存储结构，这种结构只能从一个节点遍历到其后的所有节点，故C选项叙述错误；在单链表的第一个节点前增加一个表头节点，队头指针指向表头节点，所以可以从任何一个节点开始直接遍历到所有节点，最后一个节点的指针域的值由NULL改为指向表头节点，这样的链表称为循环链表；双向链表是指链表节点含有指向前一个节点的指针和指向后一个节点的指针，所以可以从任何一个节点开始直接遍历到所有节点；二叉树链表中节点指针由父节点指向子节点，可以从根节点开始遍历到所有节点，所以选项A、B、D叙述均正确。\n');
INSERT INTO `exercises` VALUES ('398', '某棵树只有度为3的结点和叶子结点，其中度为3的结点有8个，则该树中的叶子结点数为\n', '15', '16', '17', '不存在这样的树', 'C', null, '32', '2018年3月二级《C语言》题库试题', null, '树是一种简单的非线性结构，直观地来看，树是以分支关系定义的层次结构。在树结构中，一个结点所拥有的后件个数称为该结点的度，所有结点中最大的度称为树的度。\n由于只有度为3的结点和叶子结点，可知最后一层都为叶子结点，倒数第二层一部分结点度为3，一部分为叶子结点，其余的结点的度均为3，计算度为3的结点总数(33-1-1)/2<8<(34-1-1)/2可知，树共有4层，前两层有度为3的结点(33-1-1)/2=4个，第三层有33=9个结点，其中4个是度为3的结点，5个是叶子结点，所以该树中的叶子结点数为4×3+5=17。\n故选C选项\n');
INSERT INTO `exercises` VALUES ('399', '某二叉树的前序序列为ABCDEFG，中序序列为DCBAEFG，则该二叉树的深度（根结点在第1层）为\n', '2', '3', '4', '5', 'C', null, '32', '2018年3月二级《C语言》题库试题', null, '深度，定义一棵树的根节点所在的层次为１，其他节点所在的层次等于它的父节点所在的层次加１，树的最大层次称为树的深度。二叉树遍历可以分为3种：前序遍历（访问根节点再访问左子树和访问右子树之前）、中序遍历（访问根节点在访问左子树和访问右子树两者之间）、后序遍历（访问根节点在访问左子树和访问右子树之后）。二叉树的前序序列为ABCDEFG，A为根节点。中序序列为DCBAEFG，可知DCB为左子树节点，EFG为右子树节点。同理B为C父节点,C为D父节点。同理E为F根节点，F为G根节点。故二叉树深度为4层。C选项正确。\n');
INSERT INTO `exercises` VALUES ('400', '在长度为n的有序线性表中进行二分查找，最坏情况下需要比较的次数是(　　)。\n', 'O(n)', 'O(n2)', '', '', 'C', null, '32', '2018年3月二级《C语言》题库试题', null, '当有序线性表为顺序存储时才能用二分法查找。可以证明的是对于长度为n的有序线性表，在最坏情况下，二分法查找只需要比较 次，而顺序查找需要比较n次。\n');
INSERT INTO `exercises` VALUES ('401', '在最坏情况下\n', '快速排序的时间复杂度比冒泡排序的时间复杂度要小', '快速排序的时间复杂度比希尔排序的时间复杂度要小', '希尔排序的时间复杂度比直接插入排序的时间复杂度要小', '快速排序的时间复杂度与希尔排序的时间复杂度是一样的', 'C', null, '32', '2018年3月二级《C语言》题库试题', null, '对长度为n的线性表排序，下表为常用排序方法时间复杂度：\n方法	平均时间	最坏情况时间\n冒泡排序	O(n2)	O(n2)\n直接插入排序	O(n2)	O(n2)\n简单选择排序	O(n2)	O(n2)\n快速排序	O(nlog2n)	O(n2)\n堆排序	O(nlog2n)	O(nlog2n)\n上表中未包括希尔排序，因为希尔排序的时间效率与所取的增量序列有关，如果增量序列为：d1=n/2, di+1=di/2，在最坏情况下，希尔排序所需要的比较次数为O(n1.5)。快速排序与冒泡排序的时间复杂度均为O(n2)，A选项错误。快速排序比希尔排序的时间复杂度要大（O(n2)>O(n1.5))，B选项错误。希尔排序的时间复杂度比直接插入排序的时间复杂度要小（O(n1.5)<O(n2))，C选项正确。快速排序比希尔排序的时间复杂度大（O(n2)>O(n1.5))，D选项错误。\n');
INSERT INTO `exercises` VALUES ('402', '软件设计中模块划分应遵循的准则是(　　)。\n', '低内聚低耦合', '高内聚低耦合', '低内聚高耦合', '高内聚高耦合', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, '软件设计中模块划分应遵循的准则是高内聚低偶合、模块大小规模适当、模块的依赖关系适当等。模块的划分应遵循一定的要求，以保证模块划分合理，并进一步保证以此为依据开发出的软件系统可靠性强，易于理解和维护。模块之间的耦合应尽可能的低，模块的内聚度应尽可能的高。 \n');
INSERT INTO `exercises` VALUES ('403', '下面属于白盒测试方法的是\n', '等价类划分法', '逻辑覆盖', '边界值分析法', '错误推测法', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, '白盒测试法主要有逻辑覆盖、基本路径测试等。逻辑覆盖测试包括语句覆盖、路径覆盖、判定覆盖、条件覆盖、判断-条件覆盖，选择B。其余为黑盒测试法。\n');
INSERT INTO `exercises` VALUES ('404', '有三个关系表R、S和T如下，其中三个关系对应的关键字分别为A，B和复合关键字（A，B）。\n \n表T的记录项（b,q,4）违反了\n', '实体完整性约束', '参照完整性约束', '用户定义的完整性约束', '关系完整性约束', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, '关系模型中可以有3类完整性约束：实体完整性约束、参照完整性约束和用户定义的完整性约束。实体完整性约束是指，若属性Ｍ是关系的主键，则属性Ｍ中的属性值不能为空值。T中主键不为空，A选项错误。参照完整性约束是指，若属性（或属性组）A是关系M的外键，它与关系M的主码相对应，则对于关系M中的每个元组在A上的值必须为：要么取空值；要么等于关系M中某个元组的主码值。属性B为关系S的外键，它与关系S的主键相对应，则T中元组在B上应该为空或者与S中主键值相等，题目中不相等，违反参照完整性约束，B选项正确。此题关系中无语义要求，C选项错误。\n');
INSERT INTO `exercises` VALUES ('405', '学生选课成绩表的关系模式是SC(S#,C#,G)，其中S#为学号，C#为课号，G为成绩，检索课号为2且成绩及格的学生学号的表达式为\n', '', '', '', '', 'A', null, '32', '2018年3月二级《C语言》题库试题', null, '关系模型中可以有3类完整性约束：实体完整性约束、参照完整性约束和用户定义的完整性约束。实体完整性约束是指，若属性Ｍ是关系的主键，则属性Ｍ中的属性值不能为空值。T中主键不为空，A选项错误。参照完整性约束是指，若属性（或属性组）A是关系M的外键，它与关系M的主码相对应，则对于关系M中的每个元组在A上的值必须为：要么取空值；要么等于关系M中某个元组的主码值。属性B为关系S的外键，它与关系S的主键相对应，则T中元组在B上应该为空或者与S中主键值相等，题目中不相等，违反参照完整性约束，B选项正确。此题关系中无语义要求，C选项错误。\n');
INSERT INTO `exercises` VALUES ('406', '以下叙述正确的是（）。\n', '计算机只接收由0和1代码组成的二进制指令或数据', '计算机只接收由0和1代码组成的十进制指令或数据', '计算机可直接接收并运行C源程序', '计算机可直接接收并运行任意高级语言编写的源程序', 'A', null, '32', '2018年3月二级《C语言》题库试题', null, '计算机认识自己的母语--机器语言,即0和1代码组成的二进制指令或数据，故A选项正确，B选项错误。C语言是一种高级语言,计算机不能直接运行C源程序和高级语言编写的源程序，C和D选项错误。\n');
INSERT INTO `exercises` VALUES ('407', '在源程序的开始处加上\n        #include   <stdio.h>\n进行文件引用的原因，以下叙述正确的是（）。\n', 'stdio.h文件中包含标准输入输出函数的函数说明，通过引用此文件以便能正确使用printf、scanf等函数', '将stdio.h中标准输入输出函数链接到编译生成的可执行文件中，以便能正确运行', '将stdio.h中标准输入输出函数的源程序插入到引用处，以便进行编译链接', '将stdio.h中标准输入输出函数的源程序插入到引用处，以便进行编译链接', 'A', null, '32', '2018年3月二级《C语言》题库试题', null, 'stdio.h文件中包含标准输入输出函数的函数说明，预处理指令#include<stdio.h>是使程序可以去该文件中找到printf,scanf等函数以便使用，因此答案为A选项。\n');
INSERT INTO `exercises` VALUES ('408', '有以下程序\n#include <stdio.h>\nmain()\n{\n   printf(\"%d\\n\", NULL );\n}\n程序运行后的输出结果是（）。\n', '0', '变量无定义，输出不确定', '-1', '1', 'A', null, '32', '2018年3月二级《C语言》题库试题', null, 'NULL是在stdio.h头文件中定义的预定义符，NULL的代码值为0，如果以整型格式输出则输出0。A选项正确。\n');
INSERT INTO `exercises` VALUES ('409', '有如下程序\n#include <stdio.h>\n#include <string.h>\nmain() \n{\n    printf(\"%d\\n\", strlen(\"0\\n011\\1\"));\n}\n程序运行后的输出结果是\n', '6', '8', '9', '4', 'A', null, '32', '2018年3月二级《C语言》题库试题', null, '由一对双引号括起来的一串字符为字符串。字符常量是用一对单引号括起来的单个字符，还有一些特殊字符常量，即以“\\”开头的转义字符。“\\”后可以为某些单个字符也可以为八进制或十六进制数字。strlen函数统计字符串长度，遇到“\\0”统计结束。‘0’‘\\n’‘0’‘1’‘1’‘\\1’共6个字符，A选项正确。\n');
INSERT INTO `exercises` VALUES ('410', '以下非法的定义语句是（）。\n', 'long b=0L;', 'unsigned int a= -100u;', 'short c2=0123;', 'int d=0x0;', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, 'unsigned定义的是\"无符号数\"，则B选项定义错误，答案为B选项。\n');
INSERT INTO `exercises` VALUES ('411', '不能正确表示数学式 的表达式是\n', 'a/c*b', 'a*b/c', 'a/ b* c', 'a*(b/c)', 'C', null, '32', '2018年3月二级《C语言》题库试题', null, '/号和*号的优先级处于平级,结合性都是自左至右?所以选择C,C式子表示的是 ?\n');
INSERT INTO `exercises` VALUES ('412', '有以下程序\n    #include <stdio.h>\n    main()\n    {\n        int a=2, c=5;     \n        printf( \"a=%%d,b=%%d\\n\", a,c );\n    }\n\n程序的输出结果是（）。\n', 'a=2,b=5', 'a=%2,b=%5', 'a=%d,b=%d', 'a=%%d,b=%%d', 'C', null, '32', '2018年3月二级《C语言》题库试题', null, 'C语言中用\"%%\"打印输出字符\"%\",所以%%d,输出为%d两个普通字符,而不是格式控制符\"%d\"的含义,所以打印结果为C?\n');
INSERT INTO `exercises` VALUES ('413', '以下选项中错误的是（）。\n', 'a&=b  与  a=a&b  等价', 'a^=b  与  a=a^b  等价', 'a|=b  与  a=a|b  等价', 'a!^=b  与  a=a!^b  等价', 'D', null, '32', '2018年3月二级《C语言》题库试题', null, 'D选项中，a!=b表示a不等于b时，运算结果为1，或者为0；而a=a!b是一种语法错误，!是非运算，且是单目运算符，只要求有一个操作数，故两者不等价，答案为D选项。\n');
INSERT INTO `exercises` VALUES ('414', '有以下程序段：\n  #include  <stdio.h>\n  int   a,b,c;\n  a=10; b=50;c=30;\n  if (a>b) a=b,b=c; c=a;\n  printf(\"a=%d b=%d c=%d\\n\", a,b,c)；\n程序的输出结果是(　　)。\n', 'a=10 b=50 c=30', 'a=10 b=50 c=10', 'a=10 b=30 c=10', 'a=50 b=30 c=50', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, '本题中a>b的条件不满足，所以不执行逗号表达式a=b，b=c；的操作，而是执行c=a操作，即c的值为10。\n');
INSERT INTO `exercises` VALUES ('415', ' 有如下嵌套的if语句\n    if(a<b)\n        if(a<c) k=a;\n        else  k=c;\n    else\n        if(b<c) k=b;\n        else  k=c;\n\n以下选项中与上述if语句等价的语句是\n', 'k=(a<b)?((b<c)?a:b):((b>c)?b:c);', 'k=(a<b)?((a<c)?a:c):((b<c)?b:c);', 'k=(a<b)?a:b;k=(b<c)?b:c;', 'k=(a<b)?a:b;k=(a<c)?a:c;', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, '题目中嵌套语句的含义是当a<b且a<c成立,则将a的值赋给k,如果a<b成立而a<c不成立将c的值赋给k?如果a<b不成立而b<c成立,将b的值赋给k,如果如果a<b不成立且b<c也不成立,将c的值赋给k?判断条件表达式只有B选项可以表示这个含义?\n');
INSERT INTO `exercises` VALUES ('416', ' 有以下程序段：\n#include  <stdio.h>\nint  i， n；\nfor( i＝0； i<8； i＋＋ )\n{　　n ＝ rand() % 5；\n　　switch (n)\n　　{　case 1：\ncase 3：  printf(\"%d \\n\"， n)；  break；\ncase 2：\ncase 4：  printf(\"%d \\n\"， n)；  continue；\ncase 0：  exit(0)；\n　　}\n　　printf(\"%d \\n\"，n)；\n}\n以下关于程序段执行情况的叙述，正确的是(　　)。\n', 'for循环语句固定执行8次', '当产生的随机数n为4时结束循环操作', '当产生的随机数n为1和2时不做任何操作', '当产生的随机数n为0时结束程序运行', 'D', null, '32', '2018年3月二级《C语言》题库试题', null, 'case常量表达式只是起语句标号作用，并不是该处进行条件判断。在执行switch语句时，根据switch的表达式，找到与之匹配的case语句，就从此case子句执行下去，不再进行判断，直到碰到break或函数结束为止。简单的说break是结束整个循环体，而continue是结束单次循环。B)选项中当产生的随机数n为4时要执行打印操作。C)选项中当产生的随机数为1和2时分别执行case3与case4后面语句的内容。由于存在break语句所以for循环不是固定执行8次，执行次数与产生的随机数n有关系。\n');
INSERT INTO `exercises` VALUES ('417', ' 有如下程序\n#include <stdio.h>\nmain() \n{\n    int i, *ptr;\n    int array[3] = {8,2,4};\n    for (ptr=array, i=0; i<2; i++)\n        printf(\"%d,\", *ptr++);\n    printf(\"\\n\");\n}\n程序运行后的输出结果是()。\n', '8,2,', '8,8,', '2,4,', '4,8,', 'A', null, '32', '2018年3月二级《C语言》题库试题', null, '程序执行过程为：定义指针ptr与数组array，执行for循环，使指针指向数组，i=0，输出指针指向的元素array[0]=8，然后指针加1，指向数组下一个元素；i=1，输出array[1]=2，指针指向数组下一个元素；i=2退出for循环。程序依次输出8,2，A选项正确。\n');
INSERT INTO `exercises` VALUES ('418', '有以下程序\n    #include <stdio.h>\n    main()\n    { \n        int  i, j, x=0;\n        for(i=0; i<2; i++)\n        {  \n            x++;\n            for( j=0; j<=3; j++)\n            {  \n                if(j%2)  continue;\n                x++;\n            }\n            x++;\n        }\n        printf(\"x=%d\\n\",x);\n    }\n程序执行后的输出结果是\n', 'x=4', 'x=8', 'x=6', 'x=12', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, 'coutinue的作用是跳出循环体中剩余的语句而进行下一次循环?第一次执行外循环i的值为0,执行x++,x的值变为1,第一次执行内层循环j的值为0,不满足if条件,执行x++,x的值变为2,第二次内循环j的值为1,if条件成立,跳出本次循环,第三次执行内循环j的值为2,不满足if条件,x的值变为3,第四次执行内循环j的值为3满足条件跳出本次内循环,x的值加1,即为4,第一次外循环结束?第二次执行外循环时,同理,i的值被加了,4次,变为8,所以选择B选项?\n');
INSERT INTO `exercises` VALUES ('419', '设有如下程序段\nint  a[1] = {0};\nint  b[] = {9};\nchar  c[3] = {\"A\", \"B\"}; \nchar  d = \"12\"; \n以下叙述正确的是（）。\n', 'a, b的定义合法，c, d的定义不合法', 'a,b,c,d的定义都是合法的', 'a,b,c的定义是合法的，d的定义不合法', '只有a的定义是合法的', 'A', null, '32', '2018年3月二级《C语言》题库试题', null, 'int a[1]={0}表示定义一个数组a[1]初值为0，int  b[] = {9}，表示定义一个数组b，其中只有一个值9，系统自动识别数组有1个元素。char  c[3] = {\"A\", \"B\"}，数组元素为字符串，需要用二维数组来表示，C选项错误; char  d = \"12\";，字符串常量不能赋值给字符变量，D选项错误;因此答案为A选项。\n');
INSERT INTO `exercises` VALUES ('420', '设有定义\n    double  a[10] ,*s=a;\n以下能够代表数组元素a[3]的是（）。\n', '(*s)[3]', '*(s+3)', '*s[3]', '*s+3', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, '指针的赋值首先基类型必须一致，s二维数组名，是二维数组的首地址，其基类型是一个具有10个元素的字符数组。p是一个字符指针变量，其基类型是一个字符，k是一个行指针，其基类型是具有3个元素的字符型数组。所以A、C、D中两项的基类型不一致。而B选项，s[0]是二维数组s的第一个元素，其代表第一行元素构成的数组的首地址，其相当于一维数组的数组名，其基类型是一个字符类型，和p基类型一致。因此B选项正确。\n');
INSERT INTO `exercises` VALUES ('421', '#include <stdio.h>\n#define N 4\nvoid fun(int a[][N])\n{  \n  int i;\n  for(i=0; i<N; i++) \n     a[0][i] += a[N-1][N-1-i];\n}\nmain( )\n{  int x[N][N]={ {1, 2, 3, 4}, \n                 {5, 6, 7, 8}, \n                 {9,10,11,12},\n                 {13,14,15,16}}, i;\n   fun(x);\n   for (i=0;i<N; i++) printf(\"%d,\", x[i][i]);\n   printf(\"\\n\");\n}\n\n程序运行后的输出结果是（）。\n', '4,7,10,13,', '1,6,11,16,', '17,6,11,16,', '5,13,21,29,', 'C', null, '32', '2018年3月二级《C语言》题库试题', null, 'N=4，for(i=0,i<N,i++) printf(x[i][j]);此语句输出x[0][0], x[1][1]，x[2][2]，x[3][3]，其中只有x[0][0]的值在fun函数中发生改变，在fun函数中，当i=0时，x[0][0]= x[0][0]+x[3][3]=17，程序运行后的输出结果是：17.6.11.16。因此答案为C选项。\n');
INSERT INTO `exercises` VALUES ('422', '有以下程序\n#include <stdio.h>\nmain()\n{  \n    char  ch[ ] =\"uvwxyz\",*pc;\n    pc=ch;\n    printf(\"%c\\n\", *(pc+5));\n}\n程序运行后的输出结果是（）。\n', 'z', '0', '元素ch[5]的地址', '字符y的地址', 'A', null, '32', '2018年3月二级《C语言》题库试题', null, '语句pc=ch；使得指针变量指向字符数组ch的首地址，即指向字符\'u\'。则pc+5指向的是字符向后移动5位，指向字符\'z\'。所以输出的*pc+5的值即为\'z\'。因此A选项正确。\n');
INSERT INTO `exercises` VALUES ('423', '有以下程序\n     #include <stdio.h>\n     #include <string.h>\n     void  fun (char  *w, int  m )\n     {  char  s, *p1, *p2;\n        p1=w;    p2=w+m-1;\n        while ( p1<p2 )\n           {\n              s=*p1;  *p1=*p2;  *p2=s;\n              p1++;  p2--;\n           }\n     }\n     main()\n     {  char  a[ ]=\"123456\";\n        fun ( a, strlen(a) );    puts(a);\n     }\n\n程序运行后的输出结果是（）。\n', '123456', '116611', '161616', '654321', 'D', null, '32', '2018年3月二级《C语言》题库试题', null, '主函数中调用fun(a,6)后，指针p1指向字符串中的\"1\"、p2指向字符串中的\"6\"。While循环中，只要p1<p2，则把p1、p2所指向的字符互换，同时p1前移，p2后移。最终字符串逆序存放。因此D选项正确。\n');
INSERT INTO `exercises` VALUES ('424', '若有以下程序\n     #include <stdio.h>\n     main()\n     {  char  a[20], b[ ]=\"The sky is blue.\";  int i;\n        for (i=0; i<10; i++)  scanf(\"%c\", &a[i]);\n        a[i]=\'\\0\';\n        gets(b);\n        printf(\"%s%s\\n\", a,b);\n     }\n\n执行时若输入：\nFig flower is red. <回车>\n则输出结果是（）。\n', 'Fig flower is red.is blue.', 'Fig flower is red.', 'Fig floweris red.', 'Fig floweris', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, '本题考查字符数组的赋值以及字符串的处理函数,本题中输入字符串Fig flower is red时,首先是将前10个字符赋值给字符数组a,然后执行gets(b)后,将后续字符存放到b中,当输出时,首先输出字符数组a,然后输出字符串b,所以结果为B选项?\n');
INSERT INTO `exercises` VALUES ('425', '有以下程序\n     #include <stdio.h>\n     main()\n     {  char  s[]=\"012xy\\08s34f4w2\";\n        int  i, n=0;\n        for ( i=0; s[i]!=0; i++ )\n           if(s[i] >= \'0\' && s[i] <= \'9\')  n++;\n        printf(\"%d\\n\",n);\n     }\n程序运行后的输出结果是（）。\n', '7', '0', '3', '8', 'C', null, '32', '2018年3月二级《C语言》题库试题', null, '题意统计字符s中阿拉伯数字的个数。char s[]=＇012xy\\08s34f4w2＇;元素是字符型。＇0＇=48；而＇\\0＇=0;因此可以计算出＇\\0＇之前阿拉伯数字的个数，由字符串s可知，有3个阿拉伯数字。答案为C选项。\n');
INSERT INTO `exercises` VALUES ('426', '若有定义语句：\n    char  *s1=\"OK\", *s2=\"ok\";\n以下选项中，能够输出\"OK\"的语句是（）。\n', 'if (strcmp(s1,s2)!=0)  puts(s2);', 'if (strcmp(s1,s2)!=0)  puts(s1);', 'if (strcmp(s1,s2)==1)  puts(s1);', 'if ( strcmp(s1,s2)==0)  puts(s1);', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, 'strcmp(s1,s2)是字符串比较函数，比较规则是两个字符串自左向右逐个字符相比（按照ASCII码值大小），以第一个不相同的字符的大小作为比较结果。因为\'OK\'<\'ok\'，所以strcmp(s1,s2)为负值，只有B选项正确。\n\n');
INSERT INTO `exercises` VALUES ('427', '以下关于return语句的叙述中正确的是（）。\n', '一个自定义函数中必须有一条return语句', '一个自定义函数中可以根据不同情况设置多条return语句', '定义成void类型的函数中可以有带返回值的return语句', '没有return语句的自定义函数在执行结束时不能返回到调用处', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, '在函数中允许有多个return语句，但每次调用只能有一个return 语句被执行，因此只能返回一个函数值，A选项描述错误。定义成void类型的函数，不允许从该函数取得返回值，也不允许使用return语句，C选项描述错误。没有return语句的函数在执行到函数的最后一条语句后会自动返回到调用处，D选项描述错误。因此B选项正确。\n');
INSERT INTO `exercises` VALUES ('428', '若有以下程序\n     #include <stdio.h>\n     int  *f(int  *s, int  *t)\n     {  int  k;\n        if (*s < *t)  { k = *s;  *s=*t;  *t=k; }\n        return s;\n     }\n     main()\n     {  int  i=3, j=5, *p=&i, *q=&j, *r;  \n        r=f(p,q);\n        printf(\"%d,%d,%d,%d,%d\\n\", i, j, *p, *q, *r); \n     }\n\n则程序的输出结果是（）。\n', '5,3,3,5,5', '3,5,5,3,5', '3,5,3,5,5', '5,3,5,3,5', 'D', null, '32', '2018年3月二级《C语言》题库试题', null, '在主函数中分别给整型变量i、j和指针型变量p、q赋初值，并声明指针变量r；调用f函数，并将实参变量p和q的值传递给形参变量s和t，并且f函数是指针型函数，即函数的返回值将是一个地址。在f函数中，如果条件成立，则将指针变量s和t的值互换，并且将指针s的地址返回主函数。最后输出i, j, *p, *q, *r的值，即5,3,5,3,5。因此D选项正确。\n');
INSERT INTO `exercises` VALUES ('429', '有以下程序\n#include  <stdio.h>\nint  m=12;\nint  fun( int  x,int  y )\n{  static int  m=3;\n   m= x * y - m ;\n   return (m);\n}\nmain()\n{   int   a=7, b=5;\n    m=fun( a, b )/m;\n    printf(\"%d\\n\", fun( a, b )/m );\n}\n程序运行后的输出结果是（）。\n', '2', '1', '3', '0', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, '在主函数中分别给整型变量i、j和指针型变量p、q赋初值，并声明指针变量r；调用f函数，并将实参变量p和q的值传递给形参变量s和t，并且f函数是指针型函数，即函数的返回值将是一个地址。在f函数中，如果条件成立，则将指针变量s和t的值互换，并且将指针s的地址返回主函数。最后输出i, j, *p, *q, *r的值，即5,3,5,3,5。因此D选项正确。\n');
INSERT INTO `exercises` VALUES ('430', '若有以下程序\n     #include <stdio.h>\n     int  f(int  a[], int  n)\n     {  if (n > 1) \n        {  int  t;\n           t=f(a, n-1);\n           return  t > a[n-1]  ?  t : a[n-1];\n        }\n        else\n           return a[0];\n     }\n     main()\n     {  int  a[] = {8,2,9,1,3,6,4,7,5};\n        printf(\"%d\\n\", f(a, 9));\n     }\n\n则程序的输出结果是（）。\n', '9', '1', '8', '5', 'A', null, '32', '2018年3月二级《C语言》题库试题', null, '本题主要考查了函数的递归调用，解题思路只需要将参数带入函数中，首先是执行f(a, 9)，递归执行(a, 8)直到(a, 2)，得到a[0]=8，然后判断a[0]是否大于a[1]，本题实际上就是求出数组a元素的最大值。答案为9，选项A正确。\n');
INSERT INTO `exercises` VALUES ('431', '以下叙述正确的是（）。\n', '表达式 sizeof(FILE*) == sizeof(int*) 的值为真', '文件指针的值是一个整数，它的值一定小于文件字节数', '文件指针的值是所指文件的当前读取位置', '使用fscanf函数可以向任意类型的文件中写入任意数量的字符', 'A', null, '32', '2018年3月二级《C语言》题库试题', null, 'sizeof(FILE*)=4，因为file* 为指针，指针的大小4 ,sizeof(int*)=4,理由同前面。文件指针的值是地址，是一个16进制的数，它的值不一定小于文件字节数,因此选项B错误。文件指针是所指文件的当前读取位置，而不是文件指针的值因此选项C错误。intfscanf(FILE*stream,constchar*format,[argument...]);\nfscanf函数可以向任意类型的文件，写入任意数量不能超过系统的缓冲区，写文件先写入缓冲区，最后一起写入文件，因此选项D错误。答案为A选项\n');
INSERT INTO `exercises` VALUES ('432', '以下叙述中正确的是（）。\n', 'int* p1; int ** p2; int *p3;都是合法的定义指针变量的语句', '指针变量只能通过求地址运算符（&) 来获得地址值', '语句p=NULL;与p=\\0;是等价的语句', '语句p=NULL;执行后，指针p指向地址为0的存储单元', 'A', null, '32', '2018年3月二级《C语言》题库试题', null, 'B选项描述不正确，指针变量可以通过求地址运算符（&) 来获得地址值，可以通过指针变量获得地址值，还可以通过标准函数获得地址值；C选项中，p=NULL；和p=0；或p=\'\\0\'；等价；D选项中，语句p=NULL;执行后，指针p并不是指向地址为0的存储单元，而是具有一个确定的值-\"空\"。因此A选项正确。\n');
INSERT INTO `exercises` VALUES ('433', '有以下程序\n    #include <stdio.h>\n    #include <stdlib.h>\n    void fun(int *p1, int *s)\n    {  int *t;\n       t=(int *)malloc(2 * sizeof(int));\n       *t=*p1 + *p1++;\n       *(t+1)=*p1+ *p1;\n       s=t;\n    }\n    main()\n    {\n       int a[2]={1,2},b[2]={0};\n       fun(a,b);\n       printf(\"%d,%d\\n\",b[0],b[1]);\n    }\n程序运行后的输出结果是\n', '2,6', '0,0', '2,4', '1,2', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, 'malloc函数的原型为：malloc（size）;,函数的作用是在内存的动态存储区分配一个长度为size的连续空间。程序执行过程为：定义数组a={1,2},b={0,0},b，调用函数fun，将数组地址传入函数，指针p1指向a，s指向b，定义指针t并使其指向开辟的两个整型内存，为第一个内存赋值为数组a第一个元素的2倍，即2，然后指针p1指向a数组第二个元素，为第二个内存赋值为数组a第二个元素的2倍，即4，最后使指针s指向动态开辟的两个内存的首地址。整个过程中数组b没有发生变化，依次输出b中元素为0,0，B选项正确。\n');
INSERT INTO `exercises` VALUES ('434', '有以下程序\n    #include <stdio.h>\n    #define FNA(x)  x*x\n    #define FNB(x)  x+x\n    main()\n    {   int a=2,b=4;\n      printf(\"%d,%d\\n\",FNA(FNB(a)),FNB(FNA(b)));\n    }\n程序运行后的输出结果是（）。\n', '8,16', '16,32', '8,32', '16,16', 'C', null, '32', '2018年3月二级《C语言》题库试题', null, '带参数的宏定义不是进行简单的字符串替换，而是要进行参数替换。替换过程是：用宏调用提供的实参字符串，直接置换宏定义命令行中相应形参字符串，非形参字符保持不变。FNA(FNB(a))的替换过程为：FNA(2+2)替换为2+2*2+2，计算结果为8。FNB(FNA(b))的替换过程为：FNB(4*4)替换为4*4+4*4=32。程序运行后的输出结果是8,32，C选项正确。\n');
INSERT INTO `exercises` VALUES ('435', '若有以下程序\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\ntypedef struct stu {  \n    char  *name, gender;\n    int  score; \n} STU;\nvoid f(char  *p)\n{  \n    p=(char *)malloc(10);   \n    strcpy(p, \"Qian\");  \n}\nmain()\n{  \n    STU  a={NULL, \'m\', 290}, b;\n    a.name=(char *)malloc(10);\n    strcpy( a.name, \"Zhao\" );\n    b = a;\n    f(b.name);\n    b.gender = \'f\';   b.score = 350; \n    printf(\"%s,%c,%d,\", a.name, a.gender, a.score);\n    printf(\"%s,%c,%d\\n\", b.name, b.gender, b.score);\n}\n\n则程序的输出结果是（）。\n', 'Zhao,m,290,Qian,f,350', 'Zhao,m,290,Zhao,f,350', 'Qian,f,350,Qian,f,350', 'Qian,m,290,Qian,f,350', 'B', null, '32', '2018年3月二级《C语言》题库试题', null, '本题考查结构体变量中的引用，其中a的name为Zhao，b执行函数f(b.name)后b的name并没有改变，还是Zhao，所以答案为B选项。\n');
INSERT INTO `exercises` VALUES ('558', '下列叙述中错误的是\n', '在带链队列中，队头指针和队尾指针都是在动态变化的', '在带链栈中，栈顶指针和栈底指针都是在动态变化的', '在带链栈中，栈顶指针是在动态变化的，但栈底指针是不变的', '在带链队列中，队头指针和队尾指针可以指向同一个位置', 'B', null, '35', '2018年3月二级《C语言》模拟试题1', null, '带链的队列就是用一个单链表来表示队列，队列中的每一个元素对应链表中的一个节点，在入队和退队过程中，队头指针和队尾指针都是在动态变化的，A选项叙述正确，循环队列中当队列满或者空时，队头指针和队尾指针指向同一个位置，D选项叙述正确。栈也可以采用链式存储结构表示，把栈组织成一个单链表，这种数据结构可称为带链的栈，入栈和退栈过程中栈底指针不变，栈顶指针随之变化，B选项叙述错误，C选项叙述正确。故选择B选项。\n');
INSERT INTO `exercises` VALUES ('559', '某二叉树共有12个结点，其中叶子结点只有1个。则该二叉树的深度为（根结点在第1层）\n', '3', '6', '8', '12', 'D', null, '35', '2018年3月二级《C语言》模拟试题1', null, '二叉树中，度为0的节点数等于度为2的节点数加1，即n2=n0-1，叶子节点即度为0，n0=1，则n2=0，总节点数为12=n0+n1+n2=1+n1+0，则度为1的节点数n1=11，故深度为12，选D。\n');
INSERT INTO `exercises` VALUES ('561', '对长度为n的线性表作快速排序，在最坏情况下，比较次数为\n', 'n', 'n-1', 'n(n-1)', 'n(n-1)/2', 'D', null, '35', '2018年3月二级《C语言》模拟试题1', null, '快速排序最坏情况就是每次选的基准数都和其他数做过比较，共需比较(n-1)+(n-2)+…+1=n(n-1)/2，选D。\n');
INSERT INTO `exercises` VALUES ('562', '下列序列中不满足堆条件的是\n', '（98，95，93，96，89，85，76，64，55，49）', '（98，95，93，94，89，85，76，64，55，49）', '（98，95，93，94，89，90，76，64，55，49）', '（98，95，93，94，89，90，76，80，55，49）', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '快速排序最坏情况就是每次选的基准数都和其他数做过比较，共需比较(n-1)+(n-2)+…+1=n(n-1)/2，选D。\n');
INSERT INTO `exercises` VALUES ('563', '软件生命周期中，确定软件系统要做什么的阶段是\n', '需求分析', '软件测试', '软件设计', '系统维护', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '软件生命周期各阶段的主要任务是：问题定义、可行性研究与计划制定、需求分析、软件设计、软件实现、软件测试、运行维护。其中需求分析是指对待开发软件提出的需求进行分析并给出详细定义，也即是确定软件系统要做什么，A选项正确。\n');
INSERT INTO `exercises` VALUES ('564', '有两个关系R，S如下：\n由关系R通过运算得到关系S，则所使用的运算为(　　)。\n \n', '选择', '投影', '插入', '连接', 'B', null, '35', '2018年3月二级《C语言》模拟试题1', null, '投影运算是指对于关系内的域指定可引入新的运算。本题中S是在原有关系R的内部进行的，是由R中原有的那些域的列所组成的关系。所以选择B)。\n');
INSERT INTO `exercises` VALUES ('565', '有三个关系R、S和T如下：\n由关系R和S通过运算得到关系T，则所使用的运算为(　　)。\n \n', '并', '自然连接', '笛卡尔积', '交', 'D', null, '35', '2018年3月二级《C语言》模拟试题1', null, '自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉，所以B)错误。笛卡尔积是用R集合中元素为第一元素，S集合中元素为第二元素构成的有序对，所以C)错误。根据关系T可以很明显的看出是从关系R与关系S中取得相同的关系组所以取得是交运算，选择D)。\n');
INSERT INTO `exercises` VALUES ('566', '将E-R图转换为关系模式时，E-R图中的实体和联系都可以表示为（）。\n', '属性', '键', '关系', '域', 'C', null, '35', '2018年3月二级《C语言》模拟试题1', null, '采用E-R方法得到的全局概念模型是对信息世界的描述，并不适用于计算机处理，为了适合关系数据库系统的处理，必须将E-R图转换成关系模式。这就是逻辑设计的主内容。E-R图是由实体、属性和联系组成，而关系模式中只有一种元素--关系。C选项正确。\n');
INSERT INTO `exercises` VALUES ('567', '定义学生、教师和课程的关系模式STC(SNO，SN，SA，TN，CN，G)，其中的六个属性分别为学生的学号、姓名、年龄、教师的姓名、课程名以及学生的成绩，则该关系为\n', '第一范式', 'NF范式', '第三范式', 'BCNF范式', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '第一范式（1NF）无重复的列 \n    所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。 \n说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 \n第二范式（2NF）属性完全依赖于主键[消除部分子函数依赖] \n    第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。 \n    第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是属性完全依赖于主键。 \n第三范式（3NF）属性不依赖于其它非主属性[消除传递依赖]\n满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。\n');
INSERT INTO `exercises` VALUES ('568', '以下叙述错误的是\n', '在一个任务中，单独编写的每个模块均可以独立运行', '程序“模块化”有利于任务的分解简', '允许对函数单独进行编译，是C语言实现“模块化”的基础', '采用模块化结构，可以提高程序编制的效率', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, 'C语言中，程序运行必须从main函数开始，一个程序只能有一个main函数，所以除了包含main函数的模块，其他模块都不可以单独运行，选项A错误；程序的模块化将一个大的任务分解成若干个小的任务，每个模块解决一个小的任务，选项B正确；允许对函数单独进行编译，是模块化的基础，选项C正确；采用模块化结构，提高了代码的复用度，提高程序编制的效率，选项D正确；答案为A。\n');
INSERT INTO `exercises` VALUES ('569', '以下选项中，当且仅当x的绝对值在1至6范围内表达式值为“真”的是\n', '(x>=-6)&&(x<=-1)||(x>=1)&&(x<=6)', '(x>=1)&&(x<=6)&&(x>=-6)&&(x<=-1)', '(x>=-6)||(x<=-1)||(x>=1)||(x<=6)', '(x>=1)&&(x<=6)||(x>=-1)&&(x<=-6)', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '选项B中，x既要取值1~6，又要取值-6~-1，这是不可能的，所以选项B表达式的值始终为假，选项B错误；选项C无论x取何值，表达式的值始终为真；选项D中当x=-2时，表达式的值为假，选项D错误；选项A中，仅当x的绝对值在1~6内表达式的值才为真，选项A正确；\n');
INSERT INTO `exercises` VALUES ('570', '设有语句：printf(\"%2d\\n\",2010);，则以下叙述正确的是\n', '程序运行时输出2010', '程序运行时输出20', '程序运行时输出10', '指定的输出宽度不够，编译出错', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, 'printf()函数格式化字符串的一般形式为：[标志][输出最小宽度][.精度][长度]类型。对于%2d，%d表示结果以十进制形式输出带符号的整数，数字2表示输出的最小宽度为2，若实际位数多于2，则按实际位数输出，所以程序输出2010，答案选A。\n\n');
INSERT INTO `exercises` VALUES ('571', '以下选项中，合法的C语言实数是\n', '.4e0', '4.3e0.2', 'E4.8', '0.29E', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, 'C语言中，实数有两种形式，十进制小数形式和指数形式，由四个选项可知，本题考查的是实数的指数形式，指数形式一般为： aEn，其中a为十进制数，n为十进制整数，表示的值为：a*10n；B、C错在阶码必须是整数，D错在无阶码，答案为A， A的值为： 0.4 * 100 = 0.4。\n');
INSERT INTO `exercises` VALUES ('572', '设有定义：double  x;，以下选项中不能将输入数据3.14读入赋给变量x的是\n', 'scanf(\"%4.2f\",&x);', 'scanf(\"%lf\",&x);', 'scanf(\"%le\",&x);', 'scanf(\"%4lf\",&x);', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, 'scanf()函数格式字符串的一般形式为：%[*][输入数据宽度][长度]类型。输入数据宽度必须是十进制的整数，它没有精度控制，%4.2f是错误的，不能企图用此语句输入小数点为2位的实数，选项A错误；scanf()函数的长度格式符为l和h，%lf表示用小数形式输入双精度浮点数，满足条件，选项B正确；%le表示用指数形式输入双精度浮点数，满足条件，选项C正确；%4lf表示用小数形式输入宽度为4的双精度浮点数，选项D正确；答案为A。\n');
INSERT INTO `exercises` VALUES ('573', '有以下程序\n    #include <stdio.h>\n    main()\n    {  int  x,y=0,z=0,t;\n       do\n       {  scanf(\"%d\",&x);\n          t=x>0;\n          switch (t)\n          {  case 0:  break;\n             case 1:  y+=x; continue;\n          }\n          z+=x;\n       }\n       while(x);\n       printf(\"%d,%d\\n\",y,z);\n    }\n程序运行时输入：-1 1 -2 2 0<回车>，则输出结果是\n', '1,1', '1,0', '3,-3', '3,0', 'C', null, '35', '2018年3月二级《C语言》模拟试题1', null, '分析程序结构，在do…while循环中，嵌套一个switch语句，switch语句中两个case语句分别执行break和continue，其中break语句是跳出switch语句，接着执行do…while循环体剩下的部分；而continue语句是直接进入do…while的下一个循环，由此可知每次循环，当t=0时，执行break语句，接着将z值累加x；当t=1时，执行continue语句，将y值累加x，所以当x输入-1、-2、0时，t = 0，z值累加为-3；当x输入1、2时，t=1，y值累加为3，输出y、z的值分别为 3、-3，答案选C。\n\n');
INSERT INTO `exercises` VALUES ('574', '以下选项中能正确定义二维数组的选项是\n', 'double  a[][3]={ 2*3 };', 'double  a[][3];', 'double  a[][3]={  };', 'double  a[2][3]={{1.0},{2.0},{3.0,4.0}};', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '如果第一维的长度没有指定，则定义的同时需要完成初始化，否则不知道分配多大的内存空间给它，所以选项B、C错误；二维数组a[2][3]中只有两个元素，都是一维数组，一维下标最大只能是a[1]，所以选项D错误；若完成初始化的二维数组，第一维的长度没有指定，则第一维的大小按如下规则确定：若初值个数能被第二维大小整除，所得的商就是第一维的大小，若不能整除，则所得的商加1作为第一维的大小，所以选项A相当于：\ndouble a[1][3] = {6}；其中a[0][0]=6，其他元素赋值0，选项A正确，答案为A。\n');
INSERT INTO `exercises` VALUES ('575', '若有函数定义如下\n          int fun(int  x,int  y)\n          {  return  x-y;  }\n则以下涉及上述函数的说明语句错误的\n', 'int fun( int  x,y );', 'int fun( int ,int );', 'int fun( int  a,int  b );', 'int i,fun(int  x,int  y);', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, 'C语言中函数的说明形式为：类型说明符 函数名（类型 形参名1， 类型 形参名2， ...）;其中形参名可以与函数定义时的形参名不同，或者直接省略，选项D，变量i和函数同时声明，答案为A选项。\n');
INSERT INTO `exercises` VALUES ('576', '有以下程序\n    #include <stdio.h>\n    #define N  4\n    main()\n    {  int  a[N][N]={0},i,j,k;\n       for( i=0; i<N/2; i++ )\n       {  for( j=i; j<N-i; j++ )\n             a[i][j]=a[N-i-1][j]=i+1;\n          for( k=i+1; k<N-i-1; k++ )\n             a[k][i]=a[k][N-i-1]=i+1;\n       }\n       for(j=0; j<N; j++)\n             printf(\"%2d\",a[1][j]);\n      printf(\"\\n\");\n    }\n执行后的输出结果是\n', '1 2 2 1', '1 1 1 1', '2 1 1 2', '2 2 2 2', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '本题程序需要输出二维数组a中第二行的各个元素值，即a[1]这个一维数组的元素值。分析程序可知只有在两种情况下才会对a[1]中的元素赋值：1、外层for循环中i=0时，内层第二个for循环的k取值为1，此时a[k][i]=a[1][0]=1，a[k][N-i-1]=a[1][3]=1；2、外层for循环中i=1时，内层第一个for循环的j取值为1、2，a[i][j]=a[1][j]=2，即a[1][1]=2，a[1][2]=2；除了这两种情况，其他情况不会修改a[1]中的值，所以最终a[1]各个元素的值为：1、2、2、1；答案选A。\n');
INSERT INTO `exercises` VALUES ('577', '有以下程序\n     #include <stdio.h>\n     int f(int n);\n     main()\n     {  int a=3,s;\n        s=f(a);s=s+f(a); printf(\"%d\\n\",s);\n     }\n     int f(int n)\n     {  static int a=1;\n        n+=a++;\n        return n;\n     }\n\n程序运行后的输出结果是\n', '7', '8', '9', '10', 'C', null, '35', '2018年3月二级《C语言》模拟试题1', null, '首先main函数中的局部变量a和f()函数中的静态局部变量a的作用域都只限在其所在的函数中，相互之间不影响，看作两个不同的变量即可；另外f()函数中的静态局部变量a只在第一次调用f()函数时初始化一次，其他调用都会保留上一次调用结束时的值；分析main函数可知，第一次调用时将f(a)的返回值赋给s，所以语句可以改写为：s=f(a)+f(a)，即main函数中调用两次f(a)，传入的参数a取值都为3，第一次调用时，静态局部变量初始化为1，所以n=4并返回，a自增为2；第二次调用时静态局部变量a取上一次调用结束时的值2，所以n=5并返回，a自增为3；所以在main()函数中，s=4+5=9，所以函数执行完输出结果为9，答案为C。\n\n');
INSERT INTO `exercises` VALUES ('578', '有以下程序\n#include   <stdio.h>\nmain( )\n{  int  i,j=0; \n   char  a[]=\"How are you!\";\n   for ( i=0; a[i]; i++ )\n      if ( a[i] != \' \' )\n          a[j++] = a[i];\n   a[j] = \'\\0\';\n   printf( \"%s\\n\",a );\n}\n程序运行后的输出结果是\n', 'Howareyou!', 'areyou!', 'you!', 'Howareyou!u!', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '首先main函数初始化一个字符数组a，a的内容为字符串”How are you!”（包括结尾的’\\0’），所以for循环开始于字符串的首个字符，结束于空字符’\\0’，换句话说，for循环遍历字符数组a，将字符数组a的每个非空格字符重新赋值给自身，并在循环结束时加上空字符’\\0’，所以整个程序是将字符数组a中的空格字符去除，输出结果为：\n“Howareyou!”，答案为A。\n');
INSERT INTO `exercises` VALUES ('579', '若有以下函数\n    int  fun(char  *a, char  *b)\n    {  int  bk=0;\n       while( (*a!=\'\\0\')&&(*b!=\'\\0\') && strlen(a)==strlen(b) )\n       {   if(*b != *a)  {  bk=0;  break; }\n           a++; b++; bk=1;\n       }\n       return  bk;\n    }\n此函数的功能是\n', '判断a和b两个字符串是否相等', '将字符串a改名为字符串b', '将字符串变量a的值赋赋给字符串变量b', '检查字符串a和b中是否有\'\\0\'', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '分析程序可知：函数fun在字符指针a和b未遇到字符‘\\0’且a指向的字符串A长度与b指向的字符串B长度相同时，遍历A、B，逐个比较a指向的字符与b指向的字符是否相同，所以程序分三种情况：1、A的长度与B的长度不同，返回值为0；2、A的长度与B的长度相等，但A中某个位置i上的字符与B中位置i上的字符不同，返回值为0；3、A的长度与B的长度相等，且A中相同位置上的字符与B中相同位置上的字符全部相同，返回值1；由此可知函数的功能是判断a和b指向的两个字符串是否相等。答案为A。\n\n');
INSERT INTO `exercises` VALUES ('580', '设有如下定义和语句\n     [1]  char  *s; s=\"string\";\n     [2]  char  s[7]; s=\"string\";\n     [3]  char  s[ ]=\"string\";\n     [4]  char  s[ ]={\'s\',\'t\',\'r\',\'i\',\'n\',\'g\'};\n其中定义项可以作为字符串使用的是\n', '[1]和[4]', '[1]和[2]', '[1]和[3]', '[3]和[4]', 'C', null, '35', '2018年3月二级《C语言》模拟试题1', null, '字符数组只能在初始化的时候完成赋值，否则只能对数组元素逐个赋值，[2]是错误的；C语言字符串必须包含’\\0’字符，用来表示字符串结束标志，[4]错误；可以将字符串直接赋给字符指针，使得指针指向字符串首地址，[1]正确；在字符数组初始化时，可以直接使用字符串，[3]正确；答案为C。\n');
INSERT INTO `exercises` VALUES ('581', '设有定义和语句（假设short int型数据占2字节）\n         short int  *pi,*pj;\n         pi=pj=(short *)malloc(2);\n则以下叙述正确的是\n', 'pi和pj指向了同一个short int型存储单元', 'pi和pj指向了2个连续的short int型存储单元的首地址', 'pi和pj分别指向了一个short int型存储单元', 'pi和pj分别指向了2个short int型存储单元', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '语句pi=pj=(short *)malloc(2) 首先使用动态分配函数malloc分配2个字节的内存空间，然后将内存首地址转换为short *类型并返回，赋值给pj，再将pj的值赋给pi，所以指针pi和pj的值是相同的，指向同一个short int型的存储单元，选项A正确。\n\n');
INSERT INTO `exercises` VALUES ('582', '有以下程序\n#include   <stdio.h>\n#include   <string.h>\nmain( )\n{  int  i, len;\n   char  b[]=\"Welcome you to Beijing!\";\n   len = strlen(b);\n   for ( i=0; i<len; i++ )\n      if ( b[i] == \' \' )\n      {   strcpy(b, b+i+1);\n          i=0;\n      }\n   printf( \"%s\\n\", b );\n}\n程序运行后的输出结果是\n', 'Beijing!', 'to Beijing!', 'Welcome you to Beijing!', 'you to Beijing!', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, 'strcpy(char *dest, char *source)函数是将source指向的字符串拷贝到dest指向的内存空间，所以for循环在遍历字符数组b的同时，查找b中的空格字符，将空格字符后的剩余字符串重新拷贝到字符数组b中，然后重新设置循环的索引下标为0，继续寻找空格字符，直到到达字符串的结尾空字符‘\\0’，由此可知整个程序是获取字符串“Welcome you to Beijing!”的最后一个不包含空格字符的子串，程序输出：“Beijing!”，答案选A。\n');
INSERT INTO `exercises` VALUES ('583', '有以下程序\n    #include   <stdio.h>\n    void  fun(  int  a  )\n    {  if( a>1 )  fun(a-1);\n       printf(\"%d \",a);\n    }\n    main()\n    {  int  q=5;  fun(q);  printf(\"\\n\");  }\n执行后的输出结果是\n', '1 2 3 4 5', '5 4 3 2 1', '0 1 2 3 4 5', '5 4 3 2 1 0', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '本题考查递归函数。函数fun(a)在a>1时，递归调用fun(a-1)，否则输出a的值，由于printf()函数在递归调用之后，所以直到递归函数运行完后再执行printf()函数，所以fun(5)中首先递归调用fun(4),再递归调用fun(3)、fun(2),fun(1)，最后当a=1时，输出1，接着输出2、3、4、5，所以输出结果为：1 2 3 4 5，答案为A。\n\n');
INSERT INTO `exercises` VALUES ('584', '有以下程序 \n#include   <stdio.h>\n#define   MUL1(x,y)   x*y\n#define   MUL2(x,y)   (x)*(y)\n#define   MUL3(x,y)   (x*y)\nmain()\n{  int  m=2,n=3;\n   printf( \"%d,%d,%d\\n\",MUL1(m,m+n)*2,MUL2(m,m+n)*2,MUL3(m,m+n)*2 );\n}\n程序运行后的输出结果是\n', '10,20,14', '20,20,20', '10,10,10', '14,14,14', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '本题考查宏定义，宏定义在程序的预编译阶段直接进行文本替换，所以本题中宏定义展开如下：\nMUL1(m,m+n)*2=m*m+n*2=2*2+3*2=10\nMUL2(m,m+n)*2=(m)*(m+n)*2=2*(2+3)*2=20\nMUL3(m,m+n)*2=(m*m+n)*2=(2*2+3)*2=14\n程序输出结果为10,20,14  答案为A。\n');
INSERT INTO `exercises` VALUES ('586', '有以下程序\n#include   <stdio.h>\n#define   S(x)   (x/x)*x\nmain( )\n{  int  k=6, j=3;\n   printf( \"%d,%d\\n\",  S(k+j), S(j+k) );\n}\n程序运行后的输出结果是\n', '57,39', '57,57', '9,9', '39,39', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '本题考查宏定义，宏定义是在程序预处理阶段直接进行文本替换，所以本题中S(k+j)、S(j+k)可以替换如为：S(k+j)=(k+j/k+j)*k+j=(6+3/6+3)*6+3=57；S(j+k)=(j+k/j+k)*j+k=(3+6/3+6)*3+6=39答案为A。（注：宏定义中的形参一定要使用小括号括起来，以避免出错）\n');
INSERT INTO `exercises` VALUES ('587', '若要通过位运算使整型变量a中的各位数字全部清零，以下选项正确的是\n', 'a=a&0;', 'a=a|0;', 'a=a^0;', 'a=!a;', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '本题考查位运算符和位运算。’|’运算符，1|0=1,0|0=0，所以选项B中a变量的各位数字保持不变，B错误；‘^’运算符，1^0=1,0^0=1，所以选项C中a变量的各位数字中，1保持不变，0变成1,C错误；‘!’运算符，!1=0,!0=1,所以选项D中a变量的个位数字中，1变成0,0变成1，D错误；‘&’运算符，1&0=0,0&0=0，所以选项A中各位数字全部清零，答案为A。\n');
INSERT INTO `exercises` VALUES ('588', '有定义语句：int  i;  char  s1[10],  s2[10]= \"Program\";  则能正确给s1数组赋字符串的语句是\n', 'for(i=0; i<=7; i++) s1[i]=s2[i];', 's1=s2;', 'while(s2) s1++ =s2++;', 'for(i=0; s2[i]; i++ ) s1[i]=s2[i];', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '首先字符数组只有在初始化的时候整体赋值，否则只能对字符数组逐个赋值，所以选项B错误；另外字符数组名s1、s2是常量，不能改变，选项C错误；字符串”Program”包含结尾的’\\0’，选项D中在处理到s2[i]=’\\0’时，跳出循环，未将’\\0’赋给s1，所以选项D也是错误的；由于”Program”包含结尾的’\\0’总共有8个字符，所以选项A是正确的，答案为A。\n');
INSERT INTO `exercises` VALUES ('589', '以下程序拟读取一个姓氏，查找其对应的年龄并输出\n    #include <stdio.h>\n    #include <string.h>\n    #include <stdlib.h>\n    struct person { char name[10]; int age;};\n    struct person group[6]={ \"zhang\", 18,\n                             \"wang\",20,\n                             \"li\",19,\n                             \"zhao\",18,\n                             \"liu\",19\n                            },*p;\n    main()\n    {  int  i,flag=0;\n       p=(struct person *)malloc(sizeof(struct person));\n       gets( &p->name );\n      for(i=0; i<6; i++)\n        if( (strcmp(p->name,group[i].name )==0))\n        {   printf(\"%d\\n\",group[i].age );\n            flag=1;\n        }\n        if(flag==0) printf(\"No find!\\n\");  \n    }\n程序有语法错，出错的是\n', 'gets( &p->name );', 'p=(struct person *)malloc(sizeof(struct person));', 'if( (strcmp(p->name,group[i].name )==0))', 'printf(\"%d\\n\",group[i].age );', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '语句gets(&p->name)中，gets的参数应该是成员变量name数组的首地址，而&p->name是首先获取数组name的首地址，然后再对首地址取地址符，所以这是错误的，正确参数应该是：gets(p->name);答案选A。\n');
INSERT INTO `exercises` VALUES ('590', '若有以下程序\n     #include <stdio.h>\n     void  sp(int  *a)\n     {  int  b=2;\n        *a = *a * 2;   printf(\"%d,\", *a); \n        a=&b;    *a = *a * 2;   printf(\"%d,\", *a); \n     }\n     main()\n     {  int  k=3;\n        sp(&k);   printf(\"%d\\n\", k); \n     }\n\n则程序的输出结果是（）。\n', '6,12,12', '6,4,3', '6,4,6', '9,4,9', 'C', null, '35', '2018年3月二级《C语言》模拟试题1', null, '首先在主函数中给整型变量k赋值为3，调用sp函数，将变量k的地址作为实参传递给形参指针变量a；在sp函数中，*a = *a * 2;即结果为6，通过printf()函数输出。整型变量b的地址赋给指针变量a，再执行*a = *a * 2;，即结果为4，通过printf()函数输出。返回主函数，输出k的值6。因此C选项正确。\n');
INSERT INTO `exercises` VALUES ('591', '有以下程序\n#include  <stdio.h>\nint  f( int  k )\n{  static  int  n=0; \n   int  m=0;\n   n++;   m++;   k++;\n   return  n+m+k;\n}\nmain( )\n{  int  k;\n   for ( k=0; k<2; k++ )   printf( \"%d,\", f(k) );\n   printf( \"\\n\");\n}\n程序运行后的输出结果是（）。\n', '3,5,', '3,6,', '3,7,', '0,3,', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, 'static静态变量只在声明时初始化一次。因此，第一次调用函数f(k=0)，此时n=m=k=0, 经过自增操作n=1,m=1,k=1,返回值为3，第二次调用函数f(k=1)，此时n=1，k=1,m=0,经过自增操作，n=2,k=2,m=1,返回值为5.故最终结果为3,5。故答案为A选项。\n');
INSERT INTO `exercises` VALUES ('592', '有以下程序：\n#include  <stdio.h>\nint f(int x)；\nmain()\n{ int n＝1，m；\n　m＝f(f(f(n)))； printf(\"%d\\n\"，m)；\n}\nint f(int x)\n{ return x*2； }\n程序运行后的输出结果是(　　)。\n', '8', '2', '4', '1', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '第一次调用m＝f(f(f(1)))，第二次为m＝f(f(2))，第三次为m＝f(4)，即返回值为8。\n');
INSERT INTO `exercises` VALUES ('593', '若有以下程序\n     #include <stdio.h>\n     char  *a=\"you\", b[ ]=\"welcome#you#to#China!\";\n     main()\n     {  int  i,j=0;    char *p;\n        for ( i=0; b[i]!=\'\\0\'; i++ )\n        {   if (*a == b[i])\n            {  p=&b[i];\n               for (j=0; a[j]!=\'\\0\'; j++)\n                {  if (a[j] != *p)  break;\n                   p++;\n                }\n            if (a[j]==\'\\0\')  break;\n            }\n        }\n        printf(\"%s\\n\", p);\n     }\n\n则程序的输出结果是（）。\n', '#to#China!', '#you#to#China!', 'me#you#to#China!', '#China!', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, '该程序首先定义*a和b[ ]，并进行初始化。主函数中通过外层for循环语句，遍历字符数组b[ ]，并且将符合if条件语句的字符赋给数组p；for内层循环语句，遍历字符数组a[ ]。再将符合if条件语句的结果输出。因此A选项正确。\n');
INSERT INTO `exercises` VALUES ('594', '读取二进制文件的函数调用形式为：\n    fread(buffer,size,count,fp);\n其中buffer代表的是\n', '一个内存块的首地址，代表读入数据存放的地址', '一个整型变量，代表待读取的数据的字节数', '一个文件指针，指向待读取的文件', '一个内存块的字节数', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, 'fread()函数的原型为： Size_t fread(void *buffer, size_t size, size_t count, FILE *stream)是从文件流stream中最多读取count个元素写入buffer指向的内存中，每个元素size个字节，返回值为实际读取到的元素个数，所以答案为A。\n');
INSERT INTO `exercises` VALUES ('595', '以下关于C语言文件的叙述中正确的是\n', '文件由数据序列组成，其类型可以为二进制文件或文本文件', '文件由记录序列组成，其类型可以为二进制文件或文本文件', '文件由字符序列组成，其类型可以为二进制文件或文本文件', '文件由数据序列组成，其类型只能是二进制文件', 'A', null, '35', '2018年3月二级《C语言》模拟试题1', null, 'C语言文件是指一组相关数据的有序集合，从文件编码的方式看，文件可分为ASCII码文件和二进制文件两种，其中ASCII文件也称为文本文件，所以文件由数据序列组成，类型可以为二进制文件或文本文件，选项A正确。\n');
INSERT INTO `exercises` VALUES ('596', '有以下程序\n#include <stdio.h>\nmain( )\n{  FILE  *fp;\n   int i, a[6] = {1,2,3,4,5,6}, k;\n   fp = fopen(\"data.dat\", \"w+b\");\n   fwrite(&a[0], sizeof(int), 1, fp);\n   for (i=1; i<6; i++)\n   {\n      fseek(fp, 0L, 0);\n      fwrite(&a[i], sizeof(int), 1, fp);\n   }\n   fseek(fp, 0L, 0);\n   fread(&k, sizeof(int), 1, fp);\n   fclose(fp);\n   printf(\"%d\\n\", k);\n}\n程序运行后的输出结果是\n', '123456', '21', '6', '654321', 'C', null, '35', '2018年3月二级《C语言》模拟试题1', null, '首先使用fopen函数以只写方式打开文件data.dat，返回文件指针fp，然后通过调用fwrite函数，将起始地址为&a[0]，单位长度为sizeof(int)的一个元素写入文件，即写入a[0]；接着for循环从数组a的第二个元素起，每次首先使用fseek()函数将指针fp定位到文件data.dat的开始位置，写入起始地址&a[i]，单位长度为sizeof(int)的一个元素，即写入a[i]；此时数组元素按照逆序写入文件：654321。循环结束后，使用fseek()函数再将指针fp定位到文件开始位置，调用fread()函数，从fp所指位置读取单位长度为sizeof(int)的一个元素到变量k中，即k=6，最后调用fclose()函数关闭文件，输出k的值6；答案为C。\n');
INSERT INTO `exercises` VALUES ('664', '设栈的顺序存储空间为 S(1:m)，初始状态为top=0。现经过一系列正常的入栈与退栈操作后，top=m+1，则栈中的元素个数为（  ）。\n', '不可能', 'm+1', '0', 'm', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '栈是一种特殊的线性表，它所有的插入与删除都限定在表的同一端进行。入栈运算即在栈顶位置插入一个新元素，退栈运算即取出栈顶元素赋予指定变量。栈为空时，栈顶指针top=0，经过入栈和退栈运算，指针始终指向栈顶元素，栈满时，top=m。初始状态为top=m+1是不可能的。故本题答案为A选项。\n\n');
INSERT INTO `exercises` VALUES ('665', '下列排序法中，最坏情况下时间复杂度最小的是（  ）。\n', '堆排序', '快速排序', '希尔排序', '冒泡排序', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '堆排序最坏情况时间下的时间复杂度为O(nlog2n)；希尔排序最坏情况时间下的时间复杂度为O(n1.5)；快速排序、、冒泡排序最坏情况时间下的时间复杂度为O(n2)。故本题答案为A选项。\n\n');
INSERT INTO `exercises` VALUES ('666', '某二叉树的前序遍历序列与中序遍历序列相同，均为 ABCDEF ，则按层次输出（同一层从左到右）的序列为（  ）。\n', 'ABCDEF', 'BCDEFA', 'FEDCBA', 'DEFABC', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '二叉树遍历可以分为3种：前序遍历（访问根结点在访问左子树和访问右子树之前）、中序遍历（访问根结点在访问左子树和访问右子树两者之间）、后序遍历（访问根结点在访问左子树和访问右子树之后）。二叉树的中序遍历序列和前序遍历序列均为ABCDEF，可知该树只有右子树结点，没有左子树结点，A为根结点。中序遍历序列与前序遍历序列相同说明该树只有右子树没有左子树，因此该树有6层，从顶向下从左向右依次为ABCDEF。故本题答案为A选项。\n\n');
INSERT INTO `exercises` VALUES ('667', '下列叙述中正确的是（  ）。\n', '对数据进行压缩存储会降低算法的空间复杂度', '算法的优化主要通过程序的编制技巧来实现', '算法的复杂度与问题的规模无关', '数值型算法只需考虑计算结果的可靠性', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '算法的空间复杂度指执行这个算法所需要的内存空间。在许多实际问题中，为了减少算法所占的存储空间，通常采用压缩存储技术，以便尽量减少不必要的额外空间。由于在编程时要受到计算机系统运行环境的限制，因此，程序的编制通常不可能优于算法的设计。算法执行时所需要的计算机资源越多算法复杂度越高，因此算法的复杂度和问题规模成正比。算法设计时要考虑算法的复杂度，问题规模越大越是如此。故本题答案为A选项。\n\n');
INSERT INTO `exercises` VALUES ('668', '软件需求规格说明的内容应包括（  ）。\n', '软件的主要功能', '算法详细设计', 'E-R模型', '软件总体结构', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '软件需求规格说明应重点描述软件的目标，软件的功能需求、性能需求、外部接口、属性及约束条件等。功能需求是软件需求规格说明，给出软件要执行什么功能的详尽描述。性能需求是指定量的描述软件系统应满足的具体性能需求，即各种软件功能的速度、响应时间、恢复时间。外部接口指软件如何与人、系统的硬件及其他硬件和其他软件进行交互。属性是指与软件有关的质量属性，如正确性、可用性、可靠性、安全性、可维护性等。约束条件包括影响软件实现的各种设计约束，如使用的标准、编程语言、数据库完整性方针、资源限制、运行环境等方面的要求。故本题答案为A选项。\n\n');
INSERT INTO `exercises` VALUES ('669', '某系统结构图如下图所示（图中n≥5）\n \n该系统结构图的宽度是（  ）。\n', 'n', '3', '2', '1', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '系统结构图的宽度指整体控制跨度（横向最大模块数）的表示。本题中，模块数最多的是第2层，即“功能1”到“功能n”的模块个数就是宽度，有n个。故本题答案为A选项。\n\n');
INSERT INTO `exercises` VALUES ('670', '软件是（  ）。\n', '程序、数据和文档的集合', '计算机系统', '程序', '程序和数据', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '计算机软件是计算机系统中与硬件相互依存的另一部分，是包括程序、数据及相关文档的完整集合。故本题答案为A选项。\n\n');
INSERT INTO `exercises` VALUES ('671', '关系数据库规范化的目的是为了解决关系数据库中的（  ）。\n', '插入、删除异常及数据冗余问题', '查询速度低的问题', '数据操作复杂的问题', '数据安全性和完整性保障的问题', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '关系数据库进行规范化的目地：使结构更合理，消除存储异常，使数据冗余尽量小，便于插入、删除和更新。关系模式进行规范化的原则：遵从概念单一化“一事一地”原则，即一个关系模式描述一个实体或实体间的一种联系。规范的实质就是概念的单一化。 关系模式进行规范化的方法：将关系模式投影分解成两个或两个以上的关系模式。故本题答案为A选项。\n\n');
INSERT INTO `exercises` VALUES ('672', '按照传统的数据模型分类，数据库系统可分为（  ）。\n', '层次、网状和关系', '大型、中型和小型', '西文、中文和兼容', '数据、图形和多媒体', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '数据模型（逻辑数据模型）是面向数据库系统的模型，着重于在数据库系统一级的实现。较为成熟并先后被人们大量使用的数据模型有层次模型、网状模型、关系模型和面向对象模型。故本题答案为A选项。\n\n');
INSERT INTO `exercises` VALUES ('673', '现有表示患者和医疗的关系如下：P(P#，Pn，Pg，By)，其中P#为患者编号，Pn为患者姓名，Pg为性别，By为出生日期， Tr(P#，D#，Date，Rt)，其中D#为医生编号，Date为就诊日期，Rt为诊断结果。检索在1号医生处就诊的男性病人姓名的表达式是（  ）。\n', '', '', '', '', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'π表示投影运算，针对属性；σ表示选择运算，针对元组；∞表示自然连接。首先在Tr表中选择D#为1的记录σD#=1(Tr)，并找出这些记录中患者的编号πP#(σD#=1 (Tr))；，再在P表中找到性别为男性的记录σPg =’男’(P)；将两次检索结果进行自然连接生成中间表πP#(σD#=1 (Tr))∞σPg =’男’(P)，最后在中间表中检索患者的姓名πPn(πP#(σD#=1 (Tr))∞σPg =’男’(P) )。故本题答案为A选项。\n');
INSERT INTO `exercises` VALUES ('674', '下面不合法的常量数据是（）。\n', '.023E-5', '0x3f7b8a90', '\'\\0x6d\'', '\'\\0123321\'', 'D', null, '36', '2018年3月二级《C语言》模拟试题2', null, '选项A是实型常量的指数表示形式，表示0.023*10-5，正确；选项B是十六进制表示的整型常量，正确；选项C是十六进制表示的转义字符常量，正确；选项D是字符串常量，应该使用双引号括起来，错误，本题答案为D。\n');
INSERT INTO `exercises` VALUES ('675', '以下叙述中错误的是（）。\n', 'C语言逻辑运算的结果是0和任意非0值', 'C语言中任意合法的表达式都可以作为逻辑运算的对象', 'C语言关系运算的值只有0和1两种可能', 'C语言中用0表示逻辑“假”，非零表示逻辑“真”', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '由关系运算符构成的表达式，称为关系表达式，关系运算的值为“逻辑值”，只有整数0或整数1，选项C正确；由逻辑运算符和运算对象组成的表达式称为逻辑表达式，逻辑运算的对象可以是C语言中任意合法的表达式，逻辑表达式的运算结果或者为1（“真”），或者为0（“假”），选项A错误，选项B正确；逻辑值只有两个，分别用“真”和“假”来表示，C语言中用非0表示“真”，用0表示“假”，选项D正确，本题答案为A。\n');
INSERT INTO `exercises` VALUES ('676', '以下说法正确的是（）。\n', 'C语言中的常量是指在程序运行过程中经常被改变数据类型的量', 'C语言中的常量是指在程序运行过程中经常被改变值的量', 'C语言中的常量是指在程序运行过程中经常被用到的变量', 'C语言中的常量是指在程序运行过程中其值不能被改变的量', 'D', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'C语言中的常量是指在程序运行过程中其值不能被改变的量，所以本题答案是D。\n\n');
INSERT INTO `exercises` VALUES ('677', 'C语言常量的类型从字面形式上可区分，以下判断中正确的是（）。\n', '2E3   ---  整型', '2.0E3 ---  实型', '\'\\025\'---  字符串', '\"a\"   ---  字符型', 'B', null, '36', '2018年3月二级《C语言》模拟试题2', null, '2E3是实型常量的指数形式，选项A错误；2.0E3是实型常量的指数形式，选项B正确；’\\025’是八进制表示的转义字符，选项C错误；“a”是双引号括起来的字符串常量，选项D错误；本题答案为B。\n');
INSERT INTO `exercises` VALUES ('678', '以下各选项中的代码段执行后，变量y的值不为1的是\n', '4,2', '4,4', '6,2', '5,4', 'B', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'strlen()函数计算参数指向的字符串长度，题意中字符数组a有6个字节的存储空间，但是只存储了4个字符，所以strlen()结果为4，选项C、D错误；sizeof()运算符是计算类型所占用的长度，题意中b是一个指针变量，指针在内存中占4个字节，所以sizeof结果为4，选项A错误；本题答案为B。\n');
INSERT INTO `exercises` VALUES ('679', '有以下程序 \n    #include <stdio.h> \n    void main() \n    { \n        double x=3.14159; \n        printf(\"%f\\n\", (int)(x*1000+0.5)/(double)1000); \n    } \n程序运行后的输出结果是（）。\n', '3.142000', '3.141000', '3.143000', '3.140000', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '根据算术表达式和运算符的优先级与结合性，对于题意表达式：int(x*1000 + 0.5)/(double)1000，首先计算x*1000，由于x是double类型，1000是整型，所以x*1000的结果默认是double类型：3141.59；再执行int的强制转换，结果为3142；分母(double)1000强制转换为double类型，此时3142/(double)1000中，3142需要转换成double类型，然后除以1000，结果为3.142000，保留小数点后6位，本题答案为A。\n');
INSERT INTO `exercises` VALUES ('680', '  有以下程序 \n    #include <stdio.h> \n    void main() \n    {   char *s = \"\\ta\\018bc\"; \n        for (; *s != \'\\0\'; s++) \n            printf(\"*\"); \n        printf(\"\\n\"); \n    } \n程序运行后的输出结果是（）。\n', '******', '*********', '*****', '*******', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'main()函数定义一个字符指针s，指向字符串”\\ta\\018bc”，for循环遍历s指向的字符串中的字符，然后输出“*”，所以题意可以理解为：s指向的字符串中有多少个字符，就输出多少个“*”；s指向的字符串中字符分别是：’\\t’(转义字符)、’a’、’\\01’（转义字符）、’8’、’b’、’c’，总共6个，其中由于8不属于八进制中的数字，所以’\\018’不是一个转义字符，而’\\01’是转义字符，本题答案为A。本题答案为B。\n');
INSERT INTO `exercises` VALUES ('681', '以下有关全局变量的叙述中错误的是（）。\n', '全局变量没被引用时，不占用内存空间', '所有在函数体外定义的变量都是全局变量', '全局变量可以和局部变量同名称', '全局变量的生命周期一直持续到程序结束', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '全局变量在程序运行时就分配了存储空间，直到程序结束，它的生命周期是整个程序的运行期，选项A错误、D正确；在函数体外定义的变量都属于全局变量，选项B正确；全局变量可以和局部变量同名，在局部作用域局部变量会屏蔽同名的全局变量，除非显示的引用全局变量，选项C正确；本题答案为A。\n');
INSERT INTO `exercises` VALUES ('682', '有如下程序\n#include  <stdio.h>\n#include  <string.h>\nmain() \n{\n    printf(\"%d\\n\", strlen(\"0\\n011\\0\"));\n}\n程序运行后的输出结果是（）。\n', '5', '6', '8', '9', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'strlen()函数是求字符串长度的库函数，它在遍历字符串过程中遇到字符串结束符‘\\0’时，计算结束，计算结果不包括‘\\0’，所以题意中字符串“0\\n011\\0”长度为5，各个字符分别是：‘0’、‘\\n’、‘0’、‘1’、‘1’，本题答案为A。\n');
INSERT INTO `exercises` VALUES ('683', '若有定义： char s1[100 ]=\"name\", s2[ 50]=\"address\", s3[80]=\"person\";，要将它们连接成新串:\"personnameaddress\"，正确的函数调用语句是（）。\n', 'strcat(strcat(s1,s2),s3);', 'strcat(s3,strcat(s1,s2));', 'strcat(s3,strcat(s2,s1));', 'strcat(strcat(s2,s1),s3);', 'B', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'strcat()函数是字符串连接函数，调用形式为：strcat(s1, s2);表示将s2指向的字符串的内容复制到s1指向的存储空间中，返回s1的地址；由题意可知新串首地址为s3，所以s3应该是第一参数，选项A、D错误；同理，新串中除了s3字符串，剩下的字符串为：”nameaddress”，即首地址为s1，所以调用strcat()函数，s1是第一参数，所以正确的函数调用语句为：strcat(s3, strcat(s1, s2))；本题答案为B。\n');
INSERT INTO `exercises` VALUES ('684', '  有以下程序 \n    #include <stdio.h> \n    #define SWAT(t,a,b)  t=a; a=b; b=t; \n    main() \n    { int  x=6,y=4,z=3,s=0; \n      if(x<y)  SWAT(s,x,y); \n      if(x<z)  SWAT(s,x,z); \n      if(y<z)  SWAT(s,y,z); \n      printf(\"%d,%d,%d\\n\", x,y,z); \n    } \n执行后的输出结果是\n', '6,4,3', '3,4,6', '0,3,4', '3,0,0', 'D', null, '36', '2018年3月二级《C语言》模拟试题2', null, '程序定义一个宏，#define SWAT(t,a,b) t=a;a=b;b=t;所以程序中，三个if语句经过宏替换后如下：\nif (x < y) s=x; x = y; y = s;\nif (x < z) s = x; x = z; z = s;\nif (y < z) s = y; y = z; z = s;\nx初值6，y初值4，z初值为3，s初值为0，所以：\n第1个if语句，x<y（6<4）为假，执行x=y;y=s;此时x的值为4，y的值为0；\n第2个if语句，x<z（4<3）为假，执行x=z;z=s;此时x的值为3，z的值为0；\n第3个if语句，y<z（0<0）为假，执行y=z;z=s;此时y的值为0，z的值为0；最终x、y、z的值为3、0、0；本题答案为D。\n');
INSERT INTO `exercises` VALUES ('685', '若有定义：char ch; int a; double d;， 当输入为12345 678910.36时，以下选项中能给各个变量正确输入数据的是（）。\n', 'scanf(\"%d%c%lf\",&a,&ch,&d);', 'scanf(\"%5d%2c%7.2lf\",&a,&ch,&d);', 'scanf(\"%d%c%lf\",a,ch,d);', 'scanf(\"5d%2c%7.2lf%\",&a,&ch,&d);', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'scanf()函数是标准输入函数，其中双引号之间的内容是格式控制串，后面是输入参数列表。其中输入参数列表中各项都必须是变量地址，所以选项C错误；在scanf()函数的格式字符前，可以加入一个正整数指定输入数据所占的宽度，但不可以对实数指定小数位的宽度，所以选项B、D错误；选项A是正确的，按照A的输入格式，12345赋值给a，空格赋值给ch，678910.36赋值给d；本题答案为A\n');
INSERT INTO `exercises` VALUES ('686', ' 有如下程序\n#include  <stdio.h>\nmain() \n{\n    char a, b;\n    int i;\n    a = \'3\';\n    b = \'A\';\n    for (i=0; i<6; i++)\n    {\n        if (i % 2) putchar(a + i);\n        else putchar(b + i);\n    }\n}\n程序运行后的输出结果是（）。\n', 'AB56EF', 'A4C6E8', 'B4D6F8', 'A5C7E9', 'B', null, '36', '2018年3月二级《C语言》模拟试题2', null, '程序首先赋值a为字符’3’，赋值b为字符’A’，循环变量i的初值为0，每次循环后自增1，最大值为5，if条件判断i的值，当i的值为偶数时，将b与i的和当做字符输出；当i的值为奇数时，将a与i的和当做字符输出；所以i为0时，输出b+0即A；i为1时，输出a+1即‘4’；i为2时，输出b+2即C；i为3时输出a+3即‘6’……，综上，程序运行结果为：A4C6E8，本题答案为B\n');
INSERT INTO `exercises` VALUES ('687', '有以下程序 \n    #include <stdio.h> \n    void fun(double x, double *y, double *z) \n    {   *y = *y-1.0; *z = *z+x;  } \n    main() \n    {   double a=2.5, b=9.0, *pa, *pb; \n        pa=&a;  pb=&b; \n        fun(b-a,pa,pb); \n        printf(\"%f\\n\",a); \n    } \n程序运行后的输出结果是\n', '8.000000', '9.000000', '1.500000', '10.500000', 'C', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'main()函数定义两个double类型的变量a、b，分别赋初值为：2.5、9.0，另外定义两个double类型的指针变量pa、pb，其中pa指向a，pb指向b；然后将b-a、pa、pb传给函数fun，此时x的值为7.5，y指向a，z指向b；所以：\n*y=*y-1.0，是将变量a的值减去1.0赋给a，a的值为1.5；\n*z=*z+x，是将变量b的值加上7.5赋给b，b的值为16.5；\nfun()函数执行完毕后，输出a的值为1.5；本题答案为C。\n');
INSERT INTO `exercises` VALUES ('688', '有下列程序 \n　　#include  <stdio.h> \n　　void fun(int a[ ], int n, int flag) \n　　{  int i=0,j, t; \n　　   for (i=0; i<n-1; i++) \n　　    for (j=i+1; j<n; j++) \n　　     if (flag ? (a[i] < a[j]) : (a[i] > a[j])) \n　　     { t = a[i]; a[i] = a[j]; a[j] = t;} \n　　} \n　　main( ) \n　　{  int c[10]={7,9,10,8,3,5,1,6,2,4},i; \n　　   fun(c, 10, 1); \n　　   fun(c, 5, 0); \n　　   for (i=0;i<10; i++) \n　　      printf(\"%d,\", c[i]); \n　　} \n程序执行后的输出结果是（）。\n', '5,4,3,2,1,6,7,8,9,10,', '6,7,8,9,10,5,4,3,2,1,', '6,7,8,9,10,1,2,3,4,5,', '10,9,8,7,6,1,2,3,4,5,', 'B', null, '36', '2018年3月二级《C语言》模拟试题2', null, '题意中，fun()函数接收数组a，数组元素个数n以及整型变量flag，然后通过for循环遍历数组a的n个元素，若flag为1，则将数组元素降序排列，若flag为0，则将数组元素升序排列。main()函数定义整型数组c，它包含10个元素，首先将数组c、元素个数10和1传给fun()函数，将c中10个元素逆序排列，结果为：10,9,8,7,6,5,4,3,2,1；然后再次调用fun()函数，将数组c，元素个数5和0传给fun()函数，将c中前5个元素升序排列，结果为：6,7,8,9,10,5,4,3,2,1，本题答案为B。\n');
INSERT INTO `exercises` VALUES ('689', '  有如下程序\n#include  <stdio.h>\nvoid get_put()\n{\n    char ch;\n    ch = getchar();\n    if (ch != \'\\n\') get_put();\n    putchar(ch);\n}\nmain() \n{\n    get_put();\n}\n程序运行时，输入AB12<回车>，则输出结果是（）。\n', '2100', '21BA', 'DCBA', '21AB', 'B', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'main()函数调用get_put()函数，get_put()是递归函数，每次使用getchar()读入一个字符存放到ch中，若ch不是字符’\\n’，递归调用自身，然后调用putchar()函数输出该字符。当输入AB12\\n（<回车>）时，直到读入的字符是’\\n’，输出回车符，然后回到上一层递归，逆序输出各个字符，输出结果为：<回车>21BA，所以本题答案为B。\n');
INSERT INTO `exercises` VALUES ('690', ' 有以下程序\n    #include <stdio.h>\n    void swap(int *a, int *b)\n   {   int  t, *tp;\n       t = *a; *a = *b; *b = t;\n       tp = a;  a = b;  b = tp;\n       printf(\"%d,%d,\", *a,*b);\n    }\n    main( )\n    {  int i=3, j=7, *p=&i, *q=&j;\n       swap(p, q);\n       printf(\"%d,%d,%d,%d\", i, j, *p, *q);\n    }\n    程序执行后的输出结果是\n', '3,7,3,7,3,7', '7,3,7,3,7,3', '3,7,3,7,7,3', '3,7,7,3,7,3', 'D', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'main()函数中，首先定义两个整型变量i和j，初值为3和7，并将i的地址赋给p，j的地址赋给q，传给swap()函数，swap()函数接收两个整型指针变量a，b，然后使用整型变量t交换a、b所指向的值并输出，通过指针变量，这次交换改变了实参i、j的值，使得i=7，j=3；指针变量tp交换a和b的值，由于a、b的值是p，q值的拷贝，所以这次交换只改变了形参a，b的值，对实参p，q的值没有改变，所以此时a指向j，b指向i，函数最后输出*a和*b，所以输出3,7；由于swap()函数改变了p和q指向的值，但未改变p，q的值，所以main()函数输出i的值为7，j的值为3，*p的值为i，*q的值为j，所以程序输出：3,7,7,3,7,3，本题答案为D。\n');
INSERT INTO `exercises` VALUES ('691', ' 有如下程序\n#include  <stdio.h>\n#include  <string.h>\nmain() \n{\n    char a[] = \"THIS\\0\", *b = \"OK\\0\\0\";\n    printf(\"%d,%d,%d,%d\", strlen(a), sizeof(a), strlen(b), sizeof(b));\n}\n程序运行后的输出结果是（）。\n', '4,6,2,4', '4,4,4,1', '6,5,2,1', '6,4,2,4', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'strlen()函数求得参数中字符串的长度（不包括字符串结束符’\\0’）；sizeof()运算符，求得参数这种类型所占存储空间的长度；题意中a是数组名，由于定义时省略维数大小，所以数组大小是初始化的字符个数，所以a的数组大小为6，综上：strlen(a)只计算字符’T’、’H’、’I’、’S’，结果为4；sizeof(a)是求得数组a的大小，结果为6；另外指针b指向一个字符串’OK\\0\\0’，所以strlen(b)只计算字符’O’、’K’，结果为2，sizeof(b)求得指针占用存储空间的大小，结果为4，本题答案为A。\n');
INSERT INTO `exercises` VALUES ('692', '以下选项中，能够正确利用随机函数rand()，产生一个英文字母的表达式是（）。\n', 'rand()%2==0 ? rand()%\'A\' : rand()%\'a\'', 'rand()%26+\'A\'|| rand()%26+\'a\'', 'rand()%26+\'A\' && rand()%26+\'a\'', 'rand()%2==0 ? rand()%26+\'A\': rand()%26+\'a\'', 'D', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'rand()函数是产生随机数的函数，它可以生成0~RAND_MAX之间的一个随机数，其中RAND_MAX是stdlib.h中定义的一个整数。通常如果我们需要随机0~N-1之间的一个随机数，需要使用rand()的结果对N求模即可。选项A中，rand()%2只有两个值0或1，所以当rand()%2的结果为0时，整个表达式的值是rand()%\'A\'，这里\'A\'要转换成ASCII码值65，所以结果为0~64之间的一个随机数，当rand()%2的结果为1时，整个表达式的值是rand()%\'a\'，\'a\'的ASCII码值为97，所以结果是0~96之间的一个随机数，可见选项A错误；逻辑或运算符||或逻辑与运算符&&的结果都只能是0或非0，所以选项B、C也是错误的；选项D中，如果rand()%2的结果为0，那么整个表达式的值为rand()%26+\'A\'，0~25之间任一个数与\'A\'的和都是一个大写字母；如果rand()%2的值为1，整个表达式的值为rand()%26+\'a\'，0~25之间任一个数与\'a\'的和都是一个小写字母，所以选项D正确；本题答案为D。\n');
INSERT INTO `exercises` VALUES ('693', '有下列程序 \n　　#include <stdio.h> \n　　#include <string.h> \n　　main( ) \n　　{  char v[4][10]={\"efg\",\"abcd\",\"mnopq\",\"hijkl\"},*p[4],*t;   \n　　   int i,j; \n　　   for (i=0; i<4; i++) \n　　     p[i] = v[i]; \n　　   for (i=0; i<3; i++) \n　　     for (j=i+1; j<4; j++) \n　　       if (strcmp(p[i], p[j]) > 0) \n　　       {  t = p[i]; p[i] = p[j]; p[j] = t;  } \n　　   for (i=0; i<4; i++) \n　　      printf(\"%s \" , p[i]);  \n　　} \n程序执行后的输出结果是\n', 'efg abcd hijkl mnopq', 'abcd efg hijkl mnopq', 'mnopq hijkl efg abcd', 'efg abcd mnopq hijkl', 'B', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'main()函数中定义一个二维数组v，另外还定义一个指针数组p，通过for循环，将v的各个行（字符串的首地址）赋给p的对应下标的元素，然后通过嵌套的for循环，为该二维数组中存放的各个字符串进行排序，stcmp函数返回值大于0时（p[i]>p[j]）交换两个字符串，所以每一轮内嵌的for循环，都将下标为i的字符串放在最终的排序位置上，即排序规则是按字符串升序排列，字符串排序时，是将两个字符串自左向右逐个字符比较（按字符的ASCII码大小），直到出现不同的字符或遇到’\\0’为止，排序后，再将v中各个排序后的字符串输出；所以程序运行结果为：abcd efg hijkl mnopq，本题答案为B\n\n');
INSERT INTO `exercises` VALUES ('694', '  有以下程序\n    #include  <stdio.h>\n    int *f(int *s)\n    {  s+=2;\n       s[1] +=6;\n       *s=7;\n       return s;\n    }\n    main( )\n    {  int  a[5]={1,2,3,4,5}, *p=a;  \n       p= f(p);  \n       printf(\"%d,%d,%d,%d\", a[0], a[1], *p,p[1]); \n    }\n　　程序执行后的输出结果是（）。\n', '1,2,7,10', '7,8,7,8', '1,2,1,2', '7,10,7,10', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'f()函数接收一个数组a的首地址s，然后将s指针向后移动两个单位，此时s指向数组a的第3个元素，即3，然后将s的后一个元素累加6，s指向的元素赋值为7，并返回s指针赋给实参p，所以f()函数调用后，a数组中的元素分别为：1,2,7,10,5。执行p=f(p)后，p指向第3个元素，所以输出a[0]为1，a[1]为2，*p为7，p[1]为10，本题答案为A。\n\n\n');
INSERT INTO `exercises` VALUES ('695', ' 如图所示：带有头结点的单向链表head，其三个数据结点A、B、C 的连接关系见图。\n    \n     结点类型的定义为：\n     struct link\n     {\n         double dt;\n         struct link *next;\n     };\n    若指针p指向A结点，在不改变p指向的前提下，以下选项中不能访问C结点数据成员dt的表达式是\n', '*(*p).next->next->dt', 'p->next-> next->dt', '(*(*(*p).next).next).dt', '(*(p->next-> next)).dt', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'link结构体中的next是链表中下一个结点的地址，由于p当前指向A，所以p->next是B的地址，p->next->next是C的地址，访问C的结点数据成员dt可以使用C的地址访问，即：p->next->next->dt，选项B正确；p是A的地址，所以*p是结点A，(*p).next是B的地址，由于成员运算符.的优先级高于解引用运算符*，所以*(*p).next是结点B，(*(*p).next).next是C的地址，*(*(*p).next).next是结点C，引用C的dt成员：(*(*(*p).next).next).dt ，选项C正确；同理，也可以既使用指针运算符，也使用解引用运算符来访问C的结点数据成员dt，即(*(p->next-> next)).dt，选项D正确；选项A中，*p表示A结点，(*p).next表示结点B的地址，由于->运算符的优先级高于*运算符，所以先执行->，即表达式(*p).next->next->dt引用了C结点的数据成员dt，然后再执行解引用运算*，这是错误的，本题答案为A。\n');
INSERT INTO `exercises` VALUES ('696', '设有函数说明语句：\n  int fun(int,int);\n以及函数指针定义语句：\n  int (*f)(int,int);\n若要使函数指针指向函数fun的入口地址，以下选项中正确的是（）。\n', 'f=fun( );', '*f=fun;', 'f=fun;', '*f=fun( );', 'C', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'C语言中，函数名也是一个指针，是函数的入口地址，所以要是函数指针f指向函数fun的入口地址，直接将函数名fun赋给f即可，本题答案为C。\n');
INSERT INTO `exercises` VALUES ('697', ' 有下列程序\n     #include <stdio.h>\n     main( )\n     {  char v[4][10];  int i;\n        for (i=0; i<4; i++)\n          scanf(\"%s\", v[i]);\n        printf(\"%c,%s,%s,%c\", **v, *(v+1), v[3]+3, *(v[2]+1)); \n     }\n程序执行时若输入: welcome you to beijing<回车>，则输出结果是（）。\n', 'w,you,jing,o', 'welcome,you,jing,to', 'w,you,eeijing,u', 'w,xelcome,eeijing,u', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '题意中，定义一个二维字符数组v，然后通过for循环，输入4个字符串welcome、you、to、beijing，分别存放在v的四个元素中；所以v表示存放四个字符串的二维数组；**v表示第一个字符串的第一个字符w；*(v+1)指向第二个字符串you；v[3]+3指向第四个字符串第三个字符开始后的整个字符串jing；*(v[2]+1)表示第三个字符串的第二个字符o，本题答案为A。\n');
INSERT INTO `exercises` VALUES ('698', '以下针对相应语句的注释中，说法错误的是（）。\n', 'int *pt[2];    /*  pt是一个指针数组名   */', 'int (*pt)[2];  /*  pt是一维数组名    */', 'int (*pt)( );  /*  pt是指向函数的指针   */', 'int *pt( );    /*  pt是一个函数名   */', 'B', null, '36', '2018年3月二级《C语言》模拟试题2', null, '选项A定义一个数组pt，它包含两个整型指针的元素，所以pt是一个指针数组名，正确；选项B定义了一个数组指针pt，pt指向一个数组，该数组包含两个整型元素，错误；选项C定义了一个函数，pt是函数指针，指向这个函数，其中该函数没有参数，返回类型为整型，正确；选项D定义一个函数，函数名pt，函数返回整型指针类型，正确；本题答案为B。\n');
INSERT INTO `exercises` VALUES ('699', '若有定义\n　　　typedef  int  *(*T[10])[10];  \n　　　T  b;\n则以下选项中所定义的a与上述定义中的b，其类型完全相同的是（）。\n', 'int *(*a[10][10]);', 'int **a[10][10];', 'int *(a[10])[10];', 'int *(*a[10])[10];', 'D', null, '36', '2018年3月二级《C语言》模拟试题2', null, 'typedef int *(*T[10])[10]使用typedef定义一种新类型名T，T的类型是二维数组指针，指向10个元素的数组，其中数组元素类型为int *[10]，即数组的每个元素又是包含10个元素的数组，数组的元素是整型指针类型，本题答案为D。\n');
INSERT INTO `exercises` VALUES ('700', '  有以下程序\n    #include   <stdio.h>\n    main( )\n    {  int  x=3,y=5, z1,z2;\n       z1=x^y; z2=x+y;\n       printf(\"%d,%d\\n\", z1, z2); \n    }\n   程序执行后的输出结果是（）。\n', '9,8', '8,8', '35,8', '6,8', 'D', null, '36', '2018年3月二级《C语言》模拟试题2', null, '“^”是异或运算符，两个运算数的二进制位逐位进行异或运算，当相应位的数值相同时，结果为0，当相应位的数值不同时，结果为1；题意中，x=3，二进制位00000011，y=5，二进制为00000101，异或运算后二进制数：00000110，所以z1的结果为6；z2=x+y，结果为8；本题答案为D。\n');
INSERT INTO `exercises` VALUES ('701', '  有以下程序\n     #include<stdio.h> \n     typedef struct book\n     {\n       char name[50];\n       double price;\n     } BOOK;\n     void fun(BOOK*pd,int num,int size);\n     void main()\n     {\n       BOOK data[10]={\"photoshop\",26.8,\"计算机原理\",15.00,\"数据结构\",35.6};\n       int n=3,m=10;\n       fun(data,n,m);\n       printf(\"%s , %s\\n\",data[8].name,data[9].name);\n     }\n     void fun(BOOK*pd,int num,int size)\n     {\n       int i,j,t;\n       double mx,mn;\n       mx=mn=pd[0].price;\n       j=t=0;\n       for(i=1;i<num;i++)\n       {\n         if(pd[i].price>mx)\n         {  mx=pd[i].price;j=i;  }\n         if(pd[i].price<mn)\n         {  mn=pd[i].price;t=i;  }\n       }\n       pd[size-2]=pd[j];\n       pd[size-1]=pd[t];\n     }  \n程序的运行结果是（）。\n', '数据结构 , 计算机原理', '计算机原理 , 数据结构', 'Photoshop , 计算机原理', '数据结构 , Photoshop', 'A', null, '36', '2018年3月二级《C语言》模拟试题2', null, '程序首先使用typedef定义一种新的类型名BOOK，它包含两个数据成员：字符数组name，double类型变量price；main()函数使用BOOK定义结构体数组data，它包含10个BOOK类型的结构体元素，并完成初始化，其中前3个元素使用确定的值初始化，后7个元素系统默认值初始化；函数fun()通过for循环遍历结构体数组pd的前num个元素，从而找出前num个元素中price成员最大的元素下标存放到j，找出前num个元素中price成员最小的元素下标存放到t，然后将下标为j的元素赋给下标为size-2的位置，将下标为t的元素赋给下标为size-1的位置；由于main()函数中调用fun(data, n, m)，n值为3，m值为10，所以fun()函数将data中下标为8的元素赋值为前3个元素中price值最大的元素，将data中下标为9的元素赋值为前3个元素中price值最小的元素，调用结束后，输出下标为8和9的元素的成员name，根据初值可知price最大的元素的name成员为“数据结构”，price最小的元素的name成员为“计算机原理”，所以程序输出：数据结构，计算机原理，本题答案为A。\n');

-- ----------------------------
-- Table structure for materials
-- ----------------------------
DROP TABLE IF EXISTS `materials`;
CREATE TABLE `materials` (
  `id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `order_number` int(8) NOT NULL,
  `materials_title` varchar(255) NOT NULL,
  `file_name` varchar(255) NOT NULL,
  `creation_date` date DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of materials
-- ----------------------------
INSERT INTO `materials` VALUES ('1', '1', 'C语言教程', 'c-tutorial', '2017-10-31');
INSERT INTO `materials` VALUES ('2', '2', 'C简介', 'c-intro', '2017-10-31');
INSERT INTO `materials` VALUES ('3', '3', 'C环境设置', 'c-environment-setup', '2017-10-31');
INSERT INTO `materials` VALUES ('4', '4', 'C程序结构', 'c-program-structure', '2017-10-31');
INSERT INTO `materials` VALUES ('5', '5', 'C基本语法', 'c-basic-syntax', '2017-10-31');
INSERT INTO `materials` VALUES ('6', '6', 'C数据类型', 'c-data-types', '2017-10-31');
INSERT INTO `materials` VALUES ('7', '7', 'C变量', 'c-variables', '2017-10-31');
INSERT INTO `materials` VALUES ('8', '8', 'C常量', 'c-constants', '2017-10-31');
INSERT INTO `materials` VALUES ('9', '9', 'C存储类', 'c-storage-classes', '2017-10-31');
INSERT INTO `materials` VALUES ('10', '10', 'C运算符', 'c-operators', null);
INSERT INTO `materials` VALUES ('11', '11', 'C判断', 'c-decision', null);
INSERT INTO `materials` VALUES ('12', '12', 'C循环', 'c-loops', null);
INSERT INTO `materials` VALUES ('13', '13', 'C函数', 'c-functions', null);
INSERT INTO `materials` VALUES ('14', '14', 'C作用域规则', 'c-scope-rules', null);
INSERT INTO `materials` VALUES ('15', '15', 'C数组', 'c-arrays', null);
INSERT INTO `materials` VALUES ('16', '16', 'C指针', 'c-pointers', null);
INSERT INTO `materials` VALUES ('17', '17', 'C函数指针与回调指针', 'c-fun-pointer-callback', null);
INSERT INTO `materials` VALUES ('18', '18', 'C字符串', 'c-strings', null);
INSERT INTO `materials` VALUES ('19', '19', 'C结构体', 'c-structures', null);
INSERT INTO `materials` VALUES ('20', '20', 'C共同体', 'c-unions', null);
INSERT INTO `materials` VALUES ('21', '21', 'C位域', 'c-bit-fields', null);
INSERT INTO `materials` VALUES ('22', '22', 'C之typedef', 'c-typedef', null);
INSERT INTO `materials` VALUES ('23', '23', 'C输入输出', 'c-input-output', null);
INSERT INTO `materials` VALUES ('24', '24', 'C文件读写', 'c-file-io', null);
INSERT INTO `materials` VALUES ('25', '25', 'C预处理器', 'c-preprocessors', null);
INSERT INTO `materials` VALUES ('26', '26', 'C头文件', 'c-header-files', null);
INSERT INTO `materials` VALUES ('27', '27', 'C强制换行类型', 'c-type-casting', null);
INSERT INTO `materials` VALUES ('28', '28', 'C错误处理', 'c-error-handling', null);

-- ----------------------------
-- Table structure for mistakes
-- ----------------------------
DROP TABLE IF EXISTS `mistakes`;
CREATE TABLE `mistakes` (
  `id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `exercise_id` mediumint(8) NOT NULL,
  `username` varchar(16) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2141 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of mistakes
-- ----------------------------
INSERT INTO `mistakes` VALUES ('15', '5', 'suzelin');
INSERT INTO `mistakes` VALUES ('16', '4', 'suzelin');
INSERT INTO `mistakes` VALUES ('17', '3', 'suzelin');
INSERT INTO `mistakes` VALUES ('18', '4', 'szl');
INSERT INTO `mistakes` VALUES ('19', '5', 'szl');
INSERT INTO `mistakes` VALUES ('20', '6', 'szl');
INSERT INTO `mistakes` VALUES ('21', '7', 'szl');
INSERT INTO `mistakes` VALUES ('22', '8', 'szl');
INSERT INTO `mistakes` VALUES ('23', '9', 'szl');
INSERT INTO `mistakes` VALUES ('24', '10', 'szl');
INSERT INTO `mistakes` VALUES ('25', '34', 'szl');
INSERT INTO `mistakes` VALUES ('68', '58', 'suzelin');
INSERT INTO `mistakes` VALUES ('69', '59', 'suzelin');
INSERT INTO `mistakes` VALUES ('70', '60', 'suzelin');
INSERT INTO `mistakes` VALUES ('71', '61', 'suzelin');
INSERT INTO `mistakes` VALUES ('72', '62', 'suzelin');
INSERT INTO `mistakes` VALUES ('73', '63', 'suzelin');
INSERT INTO `mistakes` VALUES ('74', '64', 'suzelin');
INSERT INTO `mistakes` VALUES ('75', '65', 'suzelin');
INSERT INTO `mistakes` VALUES ('76', '66', 'suzelin');
INSERT INTO `mistakes` VALUES ('77', '67', 'suzelin');
INSERT INTO `mistakes` VALUES ('78', '68', 'suzelin');
INSERT INTO `mistakes` VALUES ('79', '69', 'suzelin');
INSERT INTO `mistakes` VALUES ('80', '70', 'suzelin');
INSERT INTO `mistakes` VALUES ('81', '71', 'suzelin');
INSERT INTO `mistakes` VALUES ('82', '72', 'suzelin');
INSERT INTO `mistakes` VALUES ('83', '73', 'suzelin');
INSERT INTO `mistakes` VALUES ('84', '74', 'suzelin');
INSERT INTO `mistakes` VALUES ('85', '75', 'suzelin');
INSERT INTO `mistakes` VALUES ('86', '76', 'suzelin');
INSERT INTO `mistakes` VALUES ('87', '77', 'suzelin');
INSERT INTO `mistakes` VALUES ('88', '78', 'suzelin');
INSERT INTO `mistakes` VALUES ('89', '79', 'suzelin');
INSERT INTO `mistakes` VALUES ('90', '80', 'suzelin');
INSERT INTO `mistakes` VALUES ('91', '81', 'suzelin');
INSERT INTO `mistakes` VALUES ('92', '82', 'suzelin');
INSERT INTO `mistakes` VALUES ('93', '83', 'suzelin');
INSERT INTO `mistakes` VALUES ('94', '84', 'suzelin');
INSERT INTO `mistakes` VALUES ('95', '85', 'suzelin');
INSERT INTO `mistakes` VALUES ('96', '86', 'suzelin');
INSERT INTO `mistakes` VALUES ('97', '87', 'suzelin');
INSERT INTO `mistakes` VALUES ('98', '88', 'suzelin');
INSERT INTO `mistakes` VALUES ('99', '89', 'suzelin');
INSERT INTO `mistakes` VALUES ('100', '90', 'suzelin');
INSERT INTO `mistakes` VALUES ('101', '91', 'suzelin');
INSERT INTO `mistakes` VALUES ('102', '92', 'suzelin');
INSERT INTO `mistakes` VALUES ('103', '93', 'suzelin');
INSERT INTO `mistakes` VALUES ('104', '94', 'suzelin');
INSERT INTO `mistakes` VALUES ('105', '95', 'suzelin');
INSERT INTO `mistakes` VALUES ('106', '96', 'suzelin');
INSERT INTO `mistakes` VALUES ('107', '97', 'suzelin');
INSERT INTO `mistakes` VALUES ('109', '59', 'lifengxia');
INSERT INTO `mistakes` VALUES ('110', '60', 'lifengxia');
INSERT INTO `mistakes` VALUES ('111', '61', 'lifengxia');
INSERT INTO `mistakes` VALUES ('112', '62', 'lifengxia');
INSERT INTO `mistakes` VALUES ('113', '63', 'lifengxia');
INSERT INTO `mistakes` VALUES ('114', '64', 'lifengxia');
INSERT INTO `mistakes` VALUES ('115', '65', 'lifengxia');
INSERT INTO `mistakes` VALUES ('116', '66', 'lifengxia');
INSERT INTO `mistakes` VALUES ('117', '67', 'lifengxia');
INSERT INTO `mistakes` VALUES ('118', '68', 'lifengxia');
INSERT INTO `mistakes` VALUES ('119', '69', 'lifengxia');
INSERT INTO `mistakes` VALUES ('120', '70', 'lifengxia');
INSERT INTO `mistakes` VALUES ('121', '71', 'lifengxia');
INSERT INTO `mistakes` VALUES ('122', '72', 'lifengxia');
INSERT INTO `mistakes` VALUES ('123', '73', 'lifengxia');
INSERT INTO `mistakes` VALUES ('124', '74', 'lifengxia');
INSERT INTO `mistakes` VALUES ('125', '75', 'lifengxia');
INSERT INTO `mistakes` VALUES ('126', '76', 'lifengxia');
INSERT INTO `mistakes` VALUES ('127', '77', 'lifengxia');
INSERT INTO `mistakes` VALUES ('128', '78', 'lifengxia');
INSERT INTO `mistakes` VALUES ('129', '79', 'lifengxia');
INSERT INTO `mistakes` VALUES ('130', '80', 'lifengxia');
INSERT INTO `mistakes` VALUES ('131', '81', 'lifengxia');
INSERT INTO `mistakes` VALUES ('132', '82', 'lifengxia');
INSERT INTO `mistakes` VALUES ('133', '83', 'lifengxia');
INSERT INTO `mistakes` VALUES ('134', '84', 'lifengxia');
INSERT INTO `mistakes` VALUES ('135', '85', 'lifengxia');
INSERT INTO `mistakes` VALUES ('136', '86', 'lifengxia');
INSERT INTO `mistakes` VALUES ('137', '87', 'lifengxia');
INSERT INTO `mistakes` VALUES ('138', '88', 'lifengxia');
INSERT INTO `mistakes` VALUES ('139', '89', 'lifengxia');
INSERT INTO `mistakes` VALUES ('140', '90', 'lifengxia');
INSERT INTO `mistakes` VALUES ('141', '91', 'lifengxia');
INSERT INTO `mistakes` VALUES ('142', '92', 'lifengxia');
INSERT INTO `mistakes` VALUES ('143', '93', 'lifengxia');
INSERT INTO `mistakes` VALUES ('144', '94', 'lifengxia');
INSERT INTO `mistakes` VALUES ('145', '95', 'lifengxia');
INSERT INTO `mistakes` VALUES ('146', '96', 'lifengxia');
INSERT INTO `mistakes` VALUES ('147', '97', 'lifengxia');
INSERT INTO `mistakes` VALUES ('148', '1', 'suzelin');
INSERT INTO `mistakes` VALUES ('149', '2', 'suzelin');
INSERT INTO `mistakes` VALUES ('153', '6', 'suzelin');
INSERT INTO `mistakes` VALUES ('154', '7', 'suzelin');
INSERT INTO `mistakes` VALUES ('155', '8', 'suzelin');
INSERT INTO `mistakes` VALUES ('156', '9', 'suzelin');
INSERT INTO `mistakes` VALUES ('157', '10', 'suzelin');
INSERT INTO `mistakes` VALUES ('172', '178', 'suzelin');
INSERT INTO `mistakes` VALUES ('173', '179', 'suzelin');
INSERT INTO `mistakes` VALUES ('2094', '21', 'maxiao');
INSERT INTO `mistakes` VALUES ('2095', '22', 'maxiao');
INSERT INTO `mistakes` VALUES ('2096', '23', 'maxiao');
INSERT INTO `mistakes` VALUES ('2097', '25', 'maxiao');
INSERT INTO `mistakes` VALUES ('2098', '26', 'maxiao');
INSERT INTO `mistakes` VALUES ('2099', '29', 'maxiao');
INSERT INTO `mistakes` VALUES ('2100', '30', 'maxiao');
INSERT INTO `mistakes` VALUES ('2101', '180', 'suzelin');
INSERT INTO `mistakes` VALUES ('2102', '181', 'suzelin');
INSERT INTO `mistakes` VALUES ('2103', '182', 'suzelin');
INSERT INTO `mistakes` VALUES ('2104', '183', 'suzelin');
INSERT INTO `mistakes` VALUES ('2105', '184', 'suzelin');
INSERT INTO `mistakes` VALUES ('2106', '185', 'suzelin');
INSERT INTO `mistakes` VALUES ('2107', '186', 'suzelin');
INSERT INTO `mistakes` VALUES ('2108', '187', 'suzelin');
INSERT INTO `mistakes` VALUES ('2109', '188', 'suzelin');
INSERT INTO `mistakes` VALUES ('2110', '189', 'suzelin');
INSERT INTO `mistakes` VALUES ('2111', '190', 'suzelin');
INSERT INTO `mistakes` VALUES ('2112', '191', 'suzelin');
INSERT INTO `mistakes` VALUES ('2113', '192', 'suzelin');
INSERT INTO `mistakes` VALUES ('2114', '193', 'suzelin');
INSERT INTO `mistakes` VALUES ('2115', '194', 'suzelin');
INSERT INTO `mistakes` VALUES ('2116', '195', 'suzelin');
INSERT INTO `mistakes` VALUES ('2117', '196', 'suzelin');
INSERT INTO `mistakes` VALUES ('2118', '197', 'suzelin');
INSERT INTO `mistakes` VALUES ('2119', '198', 'suzelin');
INSERT INTO `mistakes` VALUES ('2120', '199', 'suzelin');
INSERT INTO `mistakes` VALUES ('2121', '200', 'suzelin');
INSERT INTO `mistakes` VALUES ('2122', '201', 'suzelin');
INSERT INTO `mistakes` VALUES ('2123', '202', 'suzelin');
INSERT INTO `mistakes` VALUES ('2124', '203', 'suzelin');
INSERT INTO `mistakes` VALUES ('2125', '204', 'suzelin');
INSERT INTO `mistakes` VALUES ('2126', '205', 'suzelin');
INSERT INTO `mistakes` VALUES ('2127', '206', 'suzelin');
INSERT INTO `mistakes` VALUES ('2128', '207', 'suzelin');
INSERT INTO `mistakes` VALUES ('2129', '208', 'suzelin');
INSERT INTO `mistakes` VALUES ('2130', '209', 'suzelin');
INSERT INTO `mistakes` VALUES ('2131', '210', 'suzelin');
INSERT INTO `mistakes` VALUES ('2132', '211', 'suzelin');
INSERT INTO `mistakes` VALUES ('2133', '212', 'suzelin');
INSERT INTO `mistakes` VALUES ('2134', '213', 'suzelin');
INSERT INTO `mistakes` VALUES ('2135', '214', 'suzelin');
INSERT INTO `mistakes` VALUES ('2136', '215', 'suzelin');
INSERT INTO `mistakes` VALUES ('2137', '216', 'suzelin');
INSERT INTO `mistakes` VALUES ('2138', '217', 'suzelin');
INSERT INTO `mistakes` VALUES ('2139', '218', 'suzelin');
INSERT INTO `mistakes` VALUES ('2140', '219', 'suzelin');

-- ----------------------------
-- Table structure for papers
-- ----------------------------
DROP TABLE IF EXISTS `papers`;
CREATE TABLE `papers` (
  `paper_id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `paper_title` varchar(255) NOT NULL,
  `paper_type` varchar(255) NOT NULL,
  `course_id` int(11) DEFAULT NULL,
  `creation_date` date DEFAULT NULL,
  PRIMARY KEY (`paper_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=38 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of papers
-- ----------------------------
INSERT INTO `papers` VALUES ('1', '第1章_程序设计基本概念', 'chapter', '-1', '2017-11-02');
INSERT INTO `papers` VALUES ('2', '第2章_C程序设计的初步知识', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('3', '2018年3月二级《C语言》临考猜想卷', 'simulation', '-1', null);
INSERT INTO `papers` VALUES ('4', '2018年3月二级《C语言》考前猜想卷', 'simulation', '-1', null);
INSERT INTO `papers` VALUES ('5', '2018年3月二级《C语言》考前必做题', 'simulation', '-1', null);
INSERT INTO `papers` VALUES ('6', '2015年9月二级《C语言》真题及解析', 'old', '-1', null);
INSERT INTO `papers` VALUES ('7', '2015年3月二级《C语言》真题及解析', 'old', '-1', null);
INSERT INTO `papers` VALUES ('8', '2014年9月二级《C语言》真题及解析', 'old', '-1', null);
INSERT INTO `papers` VALUES ('10', '第3章_顺序结构', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('11', '第4章_选择结构', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('12', '第5章_循环结构', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('13', '第6章_字符型数据', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('14', '第7章_函数', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('15', '第8章_地址和指针', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('16', '第9章_数组', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('17', '第10章_字符串', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('18', '第11章_对函数的进一步讨论', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('19', '第12章_用户标识符', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('20', '第13章_编译预处理和动态存储分配', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('21', '第14章_结构体、共用体和用户定义类型', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('22', '第15章_位运算', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('23', '第16章_文件', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('24', '第17章_上机指导', 'chapter', '-1', null);
INSERT INTO `papers` VALUES ('25', '2018年3月二级《C语言》高频考点卷', 'simulation', '-1', null);
INSERT INTO `papers` VALUES ('26', '2018年3月二级《C语言》冲刺提分卷', 'simulation', '-1', null);
INSERT INTO `papers` VALUES ('27', '2018年3月二级《C语言》题库试题', 'simulation', '-1', null);
INSERT INTO `papers` VALUES ('28', '2014年3月二级《C语言》真题及解析', 'old', '-1', null);
INSERT INTO `papers` VALUES ('29', '第1章_程序设计基本概念', 'upload', '1', null);
INSERT INTO `papers` VALUES ('30', '第2章_C程序设计的初步知识', 'upload', '1', null);
INSERT INTO `papers` VALUES ('31', '2012年3月二级《C语言》真题及解析', 'old', '-1', null);
INSERT INTO `papers` VALUES ('32', '2018年3月二级《C语言》题库试题', 'simulation', '-1', null);
INSERT INTO `papers` VALUES ('34', '第一章 C语言程序设计概述1', 'upload', '2', null);
INSERT INTO `papers` VALUES ('35', '2018年3月二级《C语言》模拟试题1', 'simulation', '-1', null);
INSERT INTO `papers` VALUES ('36', '2018年3月二级《C语言》模拟试题2', 'simulation', '-1', null);
INSERT INTO `papers` VALUES ('37', '2018年3月二级《C语言》模拟试题3', 'simulation', '-1', null);

-- ----------------------------
-- Table structure for program
-- ----------------------------
DROP TABLE IF EXISTS `program`;
CREATE TABLE `program` (
  `program_id` int(11) NOT NULL AUTO_INCREMENT,
  `program_title` varchar(1023) DEFAULT NULL,
  `program_code` varchar(4095) DEFAULT NULL,
  `program_answer` varchar(1023) DEFAULT NULL,
  `program_analysis` varchar(1023) DEFAULT NULL,
  `program_type` int(11) DEFAULT NULL,
  `paper_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`program_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of program
-- ----------------------------
INSERT INTO `program` VALUES ('1', '程序通过定义学生结构体变量， 存储了学生的学号、 姓名和三门课的成绩。 所有 学生数据均以二进制方式输出到文件中。函数 fun 的功能是重写形参 filename 所指文件中最后一个学生的数据， 即用新的学生数据覆盖该学生原来的数据， 其 他学生的数据不变。 请在程序的下画线处填入正确的内容并把下画线删除，使程序得出正确的结果。 注意：部分源程序在文件 BLANK1.C中。 不得增行或删行，也不得更改程序的结构！', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n', '(1)filename (2)fp (3)fp', '填空 1：本空是对文本文件的打开， filename 所指的文件中的最后数据要进行重 写，因此首先是要打开，因而本空填写 filename 。 \r\n填空 2：fseek 功能是重定位流上的文件指针。用 法： int fseek(FILE *stream, long offset, int fromwhere) ；本空 应该填写 fp 。 \r\n填空 3：因为题目中要对所有学生数据均以二进制方式输出到文件中，因此本空 填写 fp 。 知识点讲解： 函数名： fseek 功 能：重定位流上的文件指针。 用 法：int fseek(FILE *stream, long offset, int fromwhere) 。 描 述：函数设置文件指针 stream 的位置。如果执行成功， stream 将指向以 fromwhere 为基准，偏移 offset 个字节的位置。如果执行失败 ( 比如 offset 超 过文件自身大小 )，则不改变 stream 指向的位置。 返回值：成功，返回 0；否则返回非 0 值。\r\n', '1', '3');
INSERT INTO `program` VALUES ('2', '下列给定程序中函数 Creatlink 的功能是：创建带头结点的单向链表， 并为各结 点数据域赋 0 到 m-1的值。 请改正函数 Creatlink 中指定部位的错误，使它能得出正确的结果。 注意：部分源程序在文件 MODI1.C中, 不要改动 main 函数，不得增行或删行， 也 不得更改程序的结构！ ', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}', '（1）p=(NODE *)malloc(sizeof(NODE)); （2）return h;', '（1）由变量定义可知 p 为指向结点的指针。指向刚分配的结构指针，所以应改为 p＝(NODE *)malloc(sizeof(NODE)) 。 \r\n（2）在动态分配内存的下一行语句是，使用临时结构指针变量 h 保存 p 指针的 初始位置，最后返回不能使用 p，是因为 p 的位置已经发生了变化，所以应改为 return h。', '2', '3');
INSERT INTO `program` VALUES ('3', '请编写函数 fun ，该函数的功能是：统计一行字符串中单词的个数，作为函数值 返回。字符串在主函数中输入， 规定所有单词由小写字母组成， 单词之间有若干 个空格隔开，一行的开始没有空格。 注意：部分源程序在文件 PROG1.C中。 请勿改动 main 函数和其他函数中的任何内容，仅在函数 fun 的花括号中填入所 编写的若干语句。', '#include<string.h> \r\n#include<stdio.h> \r\n#define N 80 \r\nint fun(char *s) \r\n{ \r\n} \r\nvoid main() \r\n{ \r\n	FILE *wf; \r\n	char line[N]; \r\n	int num=0; \r\n	printf(\"Enter a string:\\n \"); \r\n	gets(line); \r\n	num=fun(line); \r\n	printf(\"The number of word is:%d\\n\\n \",num); \r\n/******************************/ \r\n	wf=fopen(\"out.dat\",\"w\"); \r\n	fprintf(wf,\"%d\",fun(\"a big car\")); \r\n	fclose(wf); \r\n/*****************************/ \r\n}', 'int fun(char *s) { \r\n	int i,j=0; \r\n	for(i=0;s[i]!=\'\\0\';i++) \r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\')) /* 如果一个字母的下一个字符为空格或者结束标记， 则表示一个单词结束*/ \r\n			j++; \r\n	return j; /* 返回单词个数 */ \r\n}', '要判断单词的个数， 首先想到的是程序怎样识别出一个单词， 如果一个字母的下 一个字符为空格或者结束标记， 则表示一个单词结束， 因此程序使用 for 循环语 句遍历整个字符串，用 if 条件语句判断当前字符是否表示一个单词的结束，如 果当前字符表示一个单词结束，则存放单词个数的变量加 1，最后返回单词的个 数', '3', '3');
INSERT INTO `program` VALUES ('4', '给定程序中，函数fun 的功能是：计算形参	x 所指数组中 N 个数的平均值 ( 规定所有数均为正数 ) ，作为函数值返回，并将大于平均值的数放在形参y 所指数组中，在主函数中输出。\r\n例如，有 10 个正数： 46、30、32、 40、6、17、45、15、48、 26，其平均值为30.500000 。主函数中输出： 46	32	40	45	48。\r\n请在程序的下画线处填入正确的内容并把下画线删除，使程序得出正确的结果。\r\n注意：部分源程序在文件	BLANK1.C中。\r\n不得增行或删行，也不得更改程序的结构！', '#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\n#define	N	10\r\n\r\ndouble fun(double x[],double *y)\r\n{ \r\n	int i,j; double av; \r\n	/**********found**********/\r\n	av=__1__; \r\n	/**********found**********/\r\n	for(i=0; i<N; i++) \r\n		av=av+__2__;\r\n	for(i=j=0; i<N; i++) \r\n		/**********found**********/\r\n		if(x[i]>av) y[__3__]= x[i]; \r\n	y[j]=-1;\r\n	return av;\r\n}\r\n\r\nvoid main()\r\n{\r\n	int i;	double x[N],y[N];\r\n	for(i=0; i<N; i++){ x[i]=rand()%50; printf(\"%4.0f \",x[i]);} \r\n	printf(\"\\n\");\r\n	printf(\"\\nThe average is: %f\\n\",fun(x,y));\r\n	for(i=0; y[i]>=0; i++) printf(\"%5.1f \",y[i]);\r\n	printf(\"\\n\");\r\n}', '（ 1） 0.0	（ 2）x[i]/N	（3）j++', '填空 1：通过读上面的程序可以看出此空考的是给变量赋初值，av 代表的是平均值，因此 av 的初值应该是  0.0 。\r\n填空 2：通过 for  循环可知，此空代表求平均值，因此应该填写x[i]/N。\r\n填空 3：先把大于平均值的数放在形参y 所指数组中，然后使下标值加	1，因此此空应该填 j++ 。\r\n', '1', '4');
INSERT INTO `program` VALUES ('5', '下列给定程序中，函数fun 的功能是：根据整型参数m，计算如下公式的值。\r\n例如，若 m＝2000，则应输出  0.000160 。\r\n请改正程序中的错误，使它能得出正确的结果。\r\n注意：部分源程序在文件 MODI1.C中, 不要改动 main 函数，不得增行或删行， 也不得更改程序的结构！\r\n', '#include	<stdlib.h>\r\n#include	<conio.h>\r\n#include	<stdio.h>\r\n\r\n/*************found**************/\r\nfun (int m)\r\n{ \r\n	double y=0, d; int i;\r\n/*************found**************/\r\n	for(i=100,i<=m,i+=100)\r\n	{\r\n		d=(double)i*(double)i;\r\n		y+=1.0/d;\r\n	}\r\n	return(y);\r\n}\r\n\r\nvoid main()\r\n{ \r\n	int n=2000; \r\n	system(\"CLS\");\r\n	printf(\"\\nThe result is %1f\\n\",fun(n));\r\n}', '(1)double	fun(int	m)\r\n(2)for(i=100;i<=m;i+=100)', '(1)题目要求在函数 fun 中求级数前 m项和，可用循环语句，每次计算级数中的一项，然后累加。第一处错误在于定义fun(int m)，由函数的返回值可知应该定义为 double	fun(int	m)。\r\n(2)for(i为 for(＝100，i<=m，i+=100) 中是一个简单的语法错误。 for 表达式 1；表达式 2；表达式 3) ，其表达式之间应以循环语句的形式\" ； \" 相隔。', '2', '4');
INSERT INTO `program` VALUES ('6', '已知学生的记录由学号和学习成绩构成， N名学生的数据已存入 a 结构体数组中。请编写函数 fun ，该函数的功能是：找出成绩最低的学生记录，通过形参返回主函数 ( 规定只有一个最低分 ) 。已给出函数的首部，请完成该函数。\r\n注意：部分源程序在文件	PROG1.C中。请勿改动主函数 main 和其他函数中的任何内容，仅在函数 fun 的花括号中填入你编写的若干语句。', '#include<stdio.h>\r\n#include<string.h>\r\n#include<conio.h>\r\n#include<stdlib.h>\r\n\r\n#define N 10\r\n\r\ntypedef struct ss\r\n{ \r\n	char num[10]; \r\n	int s;\r\n} STU;\r\n\r\nvoid fun(STU a[], STU *s)\r\n{\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	STU a[N]={{	\"A01\",81},{	\"A02\",89},{	\"A03\",66},{	\"A04\",87},{	\"A05\",77},\r\n		{ \"A06\",90},{ \"A07\",79},{ \"A08\",61},{ \"A09\",80},{ \"A10\",71}},m; \r\n	int i;\r\n	system(\"CLS\");\r\n	printf(\"*****The original data*****\\n\");\r\n	for(i=0;i<N;i++)\r\n		printf(\"No=%s Mark=%d\\n\", a[i].num,a[i].s);\r\n	fun(a,&m);\r\n	printf(\"*****THE RESULT*****\\n\");\r\n	printf(\"The lowest :%s, %d\\n\",m.num,m.s);\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%s, %d\",m.num,m.s);\r\n	fclose(wf);\r\n/*****************************/\r\n}', 'fun(STU	a[],STU	*s)\r\n{\r\n    int i;\r\n    *s=a[0]; /* 先认为第 1 个值最小 */\r\n    for(i=0;i<N;i++) /* 如果在循环的过程中再发现比第	1 个值更小的则赋给 *s*/\r\n    if(s->s>a[i].s)\r\n    *s=a[i];\r\n}', '找出结构体数组元素中的最小值。先认为第 1 个值最小，即 *s ＝ a[0] ；，如果在循环的过程中发现比第 1 个值更小的，就将指针 s 指向该元素，直到找到最小元素。另外，本题还涉及结构体中的指向运算符，请考生注意。', '3', '4');
INSERT INTO `program` VALUES ('7', '给定程序中，函数 fun 的功能是：计算 x 所指数组中 N 个数的平均值 ( 规定所有数均为正数 ) ，平均值通过形参返回给主函数，将小于平均值且最接近平均值的数作为函数值返回，并在主函数中输出。\r\n例如，有 10 个正数：46、30、32、40、6、17、45、15、48、26，平均值为 30.500000 。主函数中输出  m＝30。\r\n请在程序的下画线处填入正确的内容并把下画线删除，使程序得出正确的结果。\r\n注意：部分源程序在文件	BLANK1.C中。不得增行或删行，也不得更改程序的结构！', '#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\n#define	N	10\r\n\r\ndouble fun(double x[],double *av)\r\n{ \r\n	int i,j; double d,s; s=0;\r\n	for(i=0; i<N; i++) \r\n		s = s +x[i];\r\n/**********found**********/\r\n	__1__=s/N;\r\n	d=32767;\r\n	for(i=0; i<N; i++)\r\n		if(x[i]<*av && *av - x[i]<=d)\r\n		{\r\n			/**********found**********/\r\n			d=*av-x[i];\r\n			j=__2__;\r\n		}\r\n/**********found**********/\r\n	return __3__;\r\n\r\n}\r\n\r\nvoid main()\r\n{ \r\n	int i;	\r\n	double x[N],av,m;\r\n	for(i=0; i<N; i++)\r\n	{\r\n		x[i]=rand()%50; \r\n		printf(\"%4.0f \",x[i]);\r\n	}\r\n	printf(\"\\n\");\r\n	m=fun(x,&av);\r\n	printf(\"\\nThe average is: %f\\n\",av);\r\n	printf(\"m=%5.1f \",m);\r\n	printf(\"\\n\");\r\n}', '(1)*av	(2)i	(3)x[j]', '填空 1：从原程序中可以看出 *av 代表的是平均值，而 s/N 表示的就是平均值，因此本空应该填 *av 。\r\n填空 2：if语句来判断找最接近平均值的数，因而此空应该填i 。\r\n填空 3：题目要求将小于平均值且最接近平均值的数作为函数返回，而j 表达的是最接近平均值的数在数组中的下标，因而本空应该填写x[j]。', '1', '5');
INSERT INTO `program` VALUES ('8', '下列给定程序中，函数fun 的功能是：根据整型形参n，计算如下公式的值。例如，若 n＝10，则应输出  0.617977 。\r\n请改正程序中的错误，使它能得出正确的结果。\r\n注意：部分源程序在文件 MODI1.C中, 不要改动 main 函数，不得增行或删行， 也不得更改程序的结构！', '#include <stdlib.h>\r\n#include <conio.h>\r\n#include <stdio.h>\r\n\r\n/*************found**************/\r\nint fun(int n)\r\n{ \r\n	float A=1;int i; \r\n	/*************found**************/\r\n	for(i=2;i<n;i++)\r\n		A=1.0/(1+A); \r\n	return A;\r\n}\r\n\r\nvoid main() \r\n{ \r\n	int n;\r\n	system(\"CLS\");\r\n	printf(\"\\nPlease enter n: \");\r\n	scanf(\"%d\",&n);\r\n	printf(\"A%d=%lf\\n\",n,fun(n));\r\n}', '(1)float	fun(int	n)\r\n(2)for(i=2;i<=n;i++)', '(1)根据函数的返回值可知，函数应定义为 float 型。\r\n(2)该题中函数 fun 的作用是计算数列前n 项的和，而数列的组成方式是：第n项的分母是 1 加第 n－1 项的值，分子为1，如果循环累加按	for(i＝ 2； i<n ；i＋＋) 执行，当输入 n＝ 2 时循环不会执行， 程序将得不到想要的结果， 因此循环变量的取值范围应包括 2。', '2', '5');
INSERT INTO `program` VALUES ('9', '下列程序定义了	N×N的二维数组，并在主函数中自动赋值。请编写函数fun(int	a[][N] ，int	m)，该函数的功能是使数组右上半三角元素中的值乘以m。\r\n例如，若 m的值为 2，a 数组中的值为：\r\n则返回主程序后	a 数组中的值应为：\r\n注意：部分源程序在文件	PROG1.C中。\r\n请勿改动主函数	main 和其他函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句。', '#include <conio.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#define N 5\r\n\r\nvoid fun(int a[][N], int m)\r\n{\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n	int a[N][N],m, i, j;\r\n	FILE *out;\r\n	printf(\"*****The array*****\\n\");\r\n	for(i=0;i<N;i++)\r\n	{ \r\n		for(j=0;j<N;j++)\r\n		{\r\n			a[i][j]=rand()%20;\r\n			printf(\"%4d\", a[i][j]);\r\n		}\r\n		printf(\"\\n\");\r\n	}\r\n	m=rand()%4;\r\n	printf(\"m=%4d\\n\",m);\r\n	fun(a,m);\r\n	printf(\"THE RESULT\\n\");\r\n	for(i=0;i<N;i++)\r\n	{ \r\n		for(j=0;j<N;j++)\r\n			printf(\"%4d\",a[i][j]);\r\n		printf(\"\\n\");\r\n	}\r\n/******************************/\r\n	out=fopen(\"out.dat\",\"w\");\r\n	for(i=0;i<N;i++)\r\n		for(j=0;j<N;j++)\r\n			a[i][j]=i*j;\r\n	fun(a,8);\r\n	for(i=0;i<N;i++)\r\n	{\r\n		for(j=0;j<N;j++)\r\n			fprintf(out,\"%4d\",a[i][j]);\r\n		fprintf(out,\"\\n\");\r\n	}\r\n	fclose(out);\r\n/******************************/\r\n}', 'void fun(int a[][N], int m)\r\n{\r\n    int i,j;\r\n    for(j=0;j<N;j++)\r\n        for(i=0;i<=j;i++)\r\n            a[i][j]=a[i][j]*m; /* 右上半三角元素中的值乘以m*/\r\n}', '本程序实现将矩阵中右上半三角元素中的值乘以 m，使用循环语句遍历数组元素，第 1 个循环用于控制行坐标，第 2 个循环用于控制列下标。', '3', '5');
INSERT INTO `program` VALUES ('10', '给定程序中，函数 fun 的功能是：计算形参 x 所指数组中 N 个数的平均值 ( 规定所有数均为正数 ) ，将所指数组中大于平均值的数据移至数组的前部，小于等于平均值的数据移至 x 所指数组的后部， 平均值作为函数值返回， 在主函数中输出平均值和移动后的数据。\r\n例如，有 10 个正数：46、30、32、40、6、17、45、15、48、26，平均值为 30.500000 。\r\n移动后的输出为： 46、32、40、 45、48、30、 6、 17、15、 26。\r\n请在程序的下画线处填入正确的内容并把下画线删除，使程序得出正确的结果。\r\n注意：部分源程序在文件	BLANK1.C中。不得增行或删行，也不得更改程序的结构！', '#include	<stdlib.h>\r\n#include	<stdio.h>\r\n\r\n#define	N	10\r\n\r\ndouble fun(double	*x)\r\n{ \r\n	int	i, j;\r\n	double	s, av, y[N];\r\n	s=0;\r\n	for(i=0; i<N; i++)	\r\n		s=s+x[i];\r\n/**********found**********/\r\n	av=__1__;\r\n	for(i=j=0; i<N; i++)\r\n		if( x[i]>av )\r\n		{\r\n/**********found**********/\r\n			y[__2__]=x[i];\r\n			x[i]=-1;\r\n		}\r\n	for(i=0; i<N; i++)\r\n/**********found**********/\r\n		if( x[i]!= __3__)\r\n			y[j++]=x[i];\r\n	for(i=0; i<N; i++)\r\n		x[i] = y[i];\r\nreturn	av;\r\n}\r\n\r\nvoid main()\r\n{ \r\n	int	i;\r\n	double	x[N];\r\n	for(i=0; i<N; i++)\r\n	{\r\n		x[i]=rand()%50; \r\n		printf(\"%4.0f \",x[i]);\r\n	}\r\n	printf(\"\\n\");\r\n	printf(\"\\nThe average is: %f\\n\",fun(x));\r\n	printf(\"\\nThe result :\\n\",fun(x));\r\n	for(i=0; i<N; i++)	\r\n		printf(\"%5.0f \",x[i]);\r\n	printf(\"\\n\");\r\n}', '(1)s/N	(2)j++	(3)-1', '填空 1：由原程序可知， av 代表的是平均值， 而平均值的求法是所有数的总和除以数的个数，因而本空应该填写s/N 。\r\n填空 2：y 数组代表暂时存放x 数组，if(x[i]>av)表达的是当 x 数组中的数大于平均值时，应该把这些大于平均值的数放在	y 数组的前半部分， 因而此空应该填y[j++]。\r\n填空 3：此空表明当 x[i]	不等于什么时， x[i]中的数要赋值给y 数组，由题意可知此空只能填写 -1 。', '1', '25');
INSERT INTO `program` VALUES ('11', '下列给定程序的功能是： 读入一个英文文本行， 将其中每个单词的第一个字母改成大写，然后输出此文本行 ( 这里 \" 单词 \" 是指由空格隔开的字符串 ) 。\r\n例如，若输入 \"I	am a student to take the examination\"  ，则应输出\"I Am  A Student To Take The Examination\"。\r\n请改正程序中的错误，使程序能得出正确的结果。\r\n注意：部分源程序在文件 MODI1.C中, 不要改动 main 函数，不得增行或删行， 也不得更改程序的结构！', '#include <stdlib.h>\r\n#include <string.h>\r\n#include <conio.h>\r\n#include <ctype.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n/*************found**************/\r\nvoid upfst(char p)\r\n{\r\n	int k=0;\r\n	for ( ;*p;p++)\r\n		if (k)\r\n		{\r\n			if (*p==\' \')\r\n				k=0;\r\n		}\r\n		else\r\n		{\r\n			if (*p!=\' \')\r\n			{\r\n				k=1;\r\n				*p=toupper(*p);\r\n			}\r\n		}\r\n}\r\n\r\nvoid main()\r\n{\r\n	char chrstr[81];\r\n	system(\"CLS\");\r\n	printf(\"\\nPlease enter an English text line: \");\r\n	gets(chrstr);\r\n	printf(\"\\nBofore changing:\\n %s\",chrstr);\r\n	upfst(chrstr);\r\n	printf(\"\\nAfter changing:\\n %s\\n\",chrstr);\r\n}\r\n', 'void upfst(char *p)', '主函数中 fun 函数的调用方式说明函数 fun 的参数应为指针类型。', '2', '25');
INSERT INTO `program` VALUES ('12', '下列程序定义了	N×N的二维数组，并在主函数中赋值。请编写函数fun ，函数的功能是：求出数组周边元素的平均值并作为函数值返回给主函数中的 s。例如，若 a 数组中的值为：则返回主程序后s 的值应为 3.375 。\r\n注意：部分源程序在文件	PROG1.C中。\r\n请勿改动主函数	main 和其他函数中的任何内容，仅在函数fun的花括号中填入所编写的若干语句。', '#include<stdio.h>\r\n#include<conio.h>\r\n#include<stdlib.h>\r\n\r\n#define N 5\r\n\r\ndouble fun (int w[][N])\r\n{\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	int a[N][N]={0,1,2,7,9,1,9,7,4,5,2,3,8,3,1,4,5,6,8,2,5,9,1,4,1}; \r\n	int i, j;\r\n	double s;\r\n	system(\"CLS\");\r\n	printf(\"*****The array*****\\n \");\r\n	for (i=0; i<N; i++)\r\n	{\r\n		for (j=0;j<N;j++) \r\n		{\r\n			printf(\"%4d \",a[i][j]);\r\n		}\r\n		printf(\"\\n \");\r\n	}\r\n	s=fun(a);\r\n	printf(\"*****THE RESULT*****\\n \");\r\n	printf(\"The sum is : %lf\\n \",s);\r\n	/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf (wf,\"%lf\",s);\r\n	fclose(wf);\r\n	/*****************************/\r\n}', 'double fun (int w[][N])\r\n{\r\n    int i,j,k=0;\r\n    double sum=0.0;\r\n    for(i=0;i<N;i++)\r\n        for(j=0;j<N;j++)\r\n            if(i==0||i==N-1||j==0||j==N-1) /* 只要下标中有一个为 0 或 N-1，则它一定是周边元素  */\r\n            {\r\n                sum=sum+w[i][j]; /* 将周边元素求和 */\r\n                k++;\r\n            }\r\n    return sum/k; /* 求周边元素的平均值 */\r\n}', '本题要求计算二维数组周边元素的平均值， for 循环语句控制循环过程， if 条件语句根据数组元素的下标判断该元素是否为二维数组的周边元素。\r\n本题采用逐一判断的方式，周边元素的规律为下标中有一个是 0 或 N-1，所以只要下标中有一个为 0 或 N-1，那么它一定是周边元素。计算周边元素个数的方式是当给 sum累加一个值时， k 也加 1。', '3', '25');
INSERT INTO `program` VALUES ('13', '给定程序中，函数 fun 的功能是：计算形参 x 所指数组中 N 个数的平均值 ( 规定所有数均为正数 ) ，将所指数组中小于平均值的数据移至数组的前部，大于等于平均值的数据移至 x 所指数组的后部， 平均值作为函数值返回， 在主函数中输出平均值和移动后的数据。\r\n例如，有 10 个正数： 47、30、32、 40、6、17、45、15、48、 26，其平均值为30.500000 。移动后的输出为： 30、6、17、15、 26、47、32、 40、45、 48。\r\n请在程序的下画线处填入正确的内容并把下画线删除，使程序得出正确的结果。\r\n注意：部分源程序在文件	BLANK1.C中。不得增行或删行，也不得更改程序的结构！', '#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\n#define	N	10\r\n\r\ndouble fun(double *x)\r\n{\r\n	int i, j;\r\n	double av, y[N];\r\n	av=0;\r\n	for(i=0; i<N; i++)\r\n/**********found**********/\r\n		av+=__1__;\r\n	for(i=j=0; i<N; i++)\r\n		if( x[i]<av )\r\n		{\r\n			y[j]=x[i];\r\n			x[i]=-1;\r\n/**********found**********/\r\n			__2__;\r\n		}\r\n	i=0;\r\n	while(i<N)\r\n	{\r\n		if( x[i]!= -1 ) \r\n			y[j++]=x[i]; \r\n		/**********found**********/\r\n		__3__;\r\n	}\r\n	for(i=0; i<N; i++)\r\n		x[i] = y[i];\r\n	return av;\r\n}\r\n\r\nvoid main()\r\n{ \r\n	int i;	\r\n	double x[N];\r\n	for(i=0; i<N; i++)\r\n	{\r\n		x[i]=rand()%50;\r\n		printf(\"%4.0f \",x[i]);\r\n	}\r\n	printf(\"\\n\");\r\n	printf(\"\\nThe average is: %f\\n\",fun(x));\r\n	printf(\"\\nThe result :\\n\",fun(x));\r\n	for(i=0; i<N; i++) \r\n		printf(\"%5.0f \",x[i]);\r\n	printf(\"\\n\");\r\n}', '(1)x[i]/N    (2)j++或++j    (3)i++或++i', '填空 1：av 代表平均值，本题考查了怎样求平均值，因此本空应该填写	x[i]/N	。\r\n填空 2：通过 for  循环和 if判断找到 x[i]中比平均值小的数，并把这些值赋值给 y[j]	，因此本空应该填写j++ 或者 ++j 。\r\n填空 3：通过 while  循环语句，把 x[i]中比平均值大的数放在数组y 的后半部分，因此本空应该填写i++ 或者 ++i 。', '1', '26');
INSERT INTO `program` VALUES ('14', '下列给定函数中， 函数 fun 的功能是：统计字符串中各元音字母 ( 即 A、E、I 、O、U)的个数。注意：字母不分大小写。\r\n例如，输入 \"THIs is a boot\" ，则应输出是  1 0 2 2 0。\r\n请改正程序中的错误，使它能得出正确的结果。\r\n注意：部分源程序在文件 MODI1.C中, 不要改动 main 函数，不得增行或删行， 也不得更改程序的结构！', '#include <stdlib.h>\r\n#include <conio.h>\r\n#include <stdio.h>\r\n\r\n/*************found**************/\r\nfun(char *s, int num[5])\r\n{\r\n	int k, i=5; \r\n	for(k=0;k<i;k++)\r\n/*************found**************/\r\n		num[i]=0;\r\n	for(;*s;s++)\r\n	{\r\n		i=-1; /*************found**************/\r\n		switch(s)\r\n		{\r\n		case \'a\': \r\n		case\'A\':{i=0;break;} \r\n		case \'e\': \r\n		case \'E\':{i=1;break;} \r\n		case \'i\': \r\n		case \'I\':{i=2;break;} \r\n		case \'o\': \r\n		case \'O\':{i=3;break;} \r\n		case \'u\': \r\n		case \'U\':{i=4;break;}\r\n		}\r\n		if(i>=0)\r\n			num[i]++;\r\n	}\r\n}\r\n\r\nvoid main()\r\n{ \r\n	char s1[81]; \r\n	int num1[5], i;\r\n	system(\"CLS\"); \r\n	printf(\"\\nPlease enter a string: \");\r\n	gets(s1);\r\n	fun(s1, num1);\r\n	for(i=0;i<5;i++)\r\n		printf(\"%d \",num1[i]);\r\n	printf(\"\\n\");\r\n}', '(1)void	fun(char *s, int num[5])    (2)num[k]=0;', 'switch  语句说明如下：\r\n(1)switch后的表达式，可以是整型或字符型， 也可以是枚举类型。 在新的 ANSIC标准中允许表达式的类型为任何类型。\r\n(2) 每个 case 后的常量表达式只能是由常量组成的表达式，当switch后的表达式的值与某一个常量表达式的值一致时，程序就转到此  case 后的语句开始执行。如果没有一个常量表达式的值与switch  后的值一致，就执行 default后的语句。\r\n(3) 各个 case 后的常量表达式的值必须互不相同。\r\n(4) 各个 case 的次序不影响执行结果，一般情况下，尽量将出现概率大的case放在前面。\r\n(5) 在执行完一个行，因而必须使用case 后面的语句后，程序会转到下一个break 语句才能跳出。', '2', '26');
INSERT INTO `program` VALUES ('15', '请编写函数 fun ，该函数的功能是：求出二维数组周边元素之和，作为函数值返回。二维数组中的值在主函数中赋予。\r\n例如，若二维数组中的值为：则函数值为 61。\r\n注意：部分源程序在文件	PROG1.C中。\r\n请勿改主动函数	main 和其他函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句。', '#include<conio.h>\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n\r\n#define M 4\r\n#define N 5\r\n\r\nint fun( int a [M][N])\r\n{\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	int aa[M][N]={{1,3,5,7,9},{2,9,9,9,4},{6,9,9,9,8},{1,3,5,7,0}};\r\n	int i, j, y;\r\n	system(\"CLS\");\r\n	printf (\"The original data is :\\n \");\r\n	for(i=0; i<M;i++)\r\n	{\r\n		for (j=0; j<N;j++)\r\n			printf(\"%6d \",aa[i][j]);\r\n		printf(\"\\n \");\r\n	}\r\n	y=fun(aa);\r\n	printf(\"\\nThe sun: %d\\n \",y);\r\n	printf(\"\\n \");\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf (wf,\"%d\",y);\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', 'int fun(int a[M][N])\r\n{\r\n    int i,j,sum=0;\r\n    for(i=0;i<M;i++)\r\n        for(j=0;j<N;j++)\r\n            if(i==0||i==M-1||j==0||j==N-1) /* 只要下标中有一个为0 或M-1 或 N-1，则它一定是周边元素  */\r\n                sum=sum+a[i][j]; /* 将周边元素相加 */\r\n    return sum;\r\n}', '本题采用逐一判断的方式，周边元素的规律是，其下标值中一定有一个是0 或 M－1 或 N－1。程序中循环语句用来控制数组的行和列， 条件语句用来判断数组元素是否为周边元素。', '3', '26');
INSERT INTO `program` VALUES ('16', '给定程序中，函数 fun 的功能是将 a 和 b 所指的两个字符串分别转换成面值相同的整数，并进行相加作为函数值返回，规定字符串中只含 9 个以下数字字符。例如，主函数中输入字符串 \"32486\" 和\"12345\" ，在主函数中输出的函数值为44831。\r\n请在程序的下画线处填入正确的内容并把下画线删除，使程序得出正确的结果。\r\n注意：部分源程序在文件	BLANK1.C中。不得增行或删行，也不得更改程序的结构', '#include <stdio.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n\r\n#define N 9\r\n\r\nlong ctod( char *s )\r\n{ \r\n	long d=0;\r\n	while(*s)\r\n		if(isdigit( *s)) \r\n		{\r\n/**********found**********/\r\n			d=d*10+*s-__1__;\r\n/**********found**********/\r\n			__2__;\r\n		}\r\n	return d;\r\n}\r\n\r\nlong fun( char *a, char *b )\r\n{\r\n\r\n/**********found**********/\r\n	return __3__;\r\n}\r\n\r\nvoid main()\r\n{\r\n	char s1[N],s2[N]; \r\n	do\r\n	{ \r\n		printf(\"Input string s1 : \"); \r\n		gets(s1); \r\n	} \r\n	while( strlen(s1)>N );\r\n	do\r\n	{\r\n		printf(\"Input string s2 : \"); \r\n		gets(s2); \r\n	} \r\n	while( strlen(s2)>N );\r\n	printf(\"The result is: %ld\\n\", fun(s1,s2) );\r\n}', '(1)\'0\'    (2)s++ 或 ++s    (3)ctod(a)+ctod(b)', '填空 1：isdigt(*s)	这个函数表示检查 *s 是否是数字 (0 ～ 9) ，d＝d*10 ＋*s- ？表示的是要把字符串分别转换成面值相同的整数，因此本空应该填写	\'0\'  。\r\n填空 2：*s 所代表的字符串中字符需要一个一个的字符进行转换成整数， 因此此空应该填写 s++或++s。\r\n填空 3：题目要求把转换后的字符进行相加后作为函数的返回值，因此本空应该填写 ctod(a) ＋ctod(b) 。', '1', '27');
INSERT INTO `program` VALUES ('17', '下列给定程序是建立一个带头结点的单向链表，并用随机函数为各结点赋值。 函数fun 的功能是将单向链表结点 ( 不包括头结点 ) 数据域为偶数的值累加起来， 并且作为函数值返回。\r\n请改正函数 fun 中的错误，使它能得出正确的结果。\r\n注意：部分源程序在文件 MODI1.C中, 不要改动 main 函数，不得增行或删行， 也不得更改程序的结构！', '#include <stdio.h>\r\n#include <conio.h>\r\n#include <stdlib.h>\r\n\r\ntypedef struct aa\r\n{ \r\n	int data; \r\n	struct aa *next;\r\n} NODE;\r\n\r\nint fun (NODE *h)\r\n{\r\n	int max=-1;\r\n	NODE *p;\r\n/*************found**************/\r\n	p=h;\r\n	while(p)\r\n	{ \r\n		if(p->data>max) \r\n			max=p->data;\r\n/*************found**************/\r\n		p=h->next;\r\n	}\r\n	return max;\r\n}\r\n\r\nvoid outresult(int s, FILE *pf)\r\n{\r\n	fprintf(pf, \"\\nThe max in link :%d\\n\",s);\r\n}\r\n\r\nNODE *creatlink(int n, int m)\r\n{\r\n	NODE *h,*p,*s;\r\n	int i;\r\n	h=p=(NODE *)malloc(sizeof(NODE));\r\n	h->data=9999;\r\n	for(i=1;i<=n;i++)\r\n	{\r\n		s=(NODE *) malloc(sizeof(NODE));\r\n		s->data=rand()%m; s->next=p->next;\r\n		p->next=s; \r\n		p=p->next;\r\n	}\r\n	p->next=NULL;\r\n	return h;\r\n}\r\n\r\nvoid outlink(NODE *h,FILE *pf)\r\n{\r\n	NODE *p; p=h->next;\r\n	fprintf(pf, \"\\n The LIST :\\n\\n HEAD\");\r\n	while(p)\r\n	{\r\n		fprintf(pf, \"->%d\",p->data);\r\n		p=p->next;\r\n	}\r\n	fprintf(pf, \"\\n\");\r\n}\r\n\r\nvoid main()\r\n{ \r\n	NODE *head; int m;\r\n	system(\"CLS\");\r\n	head=creatlink(12,100);\r\n	outlink(head,stdout);\r\n	m=fun(head);\r\n	printf(\"\\nThe RESULT :\\n\");\r\n	outresult(m,stdout);\r\n}\r\n', '(1)while (p!=NULL)    (2)p=p->next;', '(1)判断当前指针 p 指向的结点是否存在，若存在则对该结点数据域进行判断操作。\r\n(2)判断结束后指针指向下一个结点。', '2', '27');
INSERT INTO `program` VALUES ('18', 'm个人的成绩存放在 score 数组中，请编写函数 fun ，它的功能是：将低于平均分的人数作为函数值返回，将低于平均分的分数放在 below 所指的数组中。\r\n例如，当 score 数组中的数据为 10、 20、30、40、50、60、 70、80、90 时，函数返回的人数应该是 4，below 中的数据应为 10、 20、30、40。注意：部分源程序在文件 PROG1.C中。\r\n请勿改动主函数	main 和其他函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句。', '#include <conio.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\nint fun(int score[],int m, int below[])\r\n{\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	int i, n, below[9];\r\n	int score[9]={10,20,30,40,50,60,70,80,90};\r\n	system(\"CLS\");\r\n	n=fun(score, 9, below);\r\n	printf(\"\\nBelow the average score are: \");\r\n	for(i=0;i<n;i++)\r\n		printf(\"%d \",below[i]);\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	for(i=0;i<n;i++)\r\n		fprintf(wf,\"%d \",below[i]);\r\n	fclose(wf);\r\n/*****************************/\r\n}', 'int fun(int score[], int m, int below[])\r\n{\r\n    int i,j=0;\r\n    float av=0.0;\r\n    for (i=0; i<m; i++)\r\n        av=av+score[i]/m; /*求平均值*/\r\n    for (i=0; i<m; i++)\r\n        if (score[i]<av) /*如果分数低于平均分，则将此分数放入below数组中*/\r\n            below[j++]=score[i];\r\n    return j; /*返回低于平均分的人数*/\r\n}', '要计算低于平均分的人数，首先应该求出平均分，然后通过 for 循环语句和 if 条件语句找出低于平均分的分数。 该题第 1 个循环的作用是求出平均分 av，第个循环的作用是找出低于平均分的成绩记录并存入 below 数组中。', '3', '27');
INSERT INTO `program` VALUES ('19', '给定程序中，函数 fun 的功能是：调用随机函数产生 20 个互不相同的整数放在形参 a 所指数组中 ( 此数组在主函数中已置 0) 。\r\n请在程序的下画线处填入正确的内容并把下画线删除，使程序得出正确的结果。\r\n注意：部分源程序在文件	BLANK1.C中。不得增行或删行，也不得更改程序的结构！', '#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\n#define	N 20\r\n\r\nvoid fun( int *a)\r\n{ \r\n	int i, x, n=0;\r\n	x=rand()%20;\r\n/**********found**********/\r\n	while (n<__1__)\r\n	{\r\n		for(i=0; i<n; i++ ) \r\n			/**********found**********/\r\n			if( x==a[i] ) __2__;\r\n/**********found**********/ \r\n			if( i==__3__)\r\n			{\r\n				a[n]=x; n++; \r\n			} \r\n			x=rand()%20;\r\n	}\r\n}\r\n\r\nvoid main()\r\n{ \r\n	int x[N]={0} ,i; \r\n	fun( x );\r\n	printf(\"The result : \\n\");\r\n	for( i=0; i<N; i++ )\r\n	{\r\n		printf(\"%4d\",x[i]);\r\n		if((i+1)%5==0)printf(\"\\n\");\r\n	}\r\n	printf(\"\\n\\n\");\r\n}', '(1)N 或 20    (2)break    (3)n', '填空 1：变量 n 用于存储数组的下标，要通过 while 语句对数组进行赋值，数组的容量为 20，因此循环条件应为 n<20。\r\n填空 2：通过一个 for 循环判断 x 是否与数组中已存的元素重复，若重复则跳出 for 循环结束。\r\n填空 3：若 for 循环是由 break 语句结束的，则 x 与数组中的元素重复，此时 i 必然小于 n；若 for 循环是因为循环变量 i 递增到某值，而不再满足循环条件结束的，说明 x 的值与数组中的元素不重复，则此时 i 的值等于 n。', '1', '32');
INSERT INTO `program` VALUES ('20', '下列给定程序中，函数 fun 的功能是：先从键盘上输入一个 3 行、3 列的矩阵的各个元素的值，然后输出主对角线元素之和。请改正程序中的错误，使它能得出正确的结果。\r\n注意：部分源程序在文件 MODI1.C中, 不要改动 main 函数，不得增行或删行， 也不得更改程序的结构！', '#include <stdio.h>\r\n\r\nvoid fun()\r\n{\r\n	int a[3][3],sum;\r\n	int i,j;\r\n/*************found**************/\r\n	sum=1;\r\n	for (i=0;i<3;i++)\r\n	{\r\n		for (j=0;j<3;j++)\r\n/*************found**************/\r\n			scanf(\"%d\",a[i][j]);\r\n	}\r\n	for(i=0;i<3;i++)\r\n		sum=sum+a[i][i];\r\n	printf(\"Sum=%d\\n\",sum);\r\n}\r\n\r\nvoid main()\r\n{\r\n	fun();\r\n}', '(1)sum=0;    (2)scanf(\"%d\",&a[i][j]);', '该题考查对循环语句的掌握和对数组概念的理解。 本题的解题思路为： 先从键盘输入一个 3×3矩阵，然后循环累加，执行循环语句中的 sum＝sum＋a[i][i] ；。因为变量 sum用来存放累加后的结果，所以应对其初始化为 0。第二处错误考查标准输入函数 scanf 的格式，被赋值的变量前要加上取地址符 \"&\" 。', '2', '32');
INSERT INTO `program` VALUES ('21', '编写程序，实现矩阵  (3 行、 3 列 ) 的转置 ( 即行列互换 ) 。\r\n例如，若输入下面的矩阵：\r\n则程序输出：\r\n注意：部分源程序在文件	PROG1.C中。\r\n请勿改动主函数	main 和其他函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句。', '#include <stdio.h>\r\n#include <conio.h>\r\n#include <stdlib.h>\r\n\r\nvoid fun (int array[3][3])\r\n{\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	int i,j;\r\n	int array [3][3]={{100,200,300},{400,500,600},{700,800,900}};\r\n	system(\"CLS\");\r\n	for (i=0;i<3;i++)\r\n	{\r\n		for (j=0;j<3;j++)\r\n			printf(\"%7d \",array[i][j]);\r\n		printf(\"\\n \");\r\n	}\r\n	fun(array);\r\n	printf(\"Converted array:\\n \");\r\n	for (i=0;i<3;i++)\r\n	{\r\n		for (j=0;j<3;j++) \r\n			printf(\"%7d \",array[i][j]);\r\n		printf(\"\\n \");\r\n	}\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	for (i=0;i<3;i++)\r\n	{\r\n		for (j=0;j<3;j++)\r\n			fprintf(wf,\"%7d \",array[i][j]);\r\n		fprintf(wf,\"\\n\");\r\n	}\r\n	fclose(wf);\r\n/*****************************/\r\n}', 'void fun (int array[3][3])\r\n{\r\n    int i,j,t;\r\n    for(i=0;i<3;i++) /* 将右上三角和左下三角对换， 实现行列互换 */\r\n        for(j=i+1;j<3;j++)\r\n        {\r\n            t=array[i][j];\r\n            array[i][j]=array[j][i];\r\n            array[j][i]=t;\r\n        }\r\n}', '要实现矩阵转置， 即将右上角数组元素和左下角数组元素对换，本题通过数组元素交换方法，完成矩阵转置操作。因为对矩阵转置后仍然存回其本身，所以只能循环矩阵中的一个角( 本程序是右上半三角 ) 。控制右上半三角的方法是在内层循环中循环变量j 从 i+1 或 i 开始。', '3', '32');
INSERT INTO `program` VALUES ('22', '给定程序中，函数 fun 的功能是：找出 N×N矩阵中每列元素中的最大值，并按顺序依次存放于形参 b 所指的一维数组中。\r\n请在程序的下画线处填入正确的内容并把下画线删除，使程序得出正确的结果。\r\n注意：部分源程序在文件	BLANK1.C中。不得增行或删行，也不得更改程序的结构！', '#include <stdio.h>\r\n\r\n#define N 4\r\n\r\nvoid fun(int (*a)[N], int *b)\r\n{\r\n	int i,j;\r\n	for(i=0; i<N; i++) \r\n	{\r\n/**********found**********/\r\n		b[i]=__1__;\r\n		for(j=1; j<N; j++)\r\n/**********found**********/\r\n			if(b[i]__2__ a[j][i])\r\n				b[i]=a[j][i];\r\n	}\r\n}\r\n\r\nvoid main()\r\n{ \r\n	int x[N][N]={ {12,5,8,7},{6,1,9,3},{1,2,3,4},{2,8,4,3} },y[N],i,j; \r\n	printf(\"\\nThe matrix :\\n\");\r\n	for(i=0;i<N; i++)\r\n	{ \r\n		for(j=0;j<N; j++)\r\n			printf(\"%4d\",x[i][j]);\r\n		printf(\"\\n\");\r\n	}\r\n/**********found**********/\r\n	fun(__3__);\r\n	printf(\"\\nThe result is:\");\r\n	for(i=0; i<N; i++)\r\n		printf(\"%3d\",y[i]);\r\n	printf(\"\\n\");\r\n}', '(1)a[0][i]    (2)<    (3)x,y', '填空 1：数组 b 用于存放每列元素中的最大值，首先将第i 列的第一个数赋给b[i]，然后用 b[i]	与其他数进行比较，因此此空应填a[0][i]。\r\n填空 2：if条件表达式表示当b[i]小于 a[j][i]时，就把 a[j][i]的值赋给 b[i]因此此空应该填 <。\r\n填空 3：fun 函数的调用，通过 fun(int (*a)[N],int *b) 可知，此空应该填y。', '1', '35');
INSERT INTO `program` VALUES ('23', '下列给定程序中，函数 fun 的功能是：将主函数中两个变量的值进行交换。 例如，若变量 a 中的值为 8，b 中的值为 3，则程序运行后， a 中的值为 3，b 中的值为8。\r\n请改正程序中的错误，使它能得出正确的结果。\r\n注意：部分源程序在文件 MODI1.C中, 不要改动 main 函数，不得增行或删行， 也不得更改程序的结构！', '#include <stdio.h>\r\n\r\n/*************found**************/\r\nvoid fun(int x,int y)\r\n{\r\n	int t;\r\n/*************found**************/\r\n	t=x;x=y;y=t;\r\n}\r\n\r\nvoid main() \r\n{\r\n	int a,b;\r\n	a=8;\r\n	b=3;\r\n	fun(&a, &b);\r\n	printf(\"%d %d\\n \", a,b);\r\n}', '(1)void	fun(int	*x, int	*y)\r\n(2)t=*x; *x=*y;	*y=t;', '(1)本题考查指针变量作函数参数。一般变量作参数时，不能改变实参的值，采用指针变量作为参数则能够改变实参的值。主函数中 fun 函数的调用方式表明 fun 函数的参数应当为指针类型。\r\n(2)此处是一个变量交换操作错误，可知 x、y 是指针类型，变量类型不同，因而x、y 不能与 t 进行值的交换。', '2', '35');
INSERT INTO `program` VALUES ('24', '编写函数 int fun(int lim, int aa[MAX]) ，其功能是求出小于或等于lim的所有素数,并放在 aa 数组中，并返回所求出的素数的个数。注意：部分源程序在文件 PROG1.C中。\r\n请勿改动主函数 main 和其他函数中的任何内容，仅在函数 fun 的花括号中填入你编写的若干语句。', '#include<conio.h>\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n\r\n#define MAX 100\r\n\r\nint fun(int lim, int aa[MAX])\r\n{\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	int limit,i,sum;\r\n	int aa[MAX];\r\n	system(\"CLS\");\r\n	printf(\"	输入一个整数	:\");\r\n	scanf(\"%d\",&limit);\r\n	sum=fun(limit,aa);\r\n	for(i=0;i<sum;i++)\r\n	{\r\n		if(i%10==0&&i!=0)	/*	每行输出	10 个数 */\r\n			printf(\"\\n \");\r\n		printf(\"%5d \",aa[i]);\r\n	}\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	sum=fun(15,aa);\r\n	for(i=0;i<sum;i++)\r\n	{\r\n		if(i%10==0&&i!=0)	/*	每行输出	10 个数 */\r\n			fprintf(wf,\"\\n\");\r\n		fprintf(wf,\"%5d \",aa[i]);\r\n	}\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', 'int fun(int lim, int aa[MAX])\r\n{\r\n    int i,j,k=0;\r\n    for(i=2;i<=lim;i++) /* 求出小于或等于  lim  的全部素数 */\r\n    {\r\n        for(j=2;j<i;j++)\r\n            if(i%j==0) break; if(j>=i)\r\n                aa[k++]=i; /* 将求出的素数放入数组 aa 中 */\r\n    }\r\n    return k; /* 返回所求出的素数的个数 */\r\n}本程序 ?褂胒 or 循环语句查找小于 lim 的所有数，使用内嵌的循环判断语句判断该数是否为素数。在做这道题时，需要重点掌握素数的判定方法：\r\nfor(j ＝2;j<i;j	＋＋ )\r\n    if(i%j ＝＝ 0)break ；', '本程序 ?褂胒 or 循环语句查找小于 lim 的所有数，使用内嵌的循环判断语句判断该数是否为素数。在做这道题时，需要重点掌握素数的判定方法：\r\nfor(j ＝2;j<i;j	＋＋ )\r\n    if(i%j ＝＝ 0)break ；', '3', '35');
INSERT INTO `program` VALUES ('25', '给定程序中，函数 fun 的功能是建立一个N×N的矩阵。矩阵元素的构成规律是：最外层元素的值全部为1；从外向内第2 层元素的值全部为	2；第 3 层元素的值全部为 3，,, 依此类推。例如，若N＝5，生成的矩阵为：\r\n请在程序的下画线处填入正确的内容并把下画线删除，使程序得出正确的结果。\r\n注意：部分源程序在文件	BLANK1.C中。不得增行或删行，也不得更改程序的结构！', '#include <stdio.h>\r\n\r\n#define	N	7\r\n\r\n/**********found**********/\r\nvoid fun(int (*a)__1__)\r\n{\r\n	int i,j,k,m;\r\n	if(N%2==0) \r\n		m=N/2 ;\r\n	else\r\n		m=N/2+1;\r\n	for(i=0; i<m; i++) \r\n	{\r\n\r\n/**********found**********/\r\n		for(j=__2__; j<N-i; j++)\r\n			a[i][j]=a[N-i-1][j]=i+1;\r\n		for(k=i+1; k<N-i; k++)\r\n/**********found**********/\r\n			a[k][i]=a[k][N-i-1]=__3__;\r\n	}\r\n}\r\n\r\nvoid main()\r\n{ \r\n	int x[N][N]={0},i,j;\r\n	fun(x);\r\n	printf(\"\\nThe result is:\\n\"); \r\n	for(i=0; i<N; i++)\r\n	{\r\n		for(j=0; j<N; j++) \r\n			printf(\"%3d\",x[i][j]);\r\n		printf(\"\\n\");\r\n	}\r\n}', '(1)[N]	(2)i	(3)i+1', '填空 1：本题考查了形参的确定。参数传递时将实参的值赋给形参，实参和形参是一一对应的，因此该空应该填写[N] 。\r\n填空 2：第二重 for  循环中 a[i][j]和 a[N－ i －1][j]组 a[N][N]  的值，因而此空应该填写i 。表示第一行和最后一行数\r\n填空 3：第三重 for  循环代表的是  a[N][N]  中每一列的值，因此此空应该填写i＋1。', '1', '36');
INSERT INTO `program` VALUES ('26', '下列给定程序中，函数 fun 的功能是：将十进制正整数 m转换成 k(2 ≤k≤9) 进制数，并按位输出。例如，若输入 8 和 2，则应输出 1000( 即十进制数 8 转换成二进制表示是 1000) 。\r\n请改正程序中的错误，使它能得出正确的结果。\r\n注意：部分源程序在文件 MODI1.C中, 不要改动 main 函数，不得增行或删行， 也不得更改程序的结构！', '#include <stdio.h>\r\n#include <conio.h>\r\n\r\n/*************found**************/\r\nvoid fun(int m,int k);\r\n{\r\n	int aa[20], i;\r\n	for(i=0;m;i++)\r\n	{\r\n/*************found**************/\r\n		aa[i]=m/k;\r\n		m/=k;\r\n	}\r\n	for(;i;i--)\r\n/*************found**************/\r\n		printf(\"%d\",aa[i]);\r\n}\r\n\r\nvoid main()\r\n{\r\n	int b,n;\r\n	printf(\"\\nPlease enter a number and a base:\\n\");\r\n	scanf(\"%d%d\",&n,&b);\r\n	fun(n,b);\r\n	printf(\"\\n \");\r\n}\r\n', '(1)void	fun(int	m,int	k)\r\n(2)aa[i]=m%k;\r\n(3)printf(\"%d\",aa[i-1]);', '(1)函数定义的格式错误，不应带有  \" ； \" 。\r\n(2)将十进制正整数转换为任意进制的数与十进制正整数转换成二进制的数的方法是一样的。 从整数 n 译出它的各位 k 进制数值， 需采用除 k 取余的方法， 即求 n 除 k 的余数，得到它的 k 进制的个位数，接着将 n 除以 k。在 n 不等于 0 的状况下循环，能顺序求出	n 的 k 进制的各个位上的数。\r\n(3)在进行 for(i  ＝0;m;i++) 循环结束时， i 已经多加了一个  1，所以这里要减去1。', '2', '36');
INSERT INTO `program` VALUES ('27', '编写一个函数， 其功能是： 从传入的 num个字符中找出最长的一个字符串， 并通过形参指针 max传回该串地址 ( 用**** 作为结束输入的标识 ) 。注意：部分源程序在文件 PROG1.C中。\r\n请勿改动主函数main 和其他函数中的任何内容，仅在函数fun的花括号中填入你编写的若干语句。', '#include<conio.h>\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n\r\nchar *fun(char (*a)[81], int num, char *max)\r\n{\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char ss[10][81],*ps=NULL;\r\n	char s[3][81]={\"abcd\",\"deg\",\"diegns\"},*p=NULL;\r\n	int i=0,n;\r\n	system(\"CLS\");\r\n	printf(\"	输入若干个字符串：	\");\r\n	gets(ss[i]);\r\n	puts(ss[i]);\r\n	while(!strcmp(ss[i], \"****\")==0) /*用 4 个星号作为结束输入的标志*/\r\n	{\r\n		i++;\r\n		gets(ss[i]);\r\n		puts(ss[i]);\r\n	}\r\n	n=i;\r\n	ps=fun(ss,n,ps);\r\n	printf(\"\\nmax=%s\\n\",ps);\r\n	/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	p=fun(s,3,p);\r\n	fprintf(wf,\"%s\",p);\r\n	fclose(wf);\r\n	/*****************************/\r\n}\r\n', 'char *fun(char (*a)[81], int num, char *max)\r\n{\r\n    int i=0;\r\n    max=a[0];\r\n    for(i=0;i<num;i++) /* 找出最长的一个字符串  */\r\n        if(strlen(max)<strlen(a[i]))\r\n            max=a[i];\r\n    return max; /* 传回最长字符串的地址  */\r\n}', '解答本题之前，首先应该明白 ss 是一个指向一维数组的指针变量， max是指向指针的变量，所以引用变量时要注意加上 * 。本程序使用循环语句遍历字符串数组，使用条件语句判断该字符串是否最大。', '3', '36');
INSERT INTO `program` VALUES ('28', '给定程序中，函数 fun 的功能是：判定形参 a 所指的 N×N(规定 N为奇数 ) 的矩阵是否是 \" 幻方 \" ，若是，函数返回值为 1；若不是，函数返回值为 0。\" 幻方 \" 的判定条件是：矩阵每行、每列、主对角线及反对角线上元素之和都相等。例如，以下 3×3的矩阵就是一个 \" 幻方 \" ：\r\n请在程序的下画线处填入正确的内容并把下画线删除，使程序得出正确的结果。\r\n注意：部分源程序在文件	BLANK1.C中。不得增行或删行，也不得更改程序的结构！', '#include <stdio.h>\r\n\r\n#define	N	3\r\n\r\nint fun(int (*a)[N])\r\n{\r\n	int i,j,m1,m2,row,colum;\r\n	m1=m2=0;\r\n	for(i=0; i<N; i++)\r\n	{\r\n		j=N-i-1; m1+=a[i][i]; m2+=a[i][j];\r\n	} \r\n	if(m1!=m2) \r\n		return 0;\r\n	for(i=0; i<N; i++) \r\n	{\r\n/**********found**********/\r\n		row=colum= __1__;\r\n		for(j=0; j<N; j++)\r\n		{\r\n			row+=a[i][j]; \r\n			colum+=a[j][i];\r\n		} /**********found**********/\r\n		if( (row!=colum) __2__ (row!=m1) ) \r\n			return 0;\r\n	}\r\n/**********found**********/\r\n	return __3__;\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n	int x[N][N],i,j;\r\n	printf(\"Enter number for array:\\n\"); \r\n	for(i=0; i<N; i++)\r\n		for(j=0; j<N; j++) \r\n			scanf(\"%d\",&x[i][j]);\r\n	printf(\"Array:\\n\");\r\n	for(i=0; i<N; i++)\r\n	{ \r\n		for(j=0; j<N; j++) \r\n			printf(\"%3d\",x[i][j]); \r\n		printf(\"\\n\");\r\n	}\r\n	if(fun(x)) \r\n		printf(\"The Array is a magic square.\\n\");\r\n	else\r\n		printf(\"The Array isn\'t a magic square.\\n\");\r\n}', '(1)0	(2)||	(3)1', '填空 1：本题考查为变量赋初值，在这里row+=a[i][j]代表是每行的总和，colum＋＝ a[j][i]代表的是每列的总和，因而row，colum 在初始化时应该为零，此空应该填0。\r\n填空 2：本题考查了  if	条件语句，此句	if判断代表每行的总和与列是否相等，每行的总和是否与对角线的总和相等，两者若有一个不成立，即返回0，因而此空应该填写 || 。\r\n填空 3：题目要求若矩阵是“幻方”，则函数返回值为1，因而此空应该填写1。', '1', '37');
INSERT INTO `program` VALUES ('29', '下列给定程序中，函数fun 的功能是：传入一个整数m，计算如下公式的值。\r\n例如，若输入  5，则应输出－ 0.283333 。\r\n请改正程序中的错误，使它能得出正确的结果。\r\n注意：部分源程序在文件 MODI1.C中, 不要改动 main 函数，不得增行或删行， 也不得更改程序的结构！', '#include <stdlib.h>\r\n#include <conio.h>\r\n#include <stdio.h>\r\n\r\ndouble fun(int m)\r\n{\r\n	double t=1.0;\r\n	int i;\r\n	for(i=2;i<=m;i++)\r\n/*************found**************/\r\n		t=1.0-1/i;\r\n/*************found**************/\r\n				;\r\n}\r\n\r\nvoid main()\r\n{\r\n	int m;\r\n	system(\"CLS\");\r\n	printf(\"\\nPlease enter 1 integer numbers:\\n\");\r\n	scanf(\"%d\",&m);\r\n	printf(\"\\n\\nThe result is %1f\\n\",fun(m));\r\n}\r\n', '(1)t-=1.0/i;\r\n(2)return t;', '(1)变量 t 存放公式的和，通过循环语句进行复合运算，因此此处应改为 t-=1.0/i; ，注意此处应进行变量的类型转换。\r\n(2)循环结束后应将和值返回给主函数。', '2', '37');
INSERT INTO `program` VALUES ('30', '请编写一个函数，用来删除字符串中的所有空格。\r\n例如，输入 asd af aa z67，则输出为  asdafaaz67 。\r\n注意：部分源程序在文件	PROG1.C中。\r\n请勿改动主函数 main 和其他函数中的任何内容，仅在函数 fun 的花括号中填入你编写的若干语句。', '#include <stdio.h>\r\n#include <ctype.h>\r\n#include <conio.h>\r\n#include <stdlib.h>\r\n\r\nvoid fun (char *str)\r\n{\r\n\r\n}\r\n\r\nvoid main()\r\n{\r\n	char str[81];\r\n	char Msg[]=\"Input a string:\";\r\n	int n;\r\n	FILE *out;\r\n	printf(Msg);\r\n	gets(str);\r\n	puts(str);\r\n	fun(str);\r\n	printf(\"*** str: %s\\n\",str);\r\n/******************************/\r\n	out=fopen(\"out.dat\",\"w\");\r\n	fun(Msg);\r\n	fprintf(out,\"%s\",Msg);\r\n	fclose(out);\r\n/******************************/\r\n}', 'void fun (char *str)\r\n{\r\n    int i=0;\r\n    char *p=str;\r\n    while(*p)\r\n    {\r\n        if(*p!=\' \')	/* 删除空格 */\r\n        {\r\n            str[i++]=*p;\r\n        }\r\n        p++;\r\n    }\r\n    str[i]=\'\\0\';	/* 加上结束符 */\r\n}', '本题要求删除所有空格， 即保留除了空格以外的其他所有字符。 由于 C语言中没有直接删除字符的操作，所以对不需要删除的字符采用 \" 保留 \" 的操作。用指针 p 指向字符串中的每一个字符， 每指向到一个字符都判断其是否为空格， 若不是空格则保存到 str[i] 。', '3', '37');

-- ----------------------------
-- Table structure for test
-- ----------------------------
DROP TABLE IF EXISTS `test`;
CREATE TABLE `test` (
  `id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL,
  `paper_id` int(11) DEFAULT NULL,
  `test_date` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `up` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=64 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of test
-- ----------------------------
INSERT INTO `test` VALUES ('9', '1', '1', '2018-04-08 22:41:33', '1');
INSERT INTO `test` VALUES ('10', '1', '1', '2018-04-09 16:18:15', '1');
INSERT INTO `test` VALUES ('11', '1', '1', '2018-04-09 16:29:42', null);
INSERT INTO `test` VALUES ('12', '1', '34', '2018-04-09 17:47:00', null);
INSERT INTO `test` VALUES ('13', '1', '34', '2018-04-09 17:58:24', null);
INSERT INTO `test` VALUES ('14', '1', '3', '2018-04-12 13:31:10', null);
INSERT INTO `test` VALUES ('15', '1', '3', '2018-04-12 13:37:18', null);
INSERT INTO `test` VALUES ('16', '1', '3', '2018-04-12 13:38:49', null);
INSERT INTO `test` VALUES ('17', '1', '3', '2018-04-12 13:40:23', null);
INSERT INTO `test` VALUES ('18', '1', '3', '2018-04-12 13:41:40', null);
INSERT INTO `test` VALUES ('19', '1', '3', '2018-04-12 13:42:20', null);
INSERT INTO `test` VALUES ('20', '1', '3', '2018-04-12 13:47:35', null);
INSERT INTO `test` VALUES ('21', '1', '3', '2018-04-12 13:48:00', null);
INSERT INTO `test` VALUES ('22', '1', '3', '2018-04-12 13:51:37', null);
INSERT INTO `test` VALUES ('23', '1', '3', '2018-04-12 13:52:27', null);
INSERT INTO `test` VALUES ('24', '1', '3', '2018-04-12 13:53:17', null);
INSERT INTO `test` VALUES ('25', '1', '3', '2018-04-12 13:54:01', null);
INSERT INTO `test` VALUES ('26', '1', '3', '2018-04-12 13:54:22', null);
INSERT INTO `test` VALUES ('27', '1', '3', '2018-04-12 13:55:02', null);
INSERT INTO `test` VALUES ('28', '1', '3', '2018-04-12 13:55:37', null);
INSERT INTO `test` VALUES ('29', '1', '3', '2018-04-12 14:14:01', null);
INSERT INTO `test` VALUES ('30', '1', '3', '2018-04-12 14:14:23', null);
INSERT INTO `test` VALUES ('31', '1', '3', '2018-04-12 14:15:32', null);
INSERT INTO `test` VALUES ('32', '1', '3', '2018-04-12 14:16:40', null);
INSERT INTO `test` VALUES ('33', '1', '3', '2018-04-12 14:17:40', null);
INSERT INTO `test` VALUES ('34', '1', '3', '2018-04-12 14:19:10', null);
INSERT INTO `test` VALUES ('35', '1', '3', '2018-04-12 14:29:33', null);
INSERT INTO `test` VALUES ('36', '1', '3', '2018-04-12 14:30:23', null);
INSERT INTO `test` VALUES ('37', '1', '3', '2018-04-12 14:31:16', null);
INSERT INTO `test` VALUES ('38', '1', '3', '2018-04-12 14:32:37', null);
INSERT INTO `test` VALUES ('39', '1', '3', '2018-04-12 14:36:59', null);
INSERT INTO `test` VALUES ('40', '1', '3', '2018-04-12 14:52:14', null);
INSERT INTO `test` VALUES ('41', '1', '3', '2018-04-12 16:17:25', null);
INSERT INTO `test` VALUES ('42', '1', '3', '2018-04-12 16:23:15', null);
INSERT INTO `test` VALUES ('43', '1', '3', '2018-04-12 19:21:26', null);
INSERT INTO `test` VALUES ('44', '1', '3', '2018-04-12 19:23:13', null);
INSERT INTO `test` VALUES ('45', '1', '3', '2018-04-12 19:25:03', null);
INSERT INTO `test` VALUES ('46', '1', '3', '2018-04-12 21:15:08', null);
INSERT INTO `test` VALUES ('47', '1', '3', '2018-04-12 21:16:03', null);
INSERT INTO `test` VALUES ('48', '1', '3', '2018-04-12 21:17:33', null);
INSERT INTO `test` VALUES ('49', '1', '3', '2018-04-12 21:20:24', null);
INSERT INTO `test` VALUES ('50', '1', '3', '2018-04-12 21:21:32', null);
INSERT INTO `test` VALUES ('51', '1', '3', '2018-04-12 21:33:34', null);
INSERT INTO `test` VALUES ('52', '1', '3', '2018-04-12 21:37:00', null);
INSERT INTO `test` VALUES ('53', '1', '3', '2018-04-12 21:40:44', null);
INSERT INTO `test` VALUES ('54', '1', '3', '2018-04-12 22:00:11', null);
INSERT INTO `test` VALUES ('55', '1', '3', '2018-04-13 12:14:47', null);
INSERT INTO `test` VALUES ('56', '1', '3', '2018-04-13 12:17:39', null);
INSERT INTO `test` VALUES ('57', '1', '3', '2018-04-13 12:20:47', null);
INSERT INTO `test` VALUES ('58', '1', '3', '2018-04-13 13:19:16', null);
INSERT INTO `test` VALUES ('59', '1', '3', '2018-04-13 13:24:13', null);
INSERT INTO `test` VALUES ('60', '1', '3', '2018-04-13 13:25:44', null);
INSERT INTO `test` VALUES ('61', '1', '3', '2018-04-13 21:51:59', null);
INSERT INTO `test` VALUES ('62', '12', '6', '2018-04-20 10:59:54', null);
INSERT INTO `test` VALUES ('63', '1', '25', '2018-04-23 17:45:55', null);

-- ----------------------------
-- Table structure for test_detail
-- ----------------------------
DROP TABLE IF EXISTS `test_detail`;
CREATE TABLE `test_detail` (
  `id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `test_id` int(11) DEFAULT NULL,
  `exercise_id` int(11) DEFAULT NULL,
  `option` varchar(16) DEFAULT NULL,
  `correct` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2009 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of test_detail
-- ----------------------------
INSERT INTO `test_detail` VALUES ('5', '9', '1', 'N', '0');
INSERT INTO `test_detail` VALUES ('6', '9', '2', 'N', '0');
INSERT INTO `test_detail` VALUES ('7', '9', '3', 'N', '0');
INSERT INTO `test_detail` VALUES ('8', '9', '4', 'N', '0');
INSERT INTO `test_detail` VALUES ('9', '9', '5', 'N', '0');
INSERT INTO `test_detail` VALUES ('10', '9', '6', 'N', '0');
INSERT INTO `test_detail` VALUES ('11', '9', '7', 'N', '0');
INSERT INTO `test_detail` VALUES ('12', '9', '8', 'N', '0');
INSERT INTO `test_detail` VALUES ('13', '9', '9', 'N', '0');
INSERT INTO `test_detail` VALUES ('14', '9', '10', 'N', '0');
INSERT INTO `test_detail` VALUES ('15', '10', '1', 'A', '1');
INSERT INTO `test_detail` VALUES ('16', '10', '2', 'C', '1');
INSERT INTO `test_detail` VALUES ('17', '10', '3', 'C', '1');
INSERT INTO `test_detail` VALUES ('18', '10', '4', 'B', '0');
INSERT INTO `test_detail` VALUES ('19', '10', '5', 'B', '0');
INSERT INTO `test_detail` VALUES ('20', '10', '6', 'N', '0');
INSERT INTO `test_detail` VALUES ('21', '10', '7', 'N', '0');
INSERT INTO `test_detail` VALUES ('22', '10', '8', 'N', '0');
INSERT INTO `test_detail` VALUES ('23', '10', '9', 'N', '0');
INSERT INTO `test_detail` VALUES ('24', '10', '10', 'N', '0');
INSERT INTO `test_detail` VALUES ('25', '11', '1', 'A', '1');
INSERT INTO `test_detail` VALUES ('26', '11', '2', 'D', '0');
INSERT INTO `test_detail` VALUES ('27', '11', '3', 'D', '0');
INSERT INTO `test_detail` VALUES ('28', '11', '4', 'D', '1');
INSERT INTO `test_detail` VALUES ('29', '11', '5', 'D', '1');
INSERT INTO `test_detail` VALUES ('30', '11', '6', 'N', '0');
INSERT INTO `test_detail` VALUES ('31', '11', '7', 'N', '0');
INSERT INTO `test_detail` VALUES ('32', '11', '8', 'N', '0');
INSERT INTO `test_detail` VALUES ('33', '11', '9', 'N', '0');
INSERT INTO `test_detail` VALUES ('34', '11', '10', 'N', '0');
INSERT INTO `test_detail` VALUES ('35', '12', '178', 'N', '0');
INSERT INTO `test_detail` VALUES ('36', '12', '179', 'N', '0');
INSERT INTO `test_detail` VALUES ('37', '13', '178', 'B', '0');
INSERT INTO `test_detail` VALUES ('38', '13', '179', 'B', '0');
INSERT INTO `test_detail` VALUES ('39', '14', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('40', '14', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('41', '14', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('42', '14', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('43', '14', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('44', '14', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('45', '14', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('46', '14', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('47', '14', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('48', '14', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('49', '14', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('50', '14', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('51', '14', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('52', '14', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('53', '14', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('54', '14', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('55', '14', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('56', '14', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('57', '14', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('58', '14', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('59', '14', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('60', '14', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('61', '14', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('62', '14', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('63', '14', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('64', '14', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('65', '14', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('66', '14', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('67', '14', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('68', '14', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('69', '14', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('70', '14', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('71', '14', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('72', '14', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('73', '14', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('74', '14', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('75', '14', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('76', '14', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('77', '14', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('78', '14', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('79', '15', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('80', '15', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('81', '15', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('82', '15', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('83', '15', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('84', '15', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('85', '15', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('86', '15', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('87', '15', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('88', '15', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('89', '15', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('90', '15', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('91', '15', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('92', '15', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('93', '15', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('94', '15', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('95', '15', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('96', '15', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('97', '15', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('98', '15', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('99', '15', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('100', '15', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('101', '15', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('102', '15', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('103', '15', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('104', '15', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('105', '15', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('106', '15', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('107', '15', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('108', '15', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('109', '15', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('110', '15', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('111', '15', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('112', '15', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('113', '15', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('114', '15', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('115', '15', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('116', '15', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('117', '15', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('118', '15', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('119', '16', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('120', '16', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('121', '16', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('122', '16', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('123', '16', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('124', '16', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('125', '16', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('126', '16', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('127', '16', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('128', '16', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('129', '16', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('130', '16', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('131', '16', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('132', '16', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('133', '16', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('134', '16', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('135', '16', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('136', '16', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('137', '16', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('138', '16', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('139', '16', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('140', '16', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('141', '16', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('142', '16', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('143', '16', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('144', '16', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('145', '16', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('146', '16', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('147', '16', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('148', '16', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('149', '16', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('150', '16', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('151', '16', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('152', '16', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('153', '16', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('154', '16', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('155', '16', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('156', '16', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('157', '16', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('158', '16', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('159', '17', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('160', '17', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('161', '17', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('162', '17', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('163', '17', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('164', '17', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('165', '17', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('166', '17', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('167', '17', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('168', '17', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('169', '17', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('170', '17', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('171', '17', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('172', '17', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('173', '17', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('174', '17', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('175', '17', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('176', '17', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('177', '17', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('178', '17', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('179', '17', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('180', '17', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('181', '17', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('182', '17', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('183', '17', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('184', '17', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('185', '17', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('186', '17', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('187', '17', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('188', '17', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('189', '17', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('190', '17', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('191', '17', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('192', '17', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('193', '17', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('194', '17', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('195', '17', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('196', '17', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('197', '17', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('198', '17', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('199', '18', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('200', '18', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('201', '18', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('202', '18', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('203', '18', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('204', '18', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('205', '18', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('206', '18', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('207', '18', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('208', '18', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('209', '18', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('210', '18', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('211', '18', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('212', '18', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('213', '18', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('214', '18', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('215', '18', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('216', '18', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('217', '18', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('218', '18', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('219', '18', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('220', '18', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('221', '18', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('222', '18', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('223', '18', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('224', '18', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('225', '18', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('226', '18', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('227', '18', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('228', '18', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('229', '18', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('230', '18', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('231', '18', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('232', '18', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('233', '18', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('234', '18', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('235', '18', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('236', '18', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('237', '18', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('238', '18', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('239', '19', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('240', '19', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('241', '19', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('242', '19', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('243', '19', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('244', '19', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('245', '19', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('246', '19', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('247', '19', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('248', '19', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('249', '19', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('250', '19', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('251', '19', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('252', '19', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('253', '19', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('254', '19', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('255', '19', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('256', '19', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('257', '19', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('258', '19', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('259', '19', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('260', '19', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('261', '19', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('262', '19', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('263', '19', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('264', '19', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('265', '19', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('266', '19', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('267', '19', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('268', '19', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('269', '19', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('270', '19', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('271', '19', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('272', '19', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('273', '19', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('274', '19', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('275', '19', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('276', '19', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('277', '19', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('278', '19', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('279', '20', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('280', '20', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('281', '20', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('282', '20', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('283', '20', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('284', '20', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('285', '20', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('286', '20', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('287', '20', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('288', '20', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('289', '20', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('290', '20', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('291', '20', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('292', '20', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('293', '20', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('294', '20', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('295', '20', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('296', '20', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('297', '20', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('298', '20', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('299', '20', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('300', '20', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('301', '20', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('302', '20', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('303', '20', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('304', '20', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('305', '20', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('306', '20', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('307', '20', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('308', '20', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('309', '20', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('310', '20', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('311', '20', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('312', '20', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('313', '20', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('314', '20', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('315', '20', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('316', '20', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('317', '20', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('318', '20', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('319', '21', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('320', '21', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('321', '21', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('322', '21', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('323', '21', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('324', '21', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('325', '21', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('326', '21', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('327', '21', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('328', '21', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('329', '21', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('330', '21', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('331', '21', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('332', '21', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('333', '21', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('334', '21', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('335', '21', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('336', '21', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('337', '21', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('338', '21', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('339', '21', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('340', '21', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('341', '21', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('342', '21', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('343', '21', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('344', '21', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('345', '21', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('346', '21', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('347', '21', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('348', '21', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('349', '21', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('350', '21', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('351', '21', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('352', '21', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('353', '21', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('354', '21', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('355', '21', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('356', '21', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('357', '21', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('358', '21', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('359', '22', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('360', '22', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('361', '22', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('362', '22', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('363', '22', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('364', '22', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('365', '22', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('366', '22', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('367', '22', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('368', '22', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('369', '22', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('370', '22', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('371', '22', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('372', '22', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('373', '22', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('374', '22', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('375', '22', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('376', '22', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('377', '22', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('378', '22', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('379', '22', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('380', '22', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('381', '22', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('382', '22', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('383', '22', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('384', '22', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('385', '22', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('386', '22', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('387', '22', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('388', '22', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('389', '22', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('390', '22', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('391', '22', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('392', '22', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('393', '22', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('394', '22', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('395', '22', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('396', '22', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('397', '22', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('398', '22', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('399', '23', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('400', '23', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('401', '23', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('402', '23', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('403', '23', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('404', '23', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('405', '23', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('406', '23', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('407', '23', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('408', '23', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('409', '23', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('410', '23', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('411', '23', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('412', '23', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('413', '23', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('414', '23', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('415', '23', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('416', '23', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('417', '23', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('418', '23', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('419', '23', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('420', '23', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('421', '23', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('422', '23', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('423', '23', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('424', '23', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('425', '23', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('426', '23', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('427', '23', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('428', '23', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('429', '23', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('430', '23', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('431', '23', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('432', '23', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('433', '23', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('434', '23', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('435', '23', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('436', '23', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('437', '23', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('438', '23', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('439', '24', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('440', '24', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('441', '24', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('442', '24', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('443', '24', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('444', '24', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('445', '24', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('446', '24', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('447', '24', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('448', '24', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('449', '24', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('450', '24', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('451', '24', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('452', '24', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('453', '24', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('454', '24', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('455', '24', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('456', '24', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('457', '24', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('458', '24', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('459', '24', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('460', '24', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('461', '24', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('462', '24', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('463', '24', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('464', '24', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('465', '24', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('466', '24', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('467', '24', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('468', '24', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('469', '24', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('470', '24', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('471', '24', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('472', '24', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('473', '24', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('474', '24', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('475', '24', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('476', '24', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('477', '24', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('478', '24', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('479', '25', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('480', '25', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('481', '25', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('482', '25', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('483', '25', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('484', '25', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('485', '25', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('486', '25', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('487', '25', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('488', '25', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('489', '25', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('490', '25', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('491', '25', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('492', '25', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('493', '25', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('494', '25', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('495', '25', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('496', '25', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('497', '25', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('498', '25', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('499', '25', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('500', '25', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('501', '25', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('502', '25', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('503', '25', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('504', '25', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('505', '25', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('506', '25', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('507', '25', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('508', '25', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('509', '25', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('510', '25', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('511', '25', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('512', '25', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('513', '25', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('514', '25', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('515', '25', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('516', '25', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('517', '25', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('518', '25', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('519', '26', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('520', '26', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('521', '26', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('522', '26', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('523', '26', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('524', '26', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('525', '26', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('526', '26', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('527', '26', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('528', '26', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('529', '26', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('530', '26', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('531', '26', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('532', '26', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('533', '26', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('534', '26', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('535', '26', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('536', '26', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('537', '26', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('538', '26', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('539', '26', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('540', '26', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('541', '26', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('542', '26', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('543', '26', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('544', '26', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('545', '26', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('546', '26', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('547', '26', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('548', '26', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('549', '26', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('550', '26', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('551', '26', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('552', '26', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('553', '26', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('554', '26', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('555', '26', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('556', '26', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('557', '26', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('558', '26', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('559', '27', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('560', '27', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('561', '27', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('562', '27', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('563', '27', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('564', '27', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('565', '27', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('566', '27', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('567', '27', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('568', '27', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('569', '27', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('570', '27', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('571', '27', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('572', '27', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('573', '27', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('574', '27', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('575', '27', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('576', '27', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('577', '27', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('578', '27', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('579', '27', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('580', '27', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('581', '27', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('582', '27', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('583', '27', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('584', '27', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('585', '27', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('586', '27', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('587', '27', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('588', '27', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('589', '27', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('590', '27', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('591', '27', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('592', '27', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('593', '27', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('594', '27', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('595', '27', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('596', '27', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('597', '27', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('598', '27', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('599', '28', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('600', '28', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('601', '28', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('602', '28', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('603', '28', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('604', '28', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('605', '28', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('606', '28', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('607', '28', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('608', '28', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('609', '28', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('610', '28', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('611', '28', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('612', '28', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('613', '28', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('614', '28', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('615', '28', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('616', '28', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('617', '28', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('618', '28', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('619', '28', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('620', '28', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('621', '28', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('622', '28', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('623', '28', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('624', '28', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('625', '28', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('626', '28', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('627', '28', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('628', '28', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('629', '28', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('630', '28', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('631', '28', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('632', '28', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('633', '28', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('634', '28', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('635', '28', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('636', '28', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('637', '28', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('638', '28', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('639', '29', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('640', '29', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('641', '29', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('642', '29', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('643', '29', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('644', '29', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('645', '29', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('646', '29', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('647', '29', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('648', '29', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('649', '29', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('650', '29', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('651', '29', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('652', '29', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('653', '29', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('654', '29', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('655', '29', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('656', '29', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('657', '29', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('658', '29', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('659', '29', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('660', '29', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('661', '29', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('662', '29', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('663', '29', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('664', '29', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('665', '29', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('666', '29', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('667', '29', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('668', '29', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('669', '29', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('670', '29', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('671', '29', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('672', '29', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('673', '29', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('674', '29', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('675', '29', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('676', '29', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('677', '29', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('678', '29', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('679', '30', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('680', '30', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('681', '30', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('682', '30', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('683', '30', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('684', '30', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('685', '30', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('686', '30', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('687', '30', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('688', '30', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('689', '30', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('690', '30', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('691', '30', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('692', '30', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('693', '30', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('694', '30', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('695', '30', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('696', '30', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('697', '30', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('698', '30', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('699', '30', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('700', '30', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('701', '30', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('702', '30', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('703', '30', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('704', '30', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('705', '30', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('706', '30', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('707', '30', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('708', '30', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('709', '30', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('710', '30', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('711', '30', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('712', '30', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('713', '30', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('714', '30', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('715', '30', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('716', '30', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('717', '30', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('718', '30', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('719', '31', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('720', '31', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('721', '31', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('722', '31', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('723', '31', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('724', '31', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('725', '31', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('726', '31', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('727', '31', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('728', '31', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('729', '31', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('730', '31', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('731', '31', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('732', '31', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('733', '31', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('734', '31', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('735', '31', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('736', '31', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('737', '31', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('738', '31', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('739', '31', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('740', '31', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('741', '31', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('742', '31', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('743', '31', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('744', '31', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('745', '31', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('746', '31', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('747', '31', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('748', '31', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('749', '31', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('750', '31', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('751', '31', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('752', '31', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('753', '31', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('754', '31', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('755', '31', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('756', '31', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('757', '31', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('758', '31', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('759', '32', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('760', '32', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('761', '32', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('762', '32', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('763', '32', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('764', '32', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('765', '32', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('766', '32', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('767', '32', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('768', '32', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('769', '32', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('770', '32', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('771', '32', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('772', '32', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('773', '32', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('774', '32', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('775', '32', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('776', '32', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('777', '32', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('778', '32', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('779', '32', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('780', '32', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('781', '32', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('782', '32', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('783', '32', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('784', '32', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('785', '32', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('786', '32', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('787', '32', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('788', '32', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('789', '32', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('790', '32', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('791', '32', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('792', '32', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('793', '32', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('794', '32', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('795', '32', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('796', '32', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('797', '32', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('798', '32', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('799', '33', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('800', '33', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('801', '33', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('802', '33', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('803', '33', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('804', '33', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('805', '33', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('806', '33', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('807', '33', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('808', '33', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('809', '33', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('810', '33', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('811', '33', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('812', '33', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('813', '33', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('814', '33', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('815', '33', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('816', '33', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('817', '33', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('818', '33', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('819', '33', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('820', '33', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('821', '33', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('822', '33', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('823', '33', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('824', '33', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('825', '33', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('826', '33', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('827', '33', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('828', '33', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('829', '33', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('830', '33', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('831', '33', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('832', '33', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('833', '33', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('834', '33', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('835', '33', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('836', '33', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('837', '33', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('838', '33', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('839', '34', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('840', '34', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('841', '34', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('842', '34', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('843', '34', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('844', '34', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('845', '34', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('846', '34', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('847', '34', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('848', '34', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('849', '34', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('850', '34', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('851', '34', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('852', '34', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('853', '34', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('854', '34', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('855', '34', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('856', '34', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('857', '34', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('858', '34', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('859', '34', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('860', '34', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('861', '34', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('862', '34', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('863', '34', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('864', '34', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('865', '34', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('866', '34', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('867', '34', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('868', '34', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('869', '34', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('870', '34', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('871', '34', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('872', '34', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('873', '34', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('874', '34', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('875', '34', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('876', '34', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('877', '34', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('878', '34', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('879', '35', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('880', '35', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('881', '35', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('882', '35', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('883', '35', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('884', '35', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('885', '35', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('886', '35', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('887', '35', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('888', '35', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('889', '35', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('890', '35', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('891', '35', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('892', '35', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('893', '35', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('894', '35', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('895', '35', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('896', '35', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('897', '35', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('898', '35', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('899', '35', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('900', '35', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('901', '35', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('902', '35', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('903', '35', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('904', '35', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('905', '35', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('906', '35', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('907', '35', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('908', '35', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('909', '35', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('910', '35', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('911', '35', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('912', '35', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('913', '35', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('914', '35', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('915', '35', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('916', '35', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('917', '35', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('918', '35', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('919', '36', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('920', '36', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('921', '36', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('922', '36', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('923', '36', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('924', '36', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('925', '36', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('926', '36', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('927', '36', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('928', '36', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('929', '36', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('930', '36', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('931', '36', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('932', '36', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('933', '36', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('934', '36', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('935', '36', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('936', '36', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('937', '36', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('938', '36', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('939', '36', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('940', '36', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('941', '36', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('942', '36', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('943', '36', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('944', '36', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('945', '36', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('946', '36', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('947', '36', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('948', '36', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('949', '36', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('950', '36', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('951', '36', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('952', '36', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('953', '36', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('954', '36', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('955', '36', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('956', '36', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('957', '36', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('958', '36', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('959', '37', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('960', '37', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('961', '37', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('962', '37', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('963', '37', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('964', '37', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('965', '37', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('966', '37', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('967', '37', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('968', '37', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('969', '37', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('970', '37', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('971', '37', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('972', '37', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('973', '37', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('974', '37', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('975', '37', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('976', '37', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('977', '37', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('978', '37', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('979', '37', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('980', '37', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('981', '37', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('982', '37', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('983', '37', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('984', '37', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('985', '37', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('986', '37', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('987', '37', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('988', '37', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('989', '37', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('990', '37', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('991', '37', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('992', '37', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('993', '37', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('994', '37', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('995', '37', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('996', '37', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('997', '37', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('998', '37', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('999', '38', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1000', '38', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1001', '38', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1002', '38', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1003', '38', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1004', '38', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1005', '38', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1006', '38', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1007', '38', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1008', '38', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1009', '38', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1010', '38', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1011', '38', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1012', '38', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1013', '38', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1014', '38', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1015', '38', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1016', '38', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1017', '38', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1018', '38', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1019', '38', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1020', '38', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1021', '38', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1022', '38', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1023', '38', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1024', '38', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1025', '38', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1026', '38', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1027', '38', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1028', '38', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1029', '38', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1030', '38', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1031', '38', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1032', '38', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1033', '38', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1034', '38', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1035', '38', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1036', '38', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1037', '38', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1038', '38', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1039', '39', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1040', '39', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1041', '39', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1042', '39', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1043', '39', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1044', '39', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1045', '39', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1046', '39', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1047', '39', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1048', '39', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1049', '39', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1050', '39', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1051', '39', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1052', '39', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1053', '39', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1054', '39', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1055', '39', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1056', '39', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1057', '39', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1058', '39', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1059', '39', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1060', '39', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1061', '39', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1062', '39', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1063', '39', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1064', '39', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1065', '39', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1066', '39', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1067', '39', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1068', '39', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1069', '39', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1070', '39', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1071', '39', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1072', '39', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1073', '39', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1074', '39', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1075', '39', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1076', '39', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1077', '39', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1078', '39', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1079', '40', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1080', '40', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1081', '40', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1082', '40', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1083', '40', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1084', '40', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1085', '40', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1086', '40', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1087', '40', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1088', '40', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1089', '40', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1090', '40', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1091', '40', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1092', '40', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1093', '40', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1094', '40', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1095', '40', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1096', '40', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1097', '40', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1098', '40', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1099', '40', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1100', '40', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1101', '40', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1102', '40', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1103', '40', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1104', '40', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1105', '40', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1106', '40', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1107', '40', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1108', '40', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1109', '40', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1110', '40', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1111', '40', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1112', '40', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1113', '40', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1114', '40', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1115', '40', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1116', '40', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1117', '40', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1118', '40', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1119', '41', '58', 'A', '0');
INSERT INTO `test_detail` VALUES ('1120', '41', '59', 'B', '0');
INSERT INTO `test_detail` VALUES ('1121', '41', '60', 'C', '0');
INSERT INTO `test_detail` VALUES ('1122', '41', '61', 'D', '0');
INSERT INTO `test_detail` VALUES ('1123', '41', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1124', '41', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1125', '41', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1126', '41', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1127', '41', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1128', '41', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1129', '41', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1130', '41', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1131', '41', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1132', '41', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1133', '41', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1134', '41', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1135', '41', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1136', '41', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1137', '41', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1138', '41', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1139', '41', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1140', '41', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1141', '41', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1142', '41', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1143', '41', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1144', '41', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1145', '41', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1146', '41', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1147', '41', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1148', '41', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1149', '41', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1150', '41', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1151', '41', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1152', '41', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1153', '41', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1154', '41', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1155', '41', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1156', '41', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1157', '41', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1158', '41', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1159', '42', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1160', '42', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1161', '42', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1162', '42', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1163', '42', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1164', '42', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1165', '42', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1166', '42', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1167', '42', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1168', '42', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1169', '42', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1170', '42', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1171', '42', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1172', '42', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1173', '42', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1174', '42', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1175', '42', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1176', '42', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1177', '42', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1178', '42', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1179', '42', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1180', '42', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1181', '42', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1182', '42', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1183', '42', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1184', '42', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1185', '42', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1186', '42', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1187', '42', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1188', '42', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1189', '42', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1190', '42', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1191', '42', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1192', '42', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1193', '42', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1194', '42', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1195', '42', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1196', '42', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1197', '42', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1198', '42', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1199', '43', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1200', '43', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1201', '43', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1202', '43', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1203', '43', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1204', '43', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1205', '43', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1206', '43', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1207', '43', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1208', '43', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1209', '43', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1210', '43', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1211', '43', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1212', '43', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1213', '43', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1214', '43', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1215', '43', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1216', '43', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1217', '43', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1218', '43', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1219', '43', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1220', '43', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1221', '43', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1222', '43', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1223', '43', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1224', '43', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1225', '43', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1226', '43', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1227', '43', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1228', '43', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1229', '43', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1230', '43', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1231', '43', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1232', '43', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1233', '43', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1234', '43', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1235', '43', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1236', '43', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1237', '43', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1238', '43', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1239', '44', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1240', '44', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1241', '44', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1242', '44', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1243', '44', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1244', '44', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1245', '44', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1246', '44', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1247', '44', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1248', '44', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1249', '44', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1250', '44', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1251', '44', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1252', '44', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1253', '44', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1254', '44', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1255', '44', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1256', '44', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1257', '44', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1258', '44', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1259', '44', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1260', '44', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1261', '44', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1262', '44', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1263', '44', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1264', '44', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1265', '44', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1266', '44', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1267', '44', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1268', '44', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1269', '44', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1270', '44', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1271', '44', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1272', '44', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1273', '44', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1274', '44', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1275', '44', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1276', '44', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1277', '44', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1278', '44', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1279', '45', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1280', '45', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1281', '45', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1282', '45', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1283', '45', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1284', '45', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1285', '45', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1286', '45', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1287', '45', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1288', '45', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1289', '45', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1290', '45', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1291', '45', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1292', '45', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1293', '45', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1294', '45', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1295', '45', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1296', '45', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1297', '45', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1298', '45', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1299', '45', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1300', '45', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1301', '45', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1302', '45', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1303', '45', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1304', '45', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1305', '45', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1306', '45', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1307', '45', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1308', '45', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1309', '45', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1310', '45', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1311', '45', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1312', '45', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1313', '45', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1314', '45', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1315', '45', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1316', '45', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1317', '45', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1318', '45', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1319', '46', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1320', '46', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1321', '46', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1322', '46', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1323', '46', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1324', '46', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1325', '46', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1326', '46', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1327', '46', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1328', '46', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1329', '46', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1330', '46', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1331', '46', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1332', '46', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1333', '46', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1334', '46', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1335', '46', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1336', '46', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1337', '46', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1338', '46', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1339', '46', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1340', '46', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1341', '46', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1342', '46', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1343', '46', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1344', '46', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1345', '46', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1346', '46', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1347', '46', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1348', '46', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1349', '46', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1350', '46', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1351', '46', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1352', '46', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1353', '46', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1354', '46', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1355', '46', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1356', '46', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1357', '46', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1358', '46', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1359', '47', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1360', '47', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1361', '47', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1362', '47', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1363', '47', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1364', '47', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1365', '47', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1366', '47', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1367', '47', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1368', '47', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1369', '47', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1370', '47', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1371', '47', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1372', '47', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1373', '47', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1374', '47', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1375', '47', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1376', '47', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1377', '47', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1378', '47', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1379', '47', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1380', '47', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1381', '47', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1382', '47', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1383', '47', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1384', '47', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1385', '47', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1386', '47', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1387', '47', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1388', '47', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1389', '47', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1390', '47', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1391', '47', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1392', '47', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1393', '47', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1394', '47', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1395', '47', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1396', '47', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1397', '47', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1398', '47', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1399', '48', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1400', '48', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1401', '48', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1402', '48', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1403', '48', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1404', '48', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1405', '48', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1406', '48', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1407', '48', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1408', '48', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1409', '48', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1410', '48', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1411', '48', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1412', '48', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1413', '48', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1414', '48', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1415', '48', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1416', '48', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1417', '48', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1418', '48', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1419', '48', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1420', '48', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1421', '48', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1422', '48', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1423', '48', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1424', '48', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1425', '48', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1426', '48', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1427', '48', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1428', '48', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1429', '48', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1430', '48', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1431', '48', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1432', '48', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1433', '48', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1434', '48', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1435', '48', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1436', '48', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1437', '48', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1438', '48', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1439', '49', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1440', '49', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1441', '49', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1442', '49', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1443', '49', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1444', '49', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1445', '49', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1446', '49', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1447', '49', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1448', '49', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1449', '49', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1450', '49', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1451', '49', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1452', '49', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1453', '49', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1454', '49', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1455', '49', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1456', '49', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1457', '49', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1458', '49', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1459', '49', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1460', '49', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1461', '49', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1462', '49', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1463', '49', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1464', '49', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1465', '49', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1466', '49', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1467', '49', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1468', '49', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1469', '49', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1470', '49', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1471', '49', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1472', '49', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1473', '49', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1474', '49', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1475', '49', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1476', '49', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1477', '49', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1478', '49', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1479', '50', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1480', '50', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1481', '50', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1482', '50', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1483', '50', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1484', '50', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1485', '50', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1486', '50', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1487', '50', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1488', '50', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1489', '50', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1490', '50', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1491', '50', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1492', '50', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1493', '50', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1494', '50', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1495', '50', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1496', '50', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1497', '50', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1498', '50', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1499', '50', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1500', '50', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1501', '50', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1502', '50', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1503', '50', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1504', '50', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1505', '50', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1506', '50', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1507', '50', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1508', '50', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1509', '50', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1510', '50', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1511', '50', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1512', '50', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1513', '50', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1514', '50', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1515', '50', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1516', '50', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1517', '50', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1518', '50', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1519', '51', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1520', '51', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1521', '51', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1522', '51', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1523', '51', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1524', '51', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1525', '51', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1526', '51', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1527', '51', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1528', '51', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1529', '51', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1530', '51', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1531', '51', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1532', '51', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1533', '51', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1534', '51', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1535', '51', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1536', '51', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1537', '51', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1538', '51', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1539', '51', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1540', '51', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1541', '51', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1542', '51', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1543', '51', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1544', '51', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1545', '51', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1546', '51', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1547', '51', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1548', '51', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1549', '51', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1550', '51', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1551', '51', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1552', '51', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1553', '51', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1554', '51', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1555', '51', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1556', '51', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1557', '51', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1558', '51', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1559', '52', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1560', '52', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1561', '52', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1562', '52', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1563', '52', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1564', '52', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1565', '52', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1566', '52', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1567', '52', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1568', '52', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1569', '52', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1570', '52', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1571', '52', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1572', '52', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1573', '52', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1574', '52', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1575', '52', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1576', '52', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1577', '52', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1578', '52', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1579', '52', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1580', '52', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1581', '52', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1582', '52', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1583', '52', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1584', '52', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1585', '52', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1586', '52', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1587', '52', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1588', '52', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1589', '52', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1590', '52', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1591', '52', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1592', '52', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1593', '52', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1594', '52', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1595', '52', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1596', '52', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1597', '52', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1598', '52', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1599', '53', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1600', '53', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1601', '53', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1602', '53', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1603', '53', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1604', '53', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1605', '53', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1606', '53', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1607', '53', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1608', '53', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1609', '53', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1610', '53', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1611', '53', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1612', '53', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1613', '53', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1614', '53', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1615', '53', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1616', '53', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1617', '53', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1618', '53', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1619', '53', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1620', '53', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1621', '53', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1622', '53', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1623', '53', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1624', '53', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1625', '53', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1626', '53', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1627', '53', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1628', '53', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1629', '53', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1630', '53', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1631', '53', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1632', '53', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1633', '53', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1634', '53', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1635', '53', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1636', '53', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1637', '53', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1638', '53', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1639', '54', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1640', '54', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1641', '54', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1642', '54', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1643', '54', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1644', '54', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1645', '54', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1646', '54', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1647', '54', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1648', '54', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1649', '54', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1650', '54', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1651', '54', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1652', '54', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1653', '54', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1654', '54', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1655', '54', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1656', '54', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1657', '54', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1658', '54', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1659', '54', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1660', '54', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1661', '54', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1662', '54', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1663', '54', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1664', '54', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1665', '54', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1666', '54', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1667', '54', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1668', '54', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1669', '54', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1670', '54', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1671', '54', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1672', '54', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1673', '54', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1674', '54', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1675', '54', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1676', '54', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1677', '54', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1678', '54', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1679', '55', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1680', '55', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1681', '55', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1682', '55', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1683', '55', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1684', '55', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1685', '55', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1686', '55', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1687', '55', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1688', '55', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1689', '55', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1690', '55', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1691', '55', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1692', '55', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1693', '55', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1694', '55', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1695', '55', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1696', '55', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1697', '55', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1698', '55', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1699', '55', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1700', '55', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1701', '55', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1702', '55', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1703', '55', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1704', '55', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1705', '55', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1706', '55', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1707', '55', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1708', '55', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1709', '55', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1710', '55', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1711', '55', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1712', '55', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1713', '55', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1714', '55', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1715', '55', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1716', '55', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1717', '55', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1718', '55', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1719', '56', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1720', '56', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1721', '56', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1722', '56', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1723', '56', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1724', '56', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1725', '56', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1726', '56', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1727', '56', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1728', '56', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1729', '56', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1730', '56', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1731', '56', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1732', '56', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1733', '56', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1734', '56', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1735', '56', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1736', '56', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1737', '56', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1738', '56', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1739', '56', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1740', '56', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1741', '56', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1742', '56', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1743', '56', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1744', '56', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1745', '56', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1746', '56', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1747', '56', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1748', '56', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1749', '56', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1750', '56', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1751', '56', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1752', '56', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1753', '56', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1754', '56', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1755', '56', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1756', '56', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1757', '56', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1758', '56', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1759', '57', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1760', '57', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1761', '57', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1762', '57', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1763', '57', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1764', '57', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1765', '57', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1766', '57', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1767', '57', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1768', '57', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1769', '57', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1770', '57', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1771', '57', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1772', '57', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1773', '57', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1774', '57', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1775', '57', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1776', '57', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1777', '57', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1778', '57', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1779', '57', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1780', '57', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1781', '57', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1782', '57', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1783', '57', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1784', '57', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1785', '57', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1786', '57', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1787', '57', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1788', '57', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1789', '57', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1790', '57', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1791', '57', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1792', '57', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1793', '57', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1794', '57', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1795', '57', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1796', '57', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1797', '57', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1798', '57', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1799', '58', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1800', '58', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1801', '58', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1802', '58', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1803', '58', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1804', '58', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1805', '58', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1806', '58', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1807', '58', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1808', '58', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1809', '58', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1810', '58', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1811', '58', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1812', '58', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1813', '58', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1814', '58', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1815', '58', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1816', '58', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1817', '58', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1818', '58', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1819', '58', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1820', '58', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1821', '58', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1822', '58', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1823', '58', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1824', '58', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1825', '58', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1826', '58', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1827', '58', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1828', '58', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1829', '58', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1830', '58', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1831', '58', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1832', '58', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1833', '58', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1834', '58', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1835', '58', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1836', '58', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1837', '58', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1838', '58', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1839', '59', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1840', '59', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1841', '59', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1842', '59', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1843', '59', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1844', '59', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1845', '59', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1846', '59', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1847', '59', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1848', '59', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1849', '59', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1850', '59', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1851', '59', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1852', '59', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1853', '59', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1854', '59', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1855', '59', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1856', '59', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1857', '59', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1858', '59', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1859', '59', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1860', '59', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1861', '59', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1862', '59', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1863', '59', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1864', '59', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1865', '59', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1866', '59', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1867', '59', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1868', '59', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1869', '59', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1870', '59', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1871', '59', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1872', '59', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1873', '59', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1874', '59', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1875', '59', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1876', '59', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1877', '59', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1878', '59', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1879', '60', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1880', '60', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1881', '60', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1882', '60', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1883', '60', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1884', '60', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1885', '60', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1886', '60', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1887', '60', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1888', '60', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1889', '60', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1890', '60', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1891', '60', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1892', '60', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1893', '60', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1894', '60', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1895', '60', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1896', '60', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1897', '60', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1898', '60', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1899', '60', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1900', '60', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1901', '60', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1902', '60', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1903', '60', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1904', '60', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1905', '60', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1906', '60', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1907', '60', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1908', '60', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1909', '60', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1910', '60', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1911', '60', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1912', '60', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1913', '60', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1914', '60', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1915', '60', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1916', '60', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1917', '60', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1918', '60', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1919', '61', '58', 'N', '0');
INSERT INTO `test_detail` VALUES ('1920', '61', '59', 'N', '0');
INSERT INTO `test_detail` VALUES ('1921', '61', '60', 'N', '0');
INSERT INTO `test_detail` VALUES ('1922', '61', '61', 'N', '0');
INSERT INTO `test_detail` VALUES ('1923', '61', '62', 'N', '0');
INSERT INTO `test_detail` VALUES ('1924', '61', '63', 'N', '0');
INSERT INTO `test_detail` VALUES ('1925', '61', '64', 'N', '0');
INSERT INTO `test_detail` VALUES ('1926', '61', '65', 'N', '0');
INSERT INTO `test_detail` VALUES ('1927', '61', '66', 'N', '0');
INSERT INTO `test_detail` VALUES ('1928', '61', '67', 'N', '0');
INSERT INTO `test_detail` VALUES ('1929', '61', '68', 'N', '0');
INSERT INTO `test_detail` VALUES ('1930', '61', '69', 'N', '0');
INSERT INTO `test_detail` VALUES ('1931', '61', '70', 'N', '0');
INSERT INTO `test_detail` VALUES ('1932', '61', '71', 'N', '0');
INSERT INTO `test_detail` VALUES ('1933', '61', '72', 'N', '0');
INSERT INTO `test_detail` VALUES ('1934', '61', '73', 'N', '0');
INSERT INTO `test_detail` VALUES ('1935', '61', '74', 'N', '0');
INSERT INTO `test_detail` VALUES ('1936', '61', '75', 'N', '0');
INSERT INTO `test_detail` VALUES ('1937', '61', '76', 'N', '0');
INSERT INTO `test_detail` VALUES ('1938', '61', '77', 'N', '0');
INSERT INTO `test_detail` VALUES ('1939', '61', '78', 'N', '0');
INSERT INTO `test_detail` VALUES ('1940', '61', '79', 'N', '0');
INSERT INTO `test_detail` VALUES ('1941', '61', '80', 'N', '0');
INSERT INTO `test_detail` VALUES ('1942', '61', '81', 'N', '0');
INSERT INTO `test_detail` VALUES ('1943', '61', '82', 'N', '0');
INSERT INTO `test_detail` VALUES ('1944', '61', '83', 'N', '0');
INSERT INTO `test_detail` VALUES ('1945', '61', '84', 'N', '0');
INSERT INTO `test_detail` VALUES ('1946', '61', '85', 'N', '0');
INSERT INTO `test_detail` VALUES ('1947', '61', '86', 'N', '0');
INSERT INTO `test_detail` VALUES ('1948', '61', '87', 'N', '0');
INSERT INTO `test_detail` VALUES ('1949', '61', '88', 'N', '0');
INSERT INTO `test_detail` VALUES ('1950', '61', '89', 'N', '0');
INSERT INTO `test_detail` VALUES ('1951', '61', '90', 'N', '0');
INSERT INTO `test_detail` VALUES ('1952', '61', '91', 'N', '0');
INSERT INTO `test_detail` VALUES ('1953', '61', '92', 'N', '0');
INSERT INTO `test_detail` VALUES ('1954', '61', '93', 'N', '0');
INSERT INTO `test_detail` VALUES ('1955', '61', '94', 'N', '0');
INSERT INTO `test_detail` VALUES ('1956', '61', '95', 'N', '0');
INSERT INTO `test_detail` VALUES ('1957', '61', '96', 'N', '0');
INSERT INTO `test_detail` VALUES ('1958', '61', '97', 'N', '0');
INSERT INTO `test_detail` VALUES ('1959', '62', '21', 'D', '0');
INSERT INTO `test_detail` VALUES ('1960', '62', '22', 'C', '0');
INSERT INTO `test_detail` VALUES ('1961', '62', '23', 'C', '0');
INSERT INTO `test_detail` VALUES ('1962', '62', '24', 'A', '1');
INSERT INTO `test_detail` VALUES ('1963', '62', '25', 'D', '0');
INSERT INTO `test_detail` VALUES ('1964', '62', '26', 'D', '0');
INSERT INTO `test_detail` VALUES ('1965', '62', '27', 'D', '1');
INSERT INTO `test_detail` VALUES ('1966', '62', '28', 'A', '1');
INSERT INTO `test_detail` VALUES ('1967', '62', '29', 'C', '0');
INSERT INTO `test_detail` VALUES ('1968', '62', '30', 'B', '0');
INSERT INTO `test_detail` VALUES ('1969', '63', '180', 'N', '0');
INSERT INTO `test_detail` VALUES ('1970', '63', '181', 'N', '0');
INSERT INTO `test_detail` VALUES ('1971', '63', '182', 'N', '0');
INSERT INTO `test_detail` VALUES ('1972', '63', '183', 'N', '0');
INSERT INTO `test_detail` VALUES ('1973', '63', '184', 'N', '0');
INSERT INTO `test_detail` VALUES ('1974', '63', '185', 'N', '0');
INSERT INTO `test_detail` VALUES ('1975', '63', '186', 'N', '0');
INSERT INTO `test_detail` VALUES ('1976', '63', '187', 'N', '0');
INSERT INTO `test_detail` VALUES ('1977', '63', '188', 'N', '0');
INSERT INTO `test_detail` VALUES ('1978', '63', '189', 'N', '0');
INSERT INTO `test_detail` VALUES ('1979', '63', '190', 'N', '0');
INSERT INTO `test_detail` VALUES ('1980', '63', '191', 'N', '0');
INSERT INTO `test_detail` VALUES ('1981', '63', '192', 'N', '0');
INSERT INTO `test_detail` VALUES ('1982', '63', '193', 'N', '0');
INSERT INTO `test_detail` VALUES ('1983', '63', '194', 'N', '0');
INSERT INTO `test_detail` VALUES ('1984', '63', '195', 'N', '0');
INSERT INTO `test_detail` VALUES ('1985', '63', '196', 'N', '0');
INSERT INTO `test_detail` VALUES ('1986', '63', '197', 'N', '0');
INSERT INTO `test_detail` VALUES ('1987', '63', '198', 'N', '0');
INSERT INTO `test_detail` VALUES ('1988', '63', '199', 'N', '0');
INSERT INTO `test_detail` VALUES ('1989', '63', '200', 'N', '0');
INSERT INTO `test_detail` VALUES ('1990', '63', '201', 'N', '0');
INSERT INTO `test_detail` VALUES ('1991', '63', '202', 'N', '0');
INSERT INTO `test_detail` VALUES ('1992', '63', '203', 'N', '0');
INSERT INTO `test_detail` VALUES ('1993', '63', '204', 'N', '0');
INSERT INTO `test_detail` VALUES ('1994', '63', '205', 'N', '0');
INSERT INTO `test_detail` VALUES ('1995', '63', '206', 'N', '0');
INSERT INTO `test_detail` VALUES ('1996', '63', '207', 'N', '0');
INSERT INTO `test_detail` VALUES ('1997', '63', '208', 'N', '0');
INSERT INTO `test_detail` VALUES ('1998', '63', '209', 'N', '0');
INSERT INTO `test_detail` VALUES ('1999', '63', '210', 'N', '0');
INSERT INTO `test_detail` VALUES ('2000', '63', '211', 'N', '0');
INSERT INTO `test_detail` VALUES ('2001', '63', '212', 'N', '0');
INSERT INTO `test_detail` VALUES ('2002', '63', '213', 'N', '0');
INSERT INTO `test_detail` VALUES ('2003', '63', '214', 'N', '0');
INSERT INTO `test_detail` VALUES ('2004', '63', '215', 'N', '0');
INSERT INTO `test_detail` VALUES ('2005', '63', '216', 'N', '0');
INSERT INTO `test_detail` VALUES ('2006', '63', '217', 'N', '0');
INSERT INTO `test_detail` VALUES ('2007', '63', '218', 'N', '0');
INSERT INTO `test_detail` VALUES ('2008', '63', '219', 'N', '0');

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (
  `id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `username` varchar(16) NOT NULL,
  `password` varchar(16) NOT NULL,
  `type` varchar(255) NOT NULL,
  `status` varchar(255) DEFAULT NULL,
  `university` varchar(255) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  `introduce` varchar(2047) DEFAULT NULL,
  `register_date` date DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of users
-- ----------------------------
INSERT INTO `users` VALUES ('1', 'suzelin', '123456', 'user', '', '', '', '', '', null);
INSERT INTO `users` VALUES ('4', 'szl', '123456', 'admin', null, null, null, null, null, null);
INSERT INTO `users` VALUES ('5', 'teacher', '123456', 'user', 'teacher', '西安电子科技大学', '孙万蓉', '教授', '孙万蓉，西安电子科技大学教授，国家级精品课程“数字电路及系统设计”课程负责人，国家级精品课程“数字电路及系统设计”课程共享建设负责人,第三届校级教学名师。西安电子科技大学电子工程学院教授委员会常任委员。第二届全国高校青年教师教学竞赛决赛专家评委，第二届和第三届陕西省高校青年教师教学竞赛决赛专家评委。\r\n\r\n负责和参与了多项教育部、省级和学校教学改项目，主编了《数字电路与系统设计》一书，参与编写了《数字电子技术基础》国家十一五规划教材和《通讯电子线路》等教材，参与编译了电子工业出版社出版的《传感器及其应用》一书。“全方位、立体化、多视角课程建设研究与实践”获省教学成果二等奖；多项教改项目获校优秀教学成果一、二等奖。参与“全国大学生电子设计竞赛”赛前指导，指导的学生获得了国家级一等奖和二等奖。科研的主要研究方向为信号与图像处理、虚拟仪器和医学仪器、物联网感知层信息采集、传输与监测管理等。先后承担和参与了多项国家自然科学基金、863项目、省自然科学基金和横向科研项目。多个项目获省部级奖，在国内国外发表科研论文30余篇。', null);
INSERT INTO `users` VALUES ('6', 'wengkai', '123456', 'user', 'teacher', '浙江大学', '翁恺', '教师', '计算机博士，浙江大学计算机学院教师，ACM-ICPC优秀教练奖得主，2011世界总决赛金牌教练。主要讲授包括C、C++、Java程序设计，程序设计语言原理，计算机体系结构，嵌入式系统等课程。\r\n\r\n专业方向为嵌入式操作系统和嵌入式系统应用，是国内Arduino和树莓派应用的鼓吹者，翻译出版了多本相关书籍，在创客界交友广泛。\r\n\r\n2004年前后的Java教学视频在网络上流传甚广，现在在网易云课堂 上开设有Java、C++、Arduino等多门课程。\r\n\r\n业余爱好无线电，1988年开始玩业余电台，电台呼号BA5AG，主要玩莫尔斯码、短波、数据通信和卫星通信。是浙大传统毅行的发起者和早期组织者之一。', null);
INSERT INTO `users` VALUES ('7', 'lifengxia', '123456', 'user', 'teacher', '北京理工大学', '李凤霞', '教授', '北京理工大学计算机学院教授，北京市教学名师。任北京理工大学计算机学院基础教学部主任、教育部大学计算机虚拟仿真实验教学中心主任、 虚拟现实与仿真计算学科方向带头人。现担任教育部高等学校“大学计算机课程”教学指导委员会副主任；全国高等院校计算机基础教育研究会副会长；中国计算机学会虚拟现实与可视化专委会副主任。特聘为北京市教育委员会 “北京高等学校计算机与信息类专业群专家委员会委员兼教学协作委员会委员”。 目前是国家级精品课、国家级精品资源共享课程负责人、国家级优秀教学团队负责人。', null);
INSERT INTO `users` VALUES ('8', 'suxiaohong', '123456', 'user', 'teacher', '哈尔滨工业大学', '苏小红', '教授', '苏小红，女，博士，哈尔滨工业大学计算机科学与技术学院航天软件工程研究中心教授，博士生导师，中国计算机学会高级会员，计算机科学与技术国家实验教学示范中心副主任，计算机语言基础教研室主任，校教学带头人，校级教学名师奖和宝钢优秀教师奖获得者，2006-2010年教育部高等学校计算机专业教学指导委员会东北地区专家工作组成员，电子工业出版社特聘专家。曾先后被评为校“三育人”先进工作者、校优秀教师、校优秀共产党员、黑龙江省高校师德先进个人、黑龙江省优秀教师。现为国家级精品课C语言程序设计和黑龙江省省级精品课计算机图形学的主持人。', null);
INSERT INTO `users` VALUES ('9', 'zhangyuchun', '123456', 'user', 'teacher', '吉林大学', '张玉春', '教授', '暂无老师简介', null);
INSERT INTO `users` VALUES ('10', '123', '123', 'user', null, null, null, null, null, null);
INSERT INTO `users` VALUES ('11', 'a85818036', 'a1212qwe1212', 'user', null, null, null, null, null, null);
INSERT INTO `users` VALUES ('12', 'maxiao', '12345678', 'user', null, null, null, null, null, null);

-- ----------------------------
-- Table structure for user_course
-- ----------------------------
DROP TABLE IF EXISTS `user_course`;
CREATE TABLE `user_course` (
  `id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL,
  `course_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of user_course
-- ----------------------------
INSERT INTO `user_course` VALUES ('1', '1', '6');
INSERT INTO `user_course` VALUES ('3', '1', '5');
INSERT INTO `user_course` VALUES ('4', '1', '4');
INSERT INTO `user_course` VALUES ('5', '1', '3');
INSERT INTO `user_course` VALUES ('6', '1', '2');
INSERT INTO `user_course` VALUES ('7', '1', '1');
INSERT INTO `user_course` VALUES ('8', '7', '2');
INSERT INTO `user_course` VALUES ('9', '11', '6');
INSERT INTO `user_course` VALUES ('10', '12', '3');

-- ----------------------------
-- Table structure for user_program
-- ----------------------------
DROP TABLE IF EXISTS `user_program`;
CREATE TABLE `user_program` (
  `id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL,
  `program_id` int(11) DEFAULT NULL,
  `user_code` varchar(4095) DEFAULT NULL,
  `state` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=177 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of user_program
-- ----------------------------
INSERT INTO `user_program` VALUES ('1', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n', '-1');
INSERT INTO `user_program` VALUES ('2', '2', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '1');
INSERT INTO `user_program` VALUES ('3', '3', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '1');
INSERT INTO `user_program` VALUES ('4', '4', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '1');
INSERT INTO `user_program` VALUES ('5', '5', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '1');
INSERT INTO `user_program` VALUES ('6', '6', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '1');
INSERT INTO `user_program` VALUES ('79', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('80', '1', '2', '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\ntypedef	struct	aa\r\n{  int   data;\r\n	struct	aa	*next;\r\n} NODE;\r\nNODE *Creatlink(int n, int m) \r\n{\r\n	NODE *h=NULL, *p, *s; int i;\r\n\r\n/**********found***********/\r\n	p=(NODE *)malloc(sizeof(NODE));\r\n	h=p;\r\n	p->next=NULL;\r\n	for(i=1; i<=n; i++)\r\n	{   \r\n		s=(NODE *)malloc(sizeof(NODE));\r\n		s->data=rand()%m;	s->next=p->next;\r\n		p->next=s;	p=p->next;\r\n	}\r\n/**********found***********/\r\n	return	h;\r\n}\r\n\r\nvoid outlink(NODE *h)\r\n{  \r\n	NODE  *p; p=h->next;\r\n	printf(\"\\n\\nTHE	LIST :\\n\\n	HEAD \");\r\n	while(p)\r\n	{ \r\n		printf(\"->%d \",p->data);\r\n		p=p->next;\r\n	}\r\n	printf(\"\\n\");\r\n}\r\n\r\nvoid main()\r\n{ \r\n	NODE *head; head=Creatlink(8,22);\r\n	outlink(head);\r\n}', '1');
INSERT INTO `user_program` VALUES ('81', '1', '3', '#include<string.h> \r\n#include<stdio.h> \r\n#define N 80 \r\nint fun(char *s) \r\n{ \r\n} \r\nvoid main() \r\n{ \r\n	FILE *wf; \r\n	char line[N]; \r\n	int num=0; \r\n	printf(\"Enter a string:\\n \"); \r\n	gets(line); \r\n	num=fun(line); \r\n	printf(\"The number of word is:%d\\n\\n \",num); \r\n/******************************/ \r\n	wf=fopen(\"out.dat\",\"w\"); \r\n	fprintf(wf,\"%d\",fun(\"a big car\")); \r\n	fclose(wf); \r\n/*****************************/ \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('82', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '1');
INSERT INTO `user_program` VALUES ('83', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('84', '1', '3', '#include<string.h> \r\n#include<stdio.h> \r\n#define N 80 \r\nint fun(char *s) \r\n{ \r\n} \r\nvoid main() \r\n{ \r\n	FILE *wf; \r\n	char line[N]; \r\n	int num=0; \r\n	printf(\"Enter a string:\\n \"); \r\n	gets(line); \r\n	num=fun(line); \r\n	printf(\"The number of word is:%d\\n\\n \",num); \r\n/******************************/ \r\n	wf=fopen(\"out.dat\",\"w\"); \r\n	fprintf(wf,\"%d\",fun(\"a big car\")); \r\n	fclose(wf); \r\n/*****************************/ \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('85', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('86', '1', '2', '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\ntypedef	struct	aa\r\n{  int   data;\r\n	struct	aa	*next;\r\n} NODE;\r\nNODE *Creatlink(int n, int m) \r\n{\r\n	NODE *h=NULL, *p, *s; int i;\r\n\r\n/**********found***********/\r\n	p=(NODE *)malloc(sizeof(NODE));\r\n	h=p;\r\n	p->next=NULL;\r\n	for(i=1; i<=n; i++)\r\n	{   \r\n		s=(NODE *)malloc(sizeof(NODE));\r\n		s->data=rand()%m;	s->next=p->next;\r\n		p->next=s;	p=p->next;\r\n	}\r\n/**********found***********/\r\n	return	h;\r\n}\r\n\r\nvoid outlink(NODE *h)\r\n{  \r\n	NODE  *p; p=h->next;\r\n	printf(\"\\n\\nTHE	LIST :\\n\\n	HEAD \");\r\n	while(p)\r\n	{ \r\n		printf(\"->%d \",p->data);\r\n		p=p->next;\r\n	}\r\n	printf(\"\\n\");\r\n}\r\n\r\nvoid main()\r\n{ \r\n	NODE *head; head=Creatlink(8,22);\r\n	outlink(head);\r\n}', '-1');
INSERT INTO `user_program` VALUES ('87', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n/* ????????????????????????????????????????????????è???????????è?°???	???è?¨?¤??????????è????????*/\r\n			j++;\r\n	return	j;	/* è????????è???????° */\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('94', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('95', '1', '2', '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\ntypedef	struct	aa\r\n{  int   data;\r\n	struct	aa	*next;\r\n} NODE;\r\nNODE *Creatlink(int n, int m) \r\n{\r\n	NODE *h=NULL, *p, *s; int i;\r\n\r\n/**********found***********/\r\n	p=(NODE *)malloc(sizeof(NODE));\r\n	h=p;\r\n	p->next=NULL;\r\n	for(i=1; i<=n; i++)\r\n	{   \r\n		s=(NODE *)malloc(sizeof(NODE));\r\n		s->data=rand()%m;	s->next=p->next;\r\n		p->next=s;	p=p->next;\r\n	}\r\n/**********found***********/\r\n	return	h;\r\n}\r\n\r\nvoid outlink(NODE *h)\r\n{  \r\n	NODE  *p; p=h->next;\r\n	printf(\"\\n\\nTHE	LIST :\\n\\n	HEAD \");\r\n	while(p)\r\n	{ \r\n		printf(\"->%d \",p->data);\r\n		p=p->next;\r\n	}\r\n	printf(\"\\n\");\r\n}\r\n\r\nvoid main()\r\n{ \r\n	NODE *head; head=Creatlink(8,22);\r\n	outlink(head);\r\n}', '-1');
INSERT INTO `user_program` VALUES ('96', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n/* ????????????????????????????????????????????????è???????????è?°???	???è?¨?¤??????????è????????*/\r\n			j++;\r\n	return	j;	/* è????????è???????° */\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('97', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('98', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('99', '1', '3', '#include<string.h> \r\n#include<stdio.h> \r\n#define N 80 \r\nint fun(char *s) \r\n{ \r\nint i,j=0;  \r\nfor(i=0;s[i]!=\'\\0\';i++)  \r\nif(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\')) /* ????????????????????????????????????????????????è???????????è?°??? ???è?¨?¤??????????è????????*/  \r\nj++;  \r\nreturn j; /* è????????è???????° */ \r\n} \r\nvoid main() \r\n{ \r\n	FILE *wf; \r\n	char line[N]; \r\n	int num=0; \r\n	printf(\"Enter a string:\\n \"); \r\n	gets(line); \r\n	num=fun(line); \r\n	printf(\"The number of word is:%d\\n\\n \",num); \r\n/******************************/ \r\n	wf=fopen(\"out.dat\",\"w\"); \r\n	fprintf(wf,\"%d\",fun(\"a big car\")); \r\n	fclose(wf); \r\n/*****************************/ \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('100', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('101', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('102', '1', '3', '#include<string.h> \r\n#include<stdio.h> \r\n#define N 80 \r\nint fun(char *s) \r\n{ \r\nint i,j=0;  \r\nfor(i=0;s[i]!=\'\\0\';i++)  \r\nif(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\')) \r\nj++;  \r\nreturn j; \r\n} \r\nvoid main() \r\n{ \r\n	FILE *wf; \r\n	char line[N]; \r\n	int num=0; \r\n	printf(\"Enter a string:\\n \"); \r\n	gets(line); \r\n	num=fun(line); \r\n	printf(\"The number of word is:%d\\n\\n \",num); \r\n/******************************/ \r\n	wf=fopen(\"out.dat\",\"w\"); \r\n	fprintf(wf,\"%d\",fun(\"a big car\")); \r\n	fclose(wf); \r\n/*****************************/ \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('103', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,fp);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '1');
INSERT INTO `user_program` VALUES ('104', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('105', '1', '3', '#include<string.h> \r\n#include<stdio.h> \r\n#define N 80 \r\nint fun(char *s) \r\n{ \r\n} \r\nvoid main() \r\n{ \r\n	FILE *wf; \r\n	char line[N]; \r\n	int num=0; \r\n	printf(\"Enter a string:\\n \"); \r\n	gets(line); \r\n	num=fun(line); \r\n	printf(\"The number of word is:%d\\n\\n \",num); \r\n/******************************/ \r\n	wf=fopen(\"out.dat\",\"w\"); \r\n	fprintf(wf,\"%d\",fun(\"a big car\")); \r\n	fclose(wf); \r\n/*****************************/ \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('106', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('107', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('108', '1', '3', '#include<string.h> \r\n#include<stdio.h> \r\n#define N 80 \r\nint fun(char *s) \r\n{ \r\nint i,j=0;  \r\nfor(i=0;s[i]!=\'\\0\';i++)  \r\nif(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\')) /* ????????????????????????????????????????????????è???????????è?°??? ???è?¨?¤??????????è????????*/  \r\nj++;  \r\nreturn j; /* è????????è???????° */  \r\n} \r\nvoid main() \r\n{ \r\n	FILE *wf; \r\n	char line[N]; \r\n	int num=0; \r\n	printf(\"Enter a string:\\n \"); \r\n	gets(line); \r\n	num=fun(line); \r\n	printf(\"The number of word is:%d\\n\\n \",num); \r\n/******************************/ \r\n	wf=fopen(\"out.dat\",\"w\"); \r\n	fprintf(wf,\"%d\",fun(\"a big car\")); \r\n	fclose(wf); \r\n/*****************************/ \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('109', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('110', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('111', '1', '3', '#include<string.h> \r\n#include<stdio.h> \r\n#define N 80 \r\nint fun(char *s) \r\n{ \r\nint i,j=0;  \r\nfor(i=0;s[i]!=\'\\0\';i++)  \r\nif(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\nj++;  \r\nreturn j; \r\n} \r\nvoid main() \r\n{ \r\n	FILE *wf; \r\n	char line[N]; \r\n	int num=0; \r\n	printf(\"Enter a string:\\n \"); \r\n	gets(line); \r\n	num=fun(line); \r\n	printf(\"The number of word is:%d\\n\\n \",num); \r\n/******************************/ \r\n	wf=fopen(\"out.dat\",\"w\"); \r\n	fprintf(wf,\"%d\",fun(\"a big car\")); \r\n	fclose(wf); \r\n/*****************************/ \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('112', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('113', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('114', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n/* ???§???????????????????????????????????????????????????????±?????????????????±??????????	?????±??????????????????????????????*/\r\n			j++;\r\n	return	j;	/* ???????????????????????? */\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('115', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('116', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('117', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n			j++;\r\n	return	j;\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('118', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n			j++;\r\n	return	j;\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('119', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('120', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('121', '1', '3', '#include<string.h> \r\n#include<stdio.h> \r\n#define N 80 \r\nint fun(char *s) \r\n{ \r\n} \r\nvoid main() \r\n{ \r\n	FILE *wf; \r\n	char line[N]; \r\n	int num=0; \r\n	printf(\"Enter a string:\\n \"); \r\n	gets(line); \r\n	num=fun(line); \r\n	printf(\"The number of word is:%d\\n\\n \",num); \r\n/******************************/ \r\n	wf=fopen(\"out.dat\",\"w\"); \r\n	fprintf(wf,\"%d\",fun(\"a big car\")); \r\n	fclose(wf); \r\n/*****************************/ \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('122', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('123', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('124', '1', '3', '#include<string.h> \r\n#include<stdio.h> \r\n#define N 80 \r\nint fun(char *s) \r\n{ \r\n} \r\nvoid main() \r\n{ \r\n	FILE *wf; \r\n	char line[N]; \r\n	int num=0; \r\n	printf(\"Enter a string:\\n \"); \r\n	gets(line); \r\n	num=fun(line); \r\n	printf(\"The number of word is:%d\\n\\n \",num); \r\n/******************************/ \r\n	wf=fopen(\"out.dat\",\"w\"); \r\n	fprintf(wf,\"%d\",fun(\"a big car\")); \r\n	fclose(wf); \r\n/*****************************/ \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('125', '1', '3', '#include<string.h> \r\n#include<stdio.h> \r\n#define N 80 \r\nint fun(char *s) \r\n{ \r\n} \r\nvoid main() \r\n{ \r\n	FILE *wf; \r\n	char line[N]; \r\n	int num=0; \r\n	printf(\"Enter a string:\\n \"); \r\n	gets(line); \r\n	num=fun(line); \r\n	printf(\"The number of word is:%d\\n\\n \",num); \r\n/******************************/ \r\n	wf=fopen(\"out.dat\",\"w\"); \r\n	fprintf(wf,\"%d\",fun(\"a big car\")); \r\n	fclose(wf); \r\n/*****************************/ \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('126', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,fp);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('127', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE *)malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return h; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('128', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n			j++;\r\n	return	j;\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('129', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,fp);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '1');
INSERT INTO `user_program` VALUES ('130', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n			j++;\r\n	return	j;\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('131', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,fp);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '1');
INSERT INTO `user_program` VALUES ('132', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,fp);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '1');
INSERT INTO `user_program` VALUES ('133', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n			j++;\r\n	return	j;\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('134', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n			j++;\r\n	return	j;\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('135', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n			j++;\r\n	return	j;\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('136', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('137', '1', '2', '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\ntypedef	struct	aa\r\n{  int   data;\r\n	struct	aa	*next;\r\n} NODE;\r\nNODE *Creatlink(int n, int m) \r\n{\r\n	NODE *h=NULL, *p, *s; int i;\r\n\r\n/**********found***********/\r\n	p=(NODE *)malloc(sizeof(NODE));\r\n	h=p;\r\n	p->next=NULL;\r\n	for(i=1; i<=n; i++)\r\n	{   \r\n		s=(NODE *)malloc(sizeof(NODE));\r\n		s->data=rand()%m;	s->next=p->next;\r\n		p->next=s;	p=p->next;\r\n	}\r\n/**********found***********/\r\n	return	h;\r\n}\r\n\r\nvoid outlink(NODE *h)\r\n{  \r\n	NODE  *p; p=h->next;\r\n	printf(\"\\n\\nTHE	LIST :\\n\\n	HEAD \");\r\n	while(p)\r\n	{ \r\n		printf(\"->%d \",p->data);\r\n		p=p->next;\r\n	}\r\n	printf(\"\\n\");\r\n}\r\n\r\nvoid main()\r\n{ \r\n	NODE *head; head=Creatlink(8,22);\r\n	outlink(head);\r\n}', '-1');
INSERT INTO `user_program` VALUES ('138', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n/* ????????????????????????????????????????????????è???????????è?°???	???è?¨?¤??????????è????????*/\r\n			j++;\r\n	return	j;	/* è????????è???????° */\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('139', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('140', '1', '2', '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\ntypedef	struct	aa\r\n{  int   data;\r\n	struct	aa	*next;\r\n} NODE;\r\nNODE *Creatlink(int n, int m) \r\n{\r\n	NODE *h=NULL, *p, *s; int i;\r\n\r\n/**********found***********/\r\n	p=(NODE *)malloc(sizeof(NODE));\r\n	h=p;\r\n	p->next=NULL;\r\n	for(i=1; i<=n; i++)\r\n	{   \r\n		s=(NODE *)malloc(sizeof(NODE));\r\n		s->data=rand()%m;	s->next=p->next;\r\n		p->next=s;	p=p->next;\r\n	}\r\n/**********found***********/\r\n	return	h;\r\n}\r\n\r\nvoid outlink(NODE *h)\r\n{  \r\n	NODE  *p; p=h->next;\r\n	printf(\"\\n\\nTHE	LIST :\\n\\n	HEAD \");\r\n	while(p)\r\n	{ \r\n		printf(\"->%d \",p->data);\r\n		p=p->next;\r\n	}\r\n	printf(\"\\n\");\r\n}\r\n\r\nvoid main()\r\n{ \r\n	NODE *head; head=Creatlink(8,22);\r\n	outlink(head);\r\n}', '-1');
INSERT INTO `user_program` VALUES ('141', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('142', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('143', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('144', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('145', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('146', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('147', '1', '1', '#include<stdio.h>\r\n#define N 5\r\n\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n    fwrite(&n,sizeof(STU),1,fp);\r\n    fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('148', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,fp);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('149', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,fp);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '1');
INSERT INTO `user_program` VALUES ('150', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,fp);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '1');
INSERT INTO `user_program` VALUES ('151', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('152', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n/* ????????????????????????????????????????????????è???????????è?°???	???è?¨?¤??????????è????????*/\r\n			j++;\r\n	return	j;	/* è????????è???????° */\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('153', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,fp);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '1');
INSERT INTO `user_program` VALUES ('154', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('155', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n			j++;\r\n	return	j;\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('156', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n			j++;\r\n	return	j;\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('157', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('158', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('159', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n			j++;\r\n	return	j;\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('160', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,fp);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '1');
INSERT INTO `user_program` VALUES ('161', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('162', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n/* ????????????????????????????????????????????????è???????????è?°???	???è?¨?¤??????????è????????*/\r\n			j++;\r\n	return	j;	/* è????????è???????° */\r\n}\r\n\r\nvoid main()\r\n{\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('163', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n			j++;\r\n	return	j;\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '1');
INSERT INTO `user_program` VALUES ('164', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n/* ????????????????????????????????????????????????è???????????è?°???	???è?¨?¤??????????è????????*/\r\n			j++;\r\n	return	j;	/* è????????è???????° */\r\n}\r\n\r\nvoid main()\r\n{\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('165', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('166', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('167', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	FILE *wf;\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n/* ????????????????????????????????????????????????è???????????è?°???	???è?¨?¤??????????è????????*/\r\n			j++;\r\n	return	j;	/* è????????è???????° */\r\n}\r\n\r\nvoid main()\r\n{\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '-1');
INSERT INTO `user_program` VALUES ('168', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(__1__,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(__2__,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,__3__);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('169', '1', '2', '#include <stdio.h> \r\n#include <stdlib.h> \r\ntypedef struct aa \r\n{ 	int data; \r\n	struct aa *next; \r\n} NODE; \r\nNODE *Creatlink(int n, int m) \r\n{ 	NODE *h=NULL, *p, *s; \r\n	int i; \r\n/**********found***********/ \r\n	p=(NODE )malloc(sizeof(NODE)); \r\n	h=p; \r\n	p->next=NULL; \r\n	for(i=1; i<=n; i++) \r\n	{ 	s=(NODE *)malloc(sizeof(NODE)); \r\n		s->data=rand()%m; s->next=p->next; \r\n		p->next=s; p=p->next; \r\n	} \r\n/**********found***********/ \r\n	return p; \r\n} \r\noutlink(NODE *h) \r\n{ 	NODE *p; \r\n	p=h->next; \r\n	printf(\"\\n\\nTHE LIST :\\n\\n HEAD \"); \r\n	while(p) \r\n	{ 	printf(\"->%d \",p->data); \r\n		p=p->next; \r\n	} \r\n	printf(\"\\n\"); \r\n} \r\nmain() \r\n{ 	NODE *head; \r\n	head=Creatlink(8,22); \r\n	outlink(head); \r\n}\r\n                  ', '-1');
INSERT INTO `user_program` VALUES ('170', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n/* ????????????????????????????????????????????????è???????????è?°???	???è?¨?¤??????????è????????*/\r\n			j++;\r\n	return	j;	/* è????????è???????° */\r\n}\r\n\r\nvoid main()\r\n{\r\n\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '1');
INSERT INTO `user_program` VALUES ('171', '1', '1', '#include<stdio.h>\r\n\r\n#define N 5\r\n\r\ntypedef struct student{\r\n    long sno;\r\n    char name[10];\r\n    float score[3];\r\n}STU;\r\nvoid fun(char*filename,STU n)\r\n{\r\n    FILE*fp; \r\n    /**********found**********/\r\n    fp=fopen(filename,\"rb+\"); \r\n    /**********found**********/\r\n    fseek(fp,-(long)sizeof(STU),SEEK_END);\r\n    /**********found**********/\r\n        fwrite(&n,sizeof(STU),1,fp);\r\n        fclose(fp);\r\n}\r\nvoid main()\r\n{\r\n    STU t[N]={{10001,\"MaChao\",91,92,77},{10002,\"CaoKai\",75,60,88},\r\n        {10003,\"LiSi\",85,70,78},{10004,\"FangFang\",90,82,87},\r\n        {10005,\"ZhangSan\",95,80,88}};\r\n    STU n={10006,\"ZhaoSi\",55,70,68},ss[N];\r\n    int i,j;FILE*fp;\r\n    fp=fopen(\"student.dat\",\"wb\");\r\n    fwrite(t,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    printf(\"\\nThe original data :\\n\\n\");\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)\r\n            printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    fun(\"student.dat\",n);\r\n    printf(\"\\nThe data after modifing :\\n\\n\");\r\n    fp=fopen(\"student.dat\",\"rb\");\r\n    fread(ss,sizeof(STU),N,fp);\r\n    fclose(fp);\r\n    for(j=0;j<N; j++)\r\n    {\r\n        printf(\"\\nNo: %ld	Name: %-8s	Scores:	\",ss[j].sno,ss[j].name);\r\n        for(i=0;i<3;i++)printf(\"%6.2f \",ss[j].score[i]);\r\n        printf(\"\\n\");\r\n    }\r\n}				\r\n\r\n                  ', '1');
INSERT INTO `user_program` VALUES ('172', '1', '2', '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\ntypedef	struct	aa\r\n{  int   data;\r\n	struct	aa	*next;\r\n} NODE;\r\nNODE *Creatlink(int n, int m) \r\n{\r\n	NODE *h=NULL, *p, *s; int i;\r\n\r\n/**********found***********/\r\n	p=(NODE *)malloc(sizeof(NODE));\r\n	h=p;\r\n	p->next=NULL;\r\n	for(i=1; i<=n; i++)\r\n	{   \r\n		s=(NODE *)malloc(sizeof(NODE));\r\n		s->data=rand()%m;	s->next=p->next;\r\n		p->next=s;	p=p->next;\r\n	}\r\n/**********found***********/\r\n	return	h;\r\n}\r\n\r\nvoid outlink(NODE *h)\r\n{  \r\n	NODE  *p; p=h->next;\r\n	printf(\"\\n\\nTHE	LIST :\\n\\n	HEAD \");\r\n	while(p)\r\n	{ \r\n		printf(\"->%d \",p->data);\r\n		p=p->next;\r\n	}\r\n	printf(\"\\n\");\r\n}\r\n\r\nvoid main()\r\n{ \r\n	NODE *head; head=Creatlink(8,22);\r\n	outlink(head);\r\n}', '1');
INSERT INTO `user_program` VALUES ('173', '1', '3', '#include<string.h>\r\n#include<stdio.h>\r\n\r\n#define N 80\r\n\r\nint fun(char *s)\r\n{\r\n	int	i,j=0;\r\n	for(i=0;s[i]!=\'\\0\';i++)\r\n		if(s[i]!=\' \'&&(s[i+1]==\' \'||s[i+1]==\'\\0\'))\r\n/* ????????????????????????????????????????????????è???????????è?°???	???è?¨?¤??????????è????????*/\r\n			j++;\r\n	return	j;	/* è????????è???????° */\r\n}\r\n\r\nvoid main()\r\n{\r\n\r\n	FILE *wf;\r\n	char line[N];\r\n	int num=0;\r\n	printf(\"Enter a string:\\n \");\r\n	gets(line);\r\n	num=fun(line);\r\n	printf(\"The number of word is:%d\\n\\n \",num);\r\n\r\n/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf(wf,\"%d\",fun(\"a big car\"));\r\n	fclose(wf);\r\n/*****************************/\r\n}\r\n', '1');
INSERT INTO `user_program` VALUES ('174', '1', '10', '#include	<stdlib.h>\r\n#include	<stdio.h>\r\n\r\n#define	N	10\r\n\r\ndouble fun(double	*x)\r\n{ \r\n	int	i, j;\r\n	double	s, av, y[N];\r\n	s=0;\r\n	for(i=0; i<N; i++)	\r\n		s=s+x[i];\r\n/**********found**********/\r\n	av=s/N;\r\n	for(i=j=0; i<N; i++)\r\n		if( x[i]>av )\r\n		{\r\n/**********found**********/\r\n			y[j++]=x[i];\r\n			x[i]=-1;\r\n		}\r\n	for(i=0; i<N; i++)\r\n/**********found**********/\r\n		if( x[i]!= -1)\r\n			y[j++]=x[i];\r\n	for(i=0; i<N; i++)\r\n		x[i] = y[i];\r\nreturn	av;\r\n}\r\n\r\nvoid main()\r\n{ \r\n	int	i;\r\n	double	x[N];\r\n	for(i=0; i<N; i++)\r\n	{\r\n		x[i]=rand()%50; \r\n		printf(\"%4.0f \",x[i]);\r\n	}\r\n	printf(\"\\n\");\r\n	printf(\"\\nThe average is: %f\\n\",fun(x));\r\n	printf(\"\\nThe result :\\n\",fun(x));\r\n	for(i=0; i<N; i++)	\r\n		printf(\"%5.0f \",x[i]);\r\n	printf(\"\\n\");\r\n}\r\n                  ', '1');
INSERT INTO `user_program` VALUES ('175', '1', '11', '#include <stdlib.h>\r\n#include <string.h>\r\n#include <conio.h>\r\n#include <ctype.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n/*************found**************/\r\nvoid upfst(char *p)\r\n{\r\n	int k=0;\r\n	for ( ;*p;p++)\r\n		if (k)\r\n		{\r\n			if (*p==\' \')\r\n				k=0;\r\n		}\r\n		else\r\n		{\r\n			if (*p!=\' \')\r\n			{\r\n				k=1;\r\n				*p=toupper(*p);\r\n			}\r\n		}\r\n}\r\n\r\nvoid main()\r\n{\r\n	char chrstr[81];\r\n	system(\"CLS\");\r\n	printf(\"\\nPlease enter an English text line: \");\r\n	gets(chrstr);\r\n	printf(\"\\nBofore changing:\\n %s\",chrstr);\r\n	upfst(chrstr);\r\n	printf(\"\\nAfter changing:\\n %s\\n\",chrstr);\r\n}\r\n\r\n                  ', '1');
INSERT INTO `user_program` VALUES ('176', '1', '12', '#include<stdio.h>\r\n#include<conio.h>\r\n#include<stdlib.h>\r\n\r\n#define N 5\r\n\r\ndouble fun (int w[][N])\r\n{\r\n    int i,j,k=0;\r\n    double sum=0.0;\r\n    for(i=0;i<N;i++)\r\n        for(j=0;j<N;j++)\r\n            if(i==0||i==N-1||j==0||j==N-1) /* ???è??????????????????????? 0 ??? N-1????????????????????¨è????????  */\r\n            {\r\n                sum=sum+w[i][j]; /* ?°???¨è?????????±???? */\r\n                k++;\r\n            }\r\n    return sum/k; /* ?±???¨è???????????????????? */\r\n}\r\n\r\nvoid main()\r\n{\r\n	FILE *wf;\r\n	int a[N][N]={0,1,2,7,9,1,9,7,4,5,2,3,8,3,1,4,5,6,8,2,5,9,1,4,1}; \r\n	int i, j;\r\n	double s;\r\n	system(\"CLS\");\r\n	printf(\"*****The array*****\\n \");\r\n	for (i=0; i<N; i++)\r\n	{\r\n		for (j=0;j<N;j++) \r\n		{\r\n			printf(\"%4d \",a[i][j]);\r\n		}\r\n		printf(\"\\n \");\r\n	}\r\n	s=fun(a);\r\n	printf(\"*****THE RESULT*****\\n \");\r\n	printf(\"The sum is : %lf\\n \",s);\r\n	/******************************/\r\n	wf=fopen(\"out.dat\",\"w\");\r\n	fprintf (wf,\"%lf\",s);\r\n	fclose(wf);\r\n	/*****************************/\r\n}\r\n                  ', '1');

-- ----------------------------
-- Table structure for videos
-- ----------------------------
DROP TABLE IF EXISTS `videos`;
CREATE TABLE `videos` (
  `id` mediumint(8) NOT NULL AUTO_INCREMENT,
  `order_number` int(8) DEFAULT NULL,
  `video_title` varchar(255) NOT NULL,
  `youku_path` varchar(255) NOT NULL,
  `img_url` varchar(255) DEFAULT NULL,
  `time` varchar(255) DEFAULT NULL,
  `creation_date` date DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=253 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of videos
-- ----------------------------
INSERT INTO `videos` VALUES ('71', '32', '【郝斌C语言】- 32 对初学编程者的一些个人建议', 'http://player.youku.com/embed/XNjQ2NDI4MzE2', 'https://vthumb.ykimg.com/0541040852A6EED26A0A48589CDF9567', '10:44', null);
INSERT INTO `videos` VALUES ('72', '28', '【郝斌C语言】- 28 预备知识 之 不同类型数据之间相互赋值的问题', 'http://player.youku.com/embed/XNjQ2NDI3MTQw', 'https://vthumb.ykimg.com/0541040852A6EDEB6A0A4F5204185AE6', '09:43', null);
INSERT INTO `videos` VALUES ('73', '37', '【郝斌C语言】- 37  复习上节课内容', 'http://player.youku.com/embed/XNjQ2NDI5Nzc2', 'https://vthumb.ykimg.com/0541040852A6EF566A0A4C4C3D79E541', '08:41', null);
INSERT INTO `videos` VALUES ('74', '34', '【郝斌C语言】- 34 如何编写出更有保存价值 和 更有学习价值的程', 'http://player.youku.com/embed/XNjQ2NDI5Mjky', 'https://vthumb.ykimg.com/0541040852A6EEF96A0A424A69F01ABB', '06:56', null);
INSERT INTO `videos` VALUES ('75', '30', '【郝斌C语言】- 30 什么是ASCII & 字符的存储', 'http://player.youku.com/embed/XNjQ2NDI4NDE2', 'https://vthumb.ykimg.com/0541040852A6EE4E6A0A4744A09EAA38', '05:18', null);
INSERT INTO `videos` VALUES ('76', '36', '【郝斌C语言】- 36 printf为什么需要输出控制符', 'http://player.youku.com/embed/XNjQ2NDI5Mzky', 'https://vthumb.ykimg.com/0541040852A6EE996A0A4C4C337DBAD2', '03:09', null);
INSERT INTO `videos` VALUES ('77', '35', '【郝斌C语言】- 35_printf用法详解_2', 'http://player.youku.com/embed/XNjQ2NDI5MjI0', 'https://vthumb.ykimg.com/0541040852A6EE656A0A406370892689', '02:44', null);
INSERT INTO `videos` VALUES ('78', '23', '【郝斌C语言】- 23 预备计算机专业知识 之 常量在C语言中是如何', 'http://player.youku.com/embed/XNjQ2NDI1ODgw', 'https://vthumb.ykimg.com/0541040852A6ED8B6A0A4B124D61B78B', '10:51', null);
INSERT INTO `videos` VALUES ('79', '31', '【郝斌C语言】- 31 printf和scanf简介', 'http://player.youku.com/embed/XNjQ2NDI3OTI4', 'https://vthumb.ykimg.com/0541040852A6ED996A0A4E4BC2A9F85B', '01:36', null);
INSERT INTO `videos` VALUES ('80', '24', '【郝斌C语言】- 24 预知识 之 常量以什么样的二进制代码存储在计', 'http://player.youku.com/embed/XNjQ2NDI1MjA0', 'https://vthumb.ykimg.com/0541040852A6EC6A6A0A3F42BB5182CE', '05:14', null);
INSERT INTO `videos` VALUES ('81', '25', '【郝斌C语言】- 25  预备计算机专业知识 之 本讲知识回顾', 'http://player.youku.com/embed/XNjQ2NDI1NTU2', 'https://vthumb.ykimg.com/0541040852A6EC906A0A4377CDB7BC10', '04:39', null);
INSERT INTO `videos` VALUES ('82', '21', '【郝斌C语言】- 21 预备计算机专业知识 之 如何定义变量', 'http://player.youku.com/embed/XNjQ2NDIzNTg4', 'https://vthumb.ykimg.com/0541040852A6EB566A0A4123789DCF97', '02:58', null);
INSERT INTO `videos` VALUES ('83', '20', '【郝斌C语言】- 20变量为什么必须的初始化（高清）', 'http://player.youku.com/embed/XNjQ1OTQxNzEy', 'https://vthumb.ykimg.com/05410408571EABEC6A0A4E04E1C96FE9', '15:38', null);
INSERT INTO `videos` VALUES ('84', '19', '【郝斌C语言】- 17 C编程预备计算机专业知识 之 数据类型（高清', 'http://player.youku.com/embed/XNjQ1OTQwODg0', 'https://vthumb.ykimg.com/05410408571EAC216A0A48046155EDFD', '18:37', null);
INSERT INTO `videos` VALUES ('85', '18', '【郝斌C语言】- 18 预备计算机专业知识 之 什么是变量（高清）', 'http://player.youku.com/embed/XNjQ1OTQxMTI0', 'https://vthumb.ykimg.com/0541040852A59BF16A0A4455559E3000', '08:25', null);
INSERT INTO `videos` VALUES ('86', '16', '【郝斌C语言】- 16 HelloWorld程序如何运行起来的（高清）', 'http://player.youku.com/embed/XNjQ1OTQwMzIw', 'https://vthumb.ykimg.com/0541040852A59B156A0A485892C2F143', '05:26', null);
INSERT INTO `videos` VALUES ('87', '19', '【郝斌C语言】-19 预备计算机专业知识 之 cpu 内存条 vc++6.0 操', 'http://player.youku.com/embed/XNjQ1OTQxMjMy', 'https://vthumb.ykimg.com/0541040852A59B406A0A4604E3796DA7', '01:51', null);
INSERT INTO `videos` VALUES ('88', '14', '【郝斌C语言】- 14  C语言编程预备计算机专业知识（高清）', 'http://player.youku.com/embed/XNjQ1OTM4MTk2', 'https://vthumb.ykimg.com/0541040852A599BF6A0A4F5204B76EC4', '05:52', null);
INSERT INTO `videos` VALUES ('89', '15', '【郝斌C语言】- 15 cpu 内存条 硬盘 显卡 主板 显示器 之间的关', 'http://player.youku.com/embed/XNjQ1OTM4NDY4', 'https://vthumb.ykimg.com/0541040852A599AB6A0A4F51FA61E278', '03:49', null);
INSERT INTO `videos` VALUES ('90', '12', '【郝斌C语言】- 12  C语言概述 之 VC++6.0软件使用讲解（高清）', 'http://player.youku.com/embed/XNjQ1MjU4OTY0', 'https://vthumb.ykimg.com/0541040852A3C1486A0A4A56EFEDE8DB', '11:01', null);
INSERT INTO `videos` VALUES ('91', '13', '【郝斌C语言】- 13 C语言概述 之 回顾本讲内容（高清）', 'http://player.youku.com/embed/XNjQ1MjU5MDg0', 'https://vthumb.ykimg.com/0541040852A3C0976A0A485899E69F34', '03:27', null);
INSERT INTO `videos` VALUES ('92', '11', '【郝斌C语言】- 11  C语言概述 之 一元二次方程详解（高清）', 'http://player.youku.com/embed/XNjQ1MjU4NDI0', 'https://vthumb.ykimg.com/05410408571EACC16A0A4704E7463793', '28:43', null);
INSERT INTO `videos` VALUES ('93', '10', '【郝斌C语言】- 10 C语言概述 之 课程总纲要（高清）', 'http://player.youku.com/embed/XNjQ1MTc4OTUy', 'https://vthumb.ykimg.com/05410408519035E26A0A470A28BCDEC3', '01:58', null);
INSERT INTO `videos` VALUES ('94', '8', '【郝斌C语言】- 08 C语言概述 之 学习目标（高清）', 'http://player.youku.com/embed/XNjQ1MTc4NTQ0', 'https://vthumb.ykimg.com/05410408519034746A0A400DF24A12C8', '01:22', null);
INSERT INTO `videos` VALUES ('95', '7', '【郝斌C语言】- 07 C语言概述 之 怎样学C语言（高清）', 'http://player.youku.com/embed/XNjQ1MTc4NDMy', 'https://vthumb.ykimg.com/05410408519034CB6A0A4265903A0930', '07:14', null);
INSERT INTO `videos` VALUES ('96', '9', '【郝斌C语言】- 09 C语言概述 之 常见问题答疑（高清）', 'http://player.youku.com/embed/XNjQ1MTc4Nzk2', 'https://vthumb.ykimg.com/054104085190366A6A0A4E7312423952', '09:53', null);
INSERT INTO `videos` VALUES ('97', '5', '【郝斌C语言】- 05 C语言概述 之 应用领域（高清）', 'http://player.youku.com/embed/XNjQ1MTc3Mzcy', 'https://vthumb.ykimg.com/054104085190346D6A0A4966224775D5', '04:36', null);
INSERT INTO `videos` VALUES ('98', '4', '【郝斌C语言】- 04  C概述 之 C的特点（高清）', 'http://player.youku.com/embed/XNjQ1MTc2OTky', 'https://vthumb.ykimg.com/0541040851791E556A0A461668272B9E', '21:32', null);
INSERT INTO `videos` VALUES ('99', '2', '【郝斌C语言】 - 02  C语言概述之HelloWorld程序举例（高清）', 'http://player.youku.com/embed/XNjQ1MTc2MDg4', 'https://vthumb.ykimg.com/0541040851791CA96A0A4A045E592EF6', '05:12', null);
INSERT INTO `videos` VALUES ('100', '3', '【郝斌C语言】- 03 C语言概述 之 起源和发展（高清）', 'http://player.youku.com/embed/XNjQ1MTc2NDk2', 'https://vthumb.ykimg.com/0541040851791E4A6A0A4A045E346E6E', '20:21', null);
INSERT INTO `videos` VALUES ('101', '1', '【郝斌C语言】 - 01 C语言概述（高清）', 'http://player.youku.com/embed/XNjQ1MTcwMTIw', 'https://vthumb.ykimg.com/0541040851791C5D6A0A4364D81E0B66', '04:13', null);
INSERT INTO `videos` VALUES ('102', '6', '【郝斌C语言】- 06 C语言概述 之 重要性（高清）', 'http://player.youku.com/embed/XNjQ1MTc4Mjc2', 'https://vthumb.ykimg.com/0541040852A340EE6A0A4744A2552D1E', '15:07', null);
INSERT INTO `videos` VALUES ('103', '73', '【郝斌C语言】- 73 for循环之 6：for和if的嵌套使用四个习题的讲', 'http://player.youku.com/embed/XNjQ4MTQxODUy', 'https://vthumb.ykimg.com/0541040852AC32246A0A4744A21EA6C3', '26:47', null);
INSERT INTO `videos` VALUES ('104', '74', '【郝斌C语言】- 74 for循环之 7：多层for循环嵌套使用执行顺序', 'http://player.youku.com/embed/XNjQ4MTQxOTQw', 'https://vthumb.ykimg.com/0541040852AC31CD6A0A451E17287389', '25:05', null);
INSERT INTO `videos` VALUES ('105', '75', '【郝斌C语言】- 75 进制', 'http://player.youku.com/embed/XNjQ4MTQxODM2', 'https://vthumb.ykimg.com/0541040852AC30AA6A0A4604D8771CE8', '11:00', null);
INSERT INTO `videos` VALUES ('106', '83', '【郝斌C语言】- 83 for和while的比较', 'http://player.youku.com/embed/XNjQ4MTQ0MTEy', 'https://vthumb.ykimg.com/0541040852AC32076A0A4A56F4DA3C95', '08:32', null);
INSERT INTO `videos` VALUES ('107', '87', '【郝斌C语言】- 87 什么时候使用while，什么时候使用for', 'http://player.youku.com/embed/XNjQ4MTQ1MzMy', 'https://vthumb.ykimg.com/0541040852AC32176A0A4377C03A1AE2', '01:45', null);
INSERT INTO `videos` VALUES ('108', '72', '【郝斌C语言】- 72 for循环之 5：浮点数的存储所带来的问题', 'http://player.youku.com/embed/XNjQ4MTQwNDY0', 'https://vthumb.ykimg.com/0541040852AC304F6A0A4C4C42213676', '16:28', null);
INSERT INTO `videos` VALUES ('109', '79', '【郝斌C语言】- 79 for循环8：复习多个for循环嵌套使用时执行顺', 'http://player.youku.com/embed/XNjQ4MTQyODY0', 'https://vthumb.ykimg.com/0541040852AC31186A0A491BCC8312B7', '08:26', null);
INSERT INTO `videos` VALUES ('110', '78', '【郝斌C语言】- 78 运算符补充之 3：逗号表达式', 'http://player.youku.com/embed/XNjQ4MTQyNDMy', 'https://vthumb.ykimg.com/0541040852AC306B6A0A485899C19C6E', '04:10', null);
INSERT INTO `videos` VALUES ('111', '77', '【郝斌C语言】- 77 运算符补充之 2： 三目运算符', 'http://player.youku.com/embed/XNjQ4MTQyMTgw', 'https://vthumb.ykimg.com/0541040852AC30246A0A4F52045F742B', '02:43', null);
INSERT INTO `videos` VALUES ('112', '81', '【郝斌C语言】- 81 while循环之 1： while函数的概述', 'http://player.youku.com/embed/XNjQ4MTQzNTQw', 'https://vthumb.ykimg.com/0541040852AC30D46A0A445554EE0703', '01:11', null);
INSERT INTO `videos` VALUES ('113', '82', '【郝斌C语言】- 82 while循环之 2：while函数的执行顺序', 'http://player.youku.com/embed/XNjQ4MTQzNjY0', 'https://vthumb.ykimg.com/0541040852AC30E46A0A491BCFD1A72A', '01:00', null);
INSERT INTO `videos` VALUES ('114', '71', '【郝斌C语言】- 71 for循环之 4：强制类型转化和对初学者很重要', 'http://player.youku.com/embed/XNjQ4MTQwNzIw', 'https://vthumb.ykimg.com/0541040852AC313C6A0A4C4C42708C34', '24:15', null);
INSERT INTO `videos` VALUES ('115', '69', '【郝斌C语言】- 69 for循环之 3：for和if的嵌套使用', 'http://player.youku.com/embed/XNjQ3OTgxMDY0', 'https://vthumb.ykimg.com/0541040852ABCF4A6A0A451E2341C387', '21:02', null);
INSERT INTO `videos` VALUES ('116', '67', '【郝斌C语言】- 67 for循环之 1：为什么需要for循环', 'http://player.youku.com/embed/XNjQ3OTc5Nzk2', 'https://vthumb.ykimg.com/0541040852ABCEC66A0A4E4BD2F66855', '22:14', null);
INSERT INTO `videos` VALUES ('117', '70', '【郝斌C语言】- 70 复习上节课知识', 'http://player.youku.com/embed/XNjQ3OTgxNzI4', 'https://vthumb.ykimg.com/0541040852ABCEAD6A0A4E4BBFBB6C9B', '06:39', null);
INSERT INTO `videos` VALUES ('118', '63', '【郝斌C语言】- 63 选择执行9：if 函数常见问题解析', 'http://player.youku.com/embed/XNjQ3OTc3NTgw', 'https://vthumb.ykimg.com/0541040852ABCE156A0A41238BC859F2', '27:53', null);
INSERT INTO `videos` VALUES ('119', '68', '【郝斌C语言】- 68 for循环之 2：for循环最简单的用法', 'http://player.youku.com/embed/XNjQ3OTgwMDY4', 'https://vthumb.ykimg.com/0541040852ABCE1F6A0A451E11A54D50', '10:22', null);
INSERT INTO `videos` VALUES ('120', '65', '【郝斌C语言】- 65 循环的定义', 'http://player.youku.com/embed/XNjQ3OTc3Nzg4', 'https://vthumb.ykimg.com/0541040852ABCBA56A0A4C4C3E663C24', '01:30', null);
INSERT INTO `videos` VALUES ('121', '66', '【郝斌C语言】- 66 循环的分类', 'http://player.youku.com/embed/XNjQ3OTc3ODky', 'https://vthumb.ykimg.com/0541040852ABCBA86A0A424A68C730B0', '00:44', null);
INSERT INTO `videos` VALUES ('122', '62', '【郝斌C语言】- 62 选择执行8：空语句的问题', 'http://player.youku.com/embed/XNjQ3OTc2MTg4', 'https://vthumb.ykimg.com/0541040852ABCB3A6A0A424A52FFCC52', '06:18', null);
INSERT INTO `videos` VALUES ('123', '64', '【郝斌C语言】- 64 switch后面再讲', 'http://player.youku.com/embed/XNjQ3OTc3Njg4', 'https://vthumb.ykimg.com/0541040852ABCB766A0A4858A4B88414', '00:24', null);
INSERT INTO `videos` VALUES ('124', '61', '【郝斌C语言】- 61 复习上机课知识', 'http://player.youku.com/embed/XNjQ3OTc1OTgw', 'https://vthumb.ykimg.com/0541040852ABCAD76A0A4B124C750128', '04:59', null);
INSERT INTO `videos` VALUES ('125', '60', '【郝斌C语言】- 60 学习C语言常见误区', 'http://player.youku.com/embed/XNjQ3MzIyNjA0', 'https://vthumb.ykimg.com/0541040852A990706A0A48589655D3B3', '22:54', null);
INSERT INTO `videos` VALUES ('126', '57', '【郝斌C语言】- 57 选择执行7：if 函数举例--求分数的等级', 'http://player.youku.com/embed/XNjQ3MzE4NzMy', 'https://vthumb.ykimg.com/0541040852A98D946A0A3F42C61126B5', '18:05', null);
INSERT INTO `videos` VALUES ('127', '59', '【郝斌C语言】- 59 if 函数子2：对任意三个数字进行排序', 'http://player.youku.com/embed/XNjQ3MzE5MDE2', 'https://vthumb.ykimg.com/0541040852A98DA36A0A44554A57704B', '17:27', null);
INSERT INTO `videos` VALUES ('128', '53', '【郝斌C语言】- 53 选择执行3_：if 函数的范围问题', 'http://player.youku.com/embed/XNjQ3MzE2NzM2', 'https://vthumb.ykimg.com/0541040852A98C446A0A3F42CE729E7A', '14:22', null);
INSERT INTO `videos` VALUES ('129', '58', '【郝斌C语言】- 58 if 函数例子1：互换两个数字', 'http://player.youku.com/embed/XNjQ3MzE4MzUy', 'https://vthumb.ykimg.com/0541040852A98CC36A0A4A56D698385B', '10:47', null);
INSERT INTO `videos` VALUES ('130', '54', '【郝斌C语言】- 54 选择执行4：if..else的用法', 'http://player.youku.com/embed/XNjQ3MzE3MDQ4', 'https://vthumb.ykimg.com/0541040852A98C086A0A4F52002CC5E4', '10:27', null);
INSERT INTO `videos` VALUES ('131', '55', '【郝斌C语言】- 55 选择执行5：if..else ifelse..的用法', 'http://player.youku.com/embed/XNjQ3MzE3NDk2', 'https://vthumb.ykimg.com/0541040852A98C476A0A4377CBA42D6B', '09:47', null);
INSERT INTO `videos` VALUES ('132', '52', '【郝斌C语言】- 52 选择执行2：if 函数最简单的用法', 'http://player.youku.com/embed/XNjQ3MzE2MjUy', 'https://vthumb.ykimg.com/0541040852A98B526A0A4E4BBE6408C7', '06:51', null);
INSERT INTO `videos` VALUES ('133', '56', '【郝斌C语言】- 56 选择执行6：C语言对真假的处理', 'http://player.youku.com/embed/XNjQ3MzE3ODU2', 'https://vthumb.ykimg.com/0541040852A98B936A0A3F42C4954B6B', '00:33', null);
INSERT INTO `videos` VALUES ('134', '51', '【郝斌C语言】- 51 选择执行1：if 函数概述', 'http://player.youku.com/embed/XNjQ3MzE1OTQ4', 'https://vthumb.ykimg.com/0541040852A98AA46A0A4C4C27ED830C', '03:11', null);
INSERT INTO `videos` VALUES ('135', '46', '【郝斌C语言】- 46 回顾Scanf 函数', 'http://player.youku.com/embed/XNjQ2OTMxMDc2', 'https://vthumb.ykimg.com/0541040852A85B666A0A412389B41EE3', '15:00', null);
INSERT INTO `videos` VALUES ('136', '50', '【郝斌C语言】- 50 流程控制之4：流程控制为什么重要', 'http://player.youku.com/embed/XNjQ2OTMyMzgw', 'https://vthumb.ykimg.com/0541040852A85C006A0A491BD970D006', '10:32', null);
INSERT INTO `videos` VALUES ('137', '49', '【郝斌C语言】- 49  回顾Scanf及运算符', 'http://player.youku.com/embed/XNjQ2OTMyMDQ4', 'https://vthumb.ykimg.com/0541040852A85B8B6A0A4D4BFAE394F6', '07:53', null);
INSERT INTO `videos` VALUES ('138', '48', '【郝斌C语言】- 48 流程控制的分类', 'http://player.youku.com/embed/XNjQ2OTMxNzQw', 'https://vthumb.ykimg.com/0541040852A85AA06A0A451E0EF40C9B', '01:18', null);
INSERT INTO `videos` VALUES ('139', '47', '【郝斌C语言】- 47 流程控制 之1：什么是流程控制', 'http://player.youku.com/embed/XNjQ2OTMxMjg0', 'https://vthumb.ykimg.com/0541040852A85A916A0A4063716AD570', '03:35', null);
INSERT INTO `videos` VALUES ('140', '44', '【郝斌C语言】- 44 逻辑运算符 之 1', 'http://player.youku.com/embed/XNjQ2OTMwMzM2', 'https://vthumb.ykimg.com/0541040852A85B156A0A4063711E794A', '13:38', null);
INSERT INTO `videos` VALUES ('141', '42', '【郝斌C语言】- 42 运算符', 'http://player.youku.com/embed/XNjQ2OTI4ODc2', 'https://vthumb.ykimg.com/0541040852A859306A0A4377CD7DBDCB', '04:12', null);
INSERT INTO `videos` VALUES ('142', '45', '【郝斌C语言】- 45 逻辑运算符 之 2', 'http://player.youku.com/embed/XNjQ2OTMwNDQ0', 'https://vthumb.ykimg.com/0541040852A85A156A0A4D4C02959BBF', '03:46', null);
INSERT INTO `videos` VALUES ('143', '43', '【郝斌C语言】- 43 运算符_2：除法与取余运算符', 'http://player.youku.com/embed/XNjQ2OTI5NjQ0', 'https://vthumb.ykimg.com/0541040852A859BC6A0A41238B176CD1', '05:24', null);
INSERT INTO `videos` VALUES ('144', '41', '【郝斌C语言】- 41 sacnf用法 - 4 ： 如何使用scanf编写出高质', 'http://player.youku.com/embed/XNjQ2OTI4NzI0', 'https://vthumb.ykimg.com/0541040852A85A1C6A0A4B12519DF678', '14:20', null);
INSERT INTO `videos` VALUES ('145', '40', '【郝斌C语言】- 40  sacnf用法 - 3、 一次给多个变量键盘赋值', 'http://player.youku.com/embed/XNjQ2OTI3NjQ0', 'https://vthumb.ykimg.com/0541040852A858AF6A0A4858A786085E', '07:30', null);
INSERT INTO `videos` VALUES ('146', '38', '【郝斌C语言】- 38  scanf用法 - 1：不含输入控制符的用法', 'http://player.youku.com/embed/XNjQ2OTI2MDg0', 'https://vthumb.ykimg.com/0541040852A8582A6A0A4F5203571EAD', '11:46', null);
INSERT INTO `videos` VALUES ('147', '39', '【郝斌C语言】- 39  scanf用法 - 2：含有非输入控制符', 'http://player.youku.com/embed/XNjQ2OTI3MjQ0', 'https://vthumb.ykimg.com/0541040852A8585E6A0A4B12413297C2', '06:16', null);
INSERT INTO `videos` VALUES ('148', '22', '【郝斌C语言】- 22  预备计算机专业知识  之 什么叫进制', 'http://player.youku.com/embed/XNjQ2NDI0NTU2', 'https://vthumb.ykimg.com/05410408571EAC826A0A42472F55E86F', '31:27', null);
INSERT INTO `videos` VALUES ('149', '26', '【郝斌C语言】- 26 预备计算机专业知识 之 代码的规范化', 'http://player.youku.com/embed/XNjQ2NDI3NTg0', 'https://vthumb.ykimg.com/05410408571EABA76A0A490443DD45A6', '18:48', null);
INSERT INTO `videos` VALUES ('150', '33', '【郝斌C语言】- 33 printf函数的用法详解', 'http://player.youku.com/embed/XNjQ2NDI5MTQ0', 'https://vthumb.ykimg.com/0541040852A6EFA96A0A424A5BD47258', '17:53', null);
INSERT INTO `videos` VALUES ('151', '27', '【郝斌C语言】- 27 预备计算机专业知识 之 什么是字节', 'http://player.youku.com/embed/XNjQ2NDI2ODA0', 'https://vthumb.ykimg.com/0541040852A6EE1D6A0A491BCB896774', '11:27', null);
INSERT INTO `videos` VALUES ('152', '29', '【郝斌C语言】- 29 char使用常见问题解析', 'http://player.youku.com/embed/XNjQ2NDI3NjY0', 'https://vthumb.ykimg.com/0541040852A6EE6A6A0A4E4BD3A5B92A', '10:55', null);
INSERT INTO `videos` VALUES ('153', '135', '【郝斌C语言】- 135 指针之 15：复习上一节指针知识', 'http://player.youku.com/embed/XNjQ4MTg4NDYw', 'https://vthumb.ykimg.com/0541040852AC4DD36A0A474490A64A13', '11:41', null);
INSERT INTO `videos` VALUES ('154', '136', '【郝斌C语言】- 136 指针之 16：指针变量的运算', 'http://player.youku.com/embed/XNjQ4MTg4OTI0', 'https://vthumb.ykimg.com/0541040852AC4D906A0A424A69E85FDE', '05:27', null);
INSERT INTO `videos` VALUES ('155', '130', '【郝斌C语言】- 130 指针之 10：通过指针为什么可以使被调函数修', 'http://player.youku.com/embed/XNjQ4MTgyMzky', 'https://vthumb.ykimg.com/0541040852AC4AA76A0A47449CB69DDA', '11:55', null);
INSERT INTO `videos` VALUES ('156', '131', '【郝斌C语言】- 131 指针之 11：一维数组和指针关系概述', 'http://player.youku.com/embed/XNjQ4MTgzMDM2', 'https://vthumb.ykimg.com/0541040852AC4A976A0A451E23C61E09', '09:41', null);
INSERT INTO `videos` VALUES ('157', '132', '【郝斌C语言】- 132 指针之 12：下标和指针的关系', 'http://player.youku.com/embed/XNjQ4MTg0ODA0', 'https://vthumb.ykimg.com/0541040852AC4B116A0A485896DC0A4E', '05:56', null);
INSERT INTO `videos` VALUES ('158', '133', '【郝斌C语言】- 133 指针之 13：一维数组名的含义', 'http://player.youku.com/embed/XNjQ4MTg1MjE2', 'https://vthumb.ykimg.com/0541040852AC4B916A0A406370968C9D', '05:54', null);
INSERT INTO `videos` VALUES ('159', '121', '【郝斌C语言】- 121 指针之1：指针用法初次简单介绍', 'http://player.youku.com/embed/XNjQ4MTczMTg0', 'https://vthumb.ykimg.com/0541040852AC47DD6A0A3F42D212B240', '40:15', null);
INSERT INTO `videos` VALUES ('160', '123', '【郝斌C语言】- 123 指针之3：什么是地址', 'http://player.youku.com/embed/XNjQ4MTc3OTEy', 'https://vthumb.ykimg.com/0541040852AC48986A0A4744A31F6AB5', '14:56', null);
INSERT INTO `videos` VALUES ('161', '128', '【郝斌C语言】- 128 指针之8：星号的三种含义', 'http://player.youku.com/embed/XNjQ4MTgwMTI4', 'https://vthumb.ykimg.com/0541040852AC487C6A0A4A56F4A29AB6', '05:48', null);
INSERT INTO `videos` VALUES ('162', '125', '【郝斌C语言】- 125 指针之5：基本类型指针', 'http://player.youku.com/embed/XNjQ4MTc5MTI0', 'https://vthumb.ykimg.com/0541040852AC47AC6A0A4377D1422858', '03:55', null);
INSERT INTO `videos` VALUES ('163', '124', '【郝斌C语言】- 124 指针之4：什么是指针', 'http://player.youku.com/embed/XNjQ4MTc3NzM2', 'https://vthumb.ykimg.com/0541040852AC46CA6A0A4E4BBB9A2072', '03:49', null);
INSERT INTO `videos` VALUES ('164', '122', '【郝斌C语言】- 122 指针之2：指针的重要性', 'http://player.youku.com/embed/XNjQ4MTcxMjA4', 'https://vthumb.ykimg.com/0541040852AC432C6A0A451E245F49A2', '07:27', null);
INSERT INTO `videos` VALUES ('165', '115', '【郝斌C语言】-115 函数之 12：如何在开发中合理的设计函数来解', 'http://player.youku.com/embed/XNjQ4MTY0NTI0', 'https://vthumb.ykimg.com/0541040852AC41A66A0A41238E790A4F', '46:37', null);
INSERT INTO `videos` VALUES ('166', '120', '【郝斌C语言】-120 函数之 17：变量的作用域和存储方式', 'http://player.youku.com/embed/XNjQ4MTY3NDE2', 'https://vthumb.ykimg.com/0541040852AC427F6A0A412386FF1201', '22:15', null);
INSERT INTO `videos` VALUES ('167', '119', '【郝斌C语言】-119 函数之 16：函数复习', 'http://player.youku.com/embed/XNjQ4MTY2ODYw', 'https://vthumb.ykimg.com/0541040852AC41AB6A0A41238E25A723', '14:29', null);
INSERT INTO `videos` VALUES ('168', '117', '【郝斌C语言】-117 函数之 14：常用系统函数和如何通过书籍学习', 'http://player.youku.com/embed/XNjQ4MTY1NDk2', 'https://vthumb.ykimg.com/0541040852AC3FDE6A0A4E4BC3B8F70C', '08:33', null);
INSERT INTO `videos` VALUES ('169', '113', '【郝斌C语言】-113 函数之 10：函数的声明', 'http://player.youku.com/embed/XNjQ4MTYzMjUy', 'https://vthumb.ykimg.com/0541040852AC3ECC6A0A485896EF9A0B', '18:36', null);
INSERT INTO `videos` VALUES ('170', '118', '【郝斌C语言】-118 函数之 15：递归', 'http://player.youku.com/embed/XNjQ4MTY1NzU2', 'https://vthumb.ykimg.com/0541040852AC3F9B6A0A4604E584A11B', '06:32', null);
INSERT INTO `videos` VALUES ('171', '111', '【郝斌C语言】-111 函数之 8：判断一个数字是否是素数', 'http://player.youku.com/embed/XNjQ4MTYxNDIw', 'https://vthumb.ykimg.com/0541040852AC3F2F6A0A4E4BB6EC34CC', '25:36', null);
INSERT INTO `videos` VALUES ('172', '105', '【郝斌C语言】-105 函数之 2：函数使用简单介绍', 'http://player.youku.com/embed/XNjQ4MTU1NTgw', 'https://vthumb.ykimg.com/0541040852AC3BBF6A0A491BD7B03501', '26:03', null);
INSERT INTO `videos` VALUES ('173', '112', '【郝斌C语言】-112 函数之 9：复习', 'http://player.youku.com/embed/XNjQ4MTYxMjY4', 'https://vthumb.ykimg.com/0541040852AC3D5B6A0A424A66E2E17D', '15:08', null);
INSERT INTO `videos` VALUES ('174', '108', '【郝斌C语言】-108 函数之 5：如何定义函数', 'http://player.youku.com/embed/XNjQ4MTU3OTI0', 'https://vthumb.ykimg.com/0541040852AC3B886A0A48589E7EEFC1', '10:18', null);
INSERT INTO `videos` VALUES ('175', '116', '【郝斌C语言】-116 函数之 13：复习函数内容的知识', 'http://player.youku.com/embed/XNjQ4MTY0MDEy', 'https://vthumb.ykimg.com/0541040852AC3EB86A0A451E1B2B4244', '06:14', null);
INSERT INTO `videos` VALUES ('176', '114', '【郝斌C语言】-114 函数之11：形参和实参', 'http://player.youku.com/embed/XNjQ4MTYyODQw', 'https://vthumb.ykimg.com/0541040852AC3DB16A0A4B124616DE10', '05:41', null);
INSERT INTO `videos` VALUES ('177', '107', '【郝斌C语言】-107 函数之 4：什么是函数', 'http://player.youku.com/embed/XNjQ4MTU2NDY4', 'https://vthumb.ykimg.com/0541040852AC3B0E6A0A491BD56C23CC', '13:48', null);
INSERT INTO `videos` VALUES ('178', '110', '【郝斌C语言】-110 函数之 7：函数的分类', 'http://player.youku.com/embed/XNjQ4MTU4NzQw', 'https://vthumb.ykimg.com/0541040852AC3B476A0A4D4C05EE704D', '05:22', null);
INSERT INTO `videos` VALUES ('179', '109', '【郝斌C语言】-109 函数之6：return和break的区别', 'http://player.youku.com/embed/XNjQ4MTU3OTQ4', 'https://vthumb.ykimg.com/0541040852AC3B2D6A0A4A56F09D804F', '08:32', null);
INSERT INTO `videos` VALUES ('180', '106', '【郝斌C语言】-106 函数之 3：为什么需要函数', 'http://player.youku.com/embed/XNjQ4MTU1MTgw', 'https://vthumb.ykimg.com/0541040852AC39126A0A424A69B762F4', '07:24', null);
INSERT INTO `videos` VALUES ('181', '101', '【郝斌C语言】-101 数组之 4：数组之所以不是我们学习重点的原因', 'http://player.youku.com/embed/XNjQ4MTUzMzE2', 'https://vthumb.ykimg.com/0541040852AC38E56A0A4B12397053A7', '25:48', null);
INSERT INTO `videos` VALUES ('182', '103', '【郝斌C语言】-103 数组之 7：是否存在多维数组', 'http://player.youku.com/embed/XNjQ4MTU0MzA4', 'https://vthumb.ykimg.com/0541040852AC38196A0A3F42BCCF945C', '05:39', null);
INSERT INTO `videos` VALUES ('183', '102', '【郝斌C语言】-102 数组之 6：二维数组的使用', 'http://player.youku.com/embed/XNjQ4MTUzMzA0', 'https://vthumb.ykimg.com/0541040852AC38796A0A4C4C40EAC2A5', '19:09', null);
INSERT INTO `videos` VALUES ('184', '104', '【郝斌C语言】-104 函数之 1：函数概述', 'http://player.youku.com/embed/XNjQ4MTU0MzQ4', 'https://vthumb.ykimg.com/0541040852AC38296A0A4A56EF2B4462', '04:40', null);
INSERT INTO `videos` VALUES ('185', '96', '【郝斌C语言】-96 流程控制的总测试', 'http://player.youku.com/embed/XNjQ4MTQ4OTI0', 'https://vthumb.ykimg.com/0541040852AC36AF6A0A445554EDD007', '17:55', null);
INSERT INTO `videos` VALUES ('186', '92', '【郝斌C语言】-92 break的用法', 'http://player.youku.com/embed/XNjQ4MTQ3NjQ0', 'https://vthumb.ykimg.com/0541040852AC352B6A0A4C4C3997E016', '20:34', null);
INSERT INTO `videos` VALUES ('187', '99', '【郝斌C语言】-99 数组之 3：为什么需要数组', 'http://player.youku.com/embed/XNjQ4MTQ4ODUy', 'https://vthumb.ykimg.com/0541040852AC34EB6A0A406370E2D491', '08:15', null);
INSERT INTO `videos` VALUES ('188', '93', '【郝斌C语言】-93 continue的用法', 'http://player.youku.com/embed/XNjQ4MTQ3ODIw', 'https://vthumb.ykimg.com/0541040852AC35486A0A3F42D26DCA7F', '12:24', null);
INSERT INTO `videos` VALUES ('189', '95', '【郝斌C语言】-95 流程控制的总复习', 'http://player.youku.com/embed/XNjQ4MTQ3NjYw', 'https://vthumb.ykimg.com/0541040852AC34E36A0A4A56F459CDFE', '10:34', null);
INSERT INTO `videos` VALUES ('190', '98', '【郝斌C语言】-98 数组之 2：数组的简单使用', 'http://player.youku.com/embed/XNjQ4MTQ5MDI0', 'https://vthumb.ykimg.com/0541040852AC34BA6A0A3F42D2A86BE8', '05:17', null);
INSERT INTO `videos` VALUES ('191', '100', '【郝斌C语言】-100 数组之 4：数组之所以不是我们学习重点的原因', 'http://player.youku.com/embed/XNjQ4MTQ5NDg0', 'https://vthumb.ykimg.com/0541040852AC34BC6A0A4744A14B2C13', '02:36', null);
INSERT INTO `videos` VALUES ('192', '84', '【郝斌C语言】- 84 如何看懂一个程序举例之1：回文数', 'http://player.youku.com/embed/XNjQ4MTQ1MDI0', 'https://vthumb.ykimg.com/0541040852AC33B46A0A47449145E3AF', '21:37', null);
INSERT INTO `videos` VALUES ('193', '76', '【郝斌C语言】- 76 运算符补充之 1： 自增自减', 'http://player.youku.com/embed/XNjQ4MTQyOTc2', 'https://vthumb.ykimg.com/0541040852AC320E6A0A44553D04A4A6', '20:28', null);
INSERT INTO `videos` VALUES ('194', '89', '【郝斌C语言】- 89 一元二次方程 用do...while 实现', 'http://player.youku.com/embed/XNjQ4MTQ2MjQ4', 'https://vthumb.ykimg.com/0541040852AC33DD6A0A40636D42F5E7', '17:11', null);
INSERT INTO `videos` VALUES ('195', '80', '【郝斌C语言】- 80 复习多个for循环嵌套使用', 'http://player.youku.com/embed/XNjQ4MTQ0MDI0', 'https://vthumb.ykimg.com/0541040852AC32AF6A0A491BD0CF27BB', '16:34', null);
INSERT INTO `videos` VALUES ('196', '86', '【郝斌C语言】- 86 如何看懂一个程序举例之 2：菲波拉契序列-2-', 'http://player.youku.com/embed/XNjQ4MTQ1MTAw', 'https://vthumb.ykimg.com/0541040852AC33106A0A4377B8D30DCF', '12:13', null);
INSERT INTO `videos` VALUES ('197', '94', '【郝斌C语言】-94 学C语言为什么无法做出像样东西 和 各门课程之', 'http://player.youku.com/embed/XNjQ4MTQ2OTMy', 'https://vthumb.ykimg.com/0541040852AC34296A0A4123868DAA44', '09:55', null);
INSERT INTO `videos` VALUES ('198', '90', '【郝斌C语言】-90 switch函数用法的简介', 'http://player.youku.com/embed/XNjQ4MTQ2NDcy', 'https://vthumb.ykimg.com/0541040852AC33F16A0A4377CD7C9FBE', '10:09', null);
INSERT INTO `videos` VALUES ('199', '85', '【郝斌C语言】- 85 如何看懂一个程序举例之 2：菲波拉契序列', 'http://player.youku.com/embed/XNjQ4MTQ0ODAw', 'https://vthumb.ykimg.com/0541040852AC327F6A0A4604E56C794C', '09:38', null);
INSERT INTO `videos` VALUES ('200', '91', '【郝斌C语言】-91 switch琐碎非重点知识介绍', 'http://player.youku.com/embed/XNjQ4MTQ2MzY0', 'https://vthumb.ykimg.com/0541040852AC334E6A0A4A56F58E82CD', '06:38', null);
INSERT INTO `videos` VALUES ('201', '97', '【郝斌C语言】-97 数组之 1：数组概述', 'http://player.youku.com/embed/XNjQ4MTQ4MDMy', 'https://vthumb.ykimg.com/0541040852AC33D56A0A406368CC83C4', '01:29', null);
INSERT INTO `videos` VALUES ('202', '88', '【郝斌C语言】- 88 -do...while- 与 while和for的比较', 'http://player.youku.com/embed/XNjQ4MTQ1NTE2', 'https://vthumb.ykimg.com/0541040852AC32976A0A3F42D23E2FE8', '04:30', null);
INSERT INTO `videos` VALUES ('205', '179', '【郝斌C语言】- 178 试题讲解 (上)', 'http://player.youku.com/embed/XNjQ4MjE4MjUy', 'https://vthumb.ykimg.com/0541040852AC65F26A0A44554C96980D', '01:07:16', null);
INSERT INTO `videos` VALUES ('206', '176', '【郝斌C语言】- 176 位运算符', 'http://player.youku.com/embed/XNjQ4MjE1Njk2', 'https://vthumb.ykimg.com/0541040852AC60C66A0A445554865C26', '35:24', null);
INSERT INTO `videos` VALUES ('207', '172', '【郝斌C语言】- 172 链表 (中)', 'http://player.youku.com/embed/XNjQ4MjEzOTMy', 'https://vthumb.ykimg.com/0541040852AC5FBC6A0A4858A5B8AB4E', '38:29', null);
INSERT INTO `videos` VALUES ('208', '173', '【郝斌C语言】 - 173 链表 (下)', 'http://player.youku.com/embed/XNjQ4MjE0Mzk2', 'https://vthumb.ykimg.com/0541040852AC5FC86A0A3F42C61F1A1A', '30:40', null);
INSERT INTO `videos` VALUES ('209', '180', '【郝斌C语言】- 180  试题讲解 (下)', 'http://player.youku.com/embed/XNjQ4MjE2MjY0', 'https://vthumb.ykimg.com/0541040852AC5F3C6A0A3F42BFED22C0', '15:46', null);
INSERT INTO `videos` VALUES ('210', '179', '【郝斌C语言】- 179 NULL的含义', 'http://player.youku.com/embed/XNjQ4MjE1MzE2', 'https://vthumb.ykimg.com/0541040852AC5EAA6A0A4B1241BD1B31', '16:31', null);
INSERT INTO `videos` VALUES ('211', '168', '【郝斌C语言】- 168 补码 (上)', 'http://player.youku.com/embed/XNjQ4MjEwMTY4', 'https://vthumb.ykimg.com/0541040852AC5DAE6A0A4D4C03C4FCD1', '47:38', null);
INSERT INTO `videos` VALUES ('212', '167', '【郝斌C语言】- 167 进制转化', 'http://player.youku.com/embed/XNjQ4MjA5NDI4', 'https://vthumb.ykimg.com/0541040852AC5C386A0A451E22ECDF18', '32:33', null);
INSERT INTO `videos` VALUES ('213', '170', '【郝斌C语言】- 170 补码 (下)', 'http://player.youku.com/embed/XNjQ4MjEwNTg0', 'https://vthumb.ykimg.com/0541040852AC5C636A0A4C4C25B552E4', '27:09', null);
INSERT INTO `videos` VALUES ('214', '175', '【郝斌C语言】- 175 广义的算法', 'http://player.youku.com/embed/XNjQ4MjExNzY4', 'https://vthumb.ykimg.com/0541040852AC5C146A0A424A61619573', '09:01', null);
INSERT INTO `videos` VALUES ('215', '177', '【郝斌C语言】- 177 文件、宏和typedef', 'http://player.youku.com/embed/XNjQ4MjEzMTc2', 'https://vthumb.ykimg.com/0541040852AC5C456A0A4C4C3B7BEBC7', '02:17', null);
INSERT INTO `videos` VALUES ('216', '164', '【郝斌C语言】- 164 结构体11：综合应用_学生管理系统(存储，排', 'http://player.youku.com/embed/XNjQ4MjA4Njky', 'https://vthumb.ykimg.com/0541040852AC5B6F6A0A4377D05F80C2', '28:51', null);
INSERT INTO `videos` VALUES ('217', '171', '【郝斌C语言】- 171 链表 (上)', 'http://player.youku.com/embed/XNjQ4MjEwMTIw', 'https://vthumb.ykimg.com/0541040852AC5B6B6A0A491BD72E61AB', '18:08', null);
INSERT INTO `videos` VALUES ('218', '174', '【郝斌C语言】- 174 狭义的算法', 'http://player.youku.com/embed/XNjQ4MjExMjg4', 'https://vthumb.ykimg.com/0541040852AC5B2C6A0A4B1253DA3408', '03:55', null);
INSERT INTO `videos` VALUES ('219', '169', '【郝斌C语言】- 169 复习上节课补码知识', 'http://player.youku.com/embed/XNjQ4MjA5MTQw', 'https://vthumb.ykimg.com/0541040852AC5A2A6A0A4C4C2F746286', '08:33', null);
INSERT INTO `videos` VALUES ('220', '155', '【郝斌C语言】- 155 结构体5：如何取出结构体变量中的每一个成员', 'http://player.youku.com/embed/XNjQ4MjA1NTY4', 'https://vthumb.ykimg.com/0541040852AC592A6A0A4A56E1EEF4FC', '25:01', null);
INSERT INTO `videos` VALUES ('221', '159', '【郝斌C语言】- 159 结构体8：通过函数完成对结构体变量的输入和', 'http://player.youku.com/embed/XNjQ4MjA2ODA4', 'https://vthumb.ykimg.com/0541040852AC5A006A0A4744A2D0EA9B', '22:37', null);
INSERT INTO `videos` VALUES ('222', '163', '【郝斌C语言】- 163 冒泡排序', 'http://player.youku.com/embed/XNjQ4MjA3NjY0', 'https://vthumb.ykimg.com/0541040852AC59E86A0A4744993D6079', '20:47', null);
INSERT INTO `videos` VALUES ('223', '166', '【郝斌C语言】- 166 枚举（下）', 'http://player.youku.com/embed/XNjQ4MjA4MjEy', 'https://vthumb.ykimg.com/0541040852AC59ED6A0A4604C8DA7D74', '16:09', null);
INSERT INTO `videos` VALUES ('224', '162', '【郝斌C语言】- 162 结构体10：结构体变量的运算', 'http://player.youku.com/embed/XNjQ4MjA2MDA0', 'https://vthumb.ykimg.com/0541040852AC57B56A0A4E4BCEA5A870', '02:49', null);
INSERT INTO `videos` VALUES ('225', '143', '【郝斌C语言】- 143 指针之 23：动态内存分配举例(动态一维数组', 'http://player.youku.com/embed/XNjQ4MjAwNjY0', 'https://vthumb.ykimg.com/0541040852AC577A6A0A44554C03552E', '35:11', null);
INSERT INTO `videos` VALUES ('226', '165', '【郝斌C语言】- 165 枚举（上）', 'http://player.youku.com/embed/XNjQ4MjA2NDQw', 'https://vthumb.ykimg.com/0541040852AC57DF6A0A3F42BC16C529', '01:41', null);
INSERT INTO `videos` VALUES ('227', '161', '【郝斌C语言】- 161 指针优点大总结', 'http://player.youku.com/embed/XNjQ4MjA2NjQ0', 'https://vthumb.ykimg.com/0541040852AC59066A0A451E24F883F6', '12:31', null);
INSERT INTO `videos` VALUES ('228', '151', '【郝斌C语言】- 151 结构体之 1：为什么需要结构体和什么叫结构', 'http://player.youku.com/embed/XNjQ4MjA0MjM2', 'https://vthumb.ykimg.com/0541040852AC57A36A0A41237C08FB9C', '15:37', null);
INSERT INTO `videos` VALUES ('229', '149', '【郝斌C语言】- 149 指针之 29：动态内存可以跨函数使用详解', 'http://player.youku.com/embed/XNjQ4MjA0ODAw', 'https://vthumb.ykimg.com/0541040852AC58966A0A4604E06D5E93', '13:24', null);
INSERT INTO `videos` VALUES ('230', '160', '【郝斌C语言】- 160 结构体9：应该发送内容还是应该发送地址', 'http://player.youku.com/embed/XNjQ4MjA2MDY0', 'https://vthumb.ykimg.com/0541040852AC58366A0A4B1250DB3409', '08:48', null);
INSERT INTO `videos` VALUES ('231', '158', '【郝斌C语言】- 158 结构体7：复习上节课知识', 'http://player.youku.com/embed/XNjQ4MjA1NDQ4', 'https://vthumb.ykimg.com/0541040852AC57B66A0A4604E3A9D7D7', '08:09', null);
INSERT INTO `videos` VALUES ('232', '157', '【郝斌C语言】- 157 考前知识点概述', 'http://player.youku.com/embed/XNjQ4MjA0OTc2', 'https://vthumb.ykimg.com/0541040852AC570E6A0A3F42C0082E63', '04:39', null);
INSERT INTO `videos` VALUES ('233', '144', '【郝斌C语言】- 144 指针之 24-动态内存和静态内存的比较', 'http://player.youku.com/embed/XNjQ4MjAyMTk2', 'https://vthumb.ykimg.com/0541040852AC568C6A0A41238ABAA86B', '20:02', null);
INSERT INTO `videos` VALUES ('234', '148', '【郝斌C语言】- 148 指针之 28：静态变量不能跨函数使用详解', 'http://player.youku.com/embed/XNjQ4MjAzMTQw', 'https://vthumb.ykimg.com/0541040852AC56D96A0A445554E7C2AF', '12:26', null);
INSERT INTO `videos` VALUES ('235', '145', '【郝斌C语言】- 145 指针之 25：多级指针', 'http://player.youku.com/embed/XNjQ4MjAyNTg0', 'https://vthumb.ykimg.com/0541040852AC56A26A0A491BCC06B299', '16:06', null);
INSERT INTO `videos` VALUES ('236', '154', '【郝斌C语言】- 154 结构体4-结构体的赋值和初始化', 'http://player.youku.com/embed/XNjQ4MjA0MTQw', 'https://vthumb.ykimg.com/0541040852AC569C6A0A4F51FF98656B', '04:30', null);
INSERT INTO `videos` VALUES ('237', '156', '【郝斌C语言】- 156 结构体之 6：布置作业', 'http://player.youku.com/embed/XNjQ4MjA0NjUy', 'https://vthumb.ykimg.com/0541040852AC56956A0A4C4C3DA23B46', '02:05', null);
INSERT INTO `videos` VALUES ('238', '150', '【郝斌C语言】- 150 指针之 30：跨函数使用内存习题测试', 'http://player.youku.com/embed/XNjQ4MjAzMzE2', 'https://vthumb.ykimg.com/0541040852AC56336A0A491BD1C38E76', '05:50', null);
INSERT INTO `videos` VALUES ('239', '152', '【郝斌C语言】- 152 结构体之2：如何定义结构体', 'http://player.youku.com/embed/XNjQ4MjAzNjE2', 'https://vthumb.ykimg.com/0541040852AC563B6A0A3F42CE1E775E', '04:24', null);
INSERT INTO `videos` VALUES ('240', '147', '【郝斌C语言】- 147 指针之 27：闲聊', 'http://player.youku.com/embed/XNjQ4MjAyNjg4', 'https://vthumb.ykimg.com/0541040852AC55A36A0A406361C0EE61', '04:37', null);
INSERT INTO `videos` VALUES ('241', '153', '【郝斌C语言】- 153 结构体之3：怎样使用结构体变量概述', 'http://player.youku.com/embed/XNjQ4MjAzNjY0', 'https://vthumb.ykimg.com/0541040852AC561C6A0A4063729E0FAC', '02:34', null);
INSERT INTO `videos` VALUES ('242', '146', '【郝斌C语言】- 146 指针之 26-复习上节课知识', 'http://player.youku.com/embed/XNjQ4MjAyNjA4', 'https://vthumb.ykimg.com/0541040852AC55BB6A0A48588EC15A53', '04:42', null);
INSERT INTO `videos` VALUES ('243', '134', '【郝斌C语言】- 134 指针之 14：确定一个一维数组需要2个参数及', 'http://player.youku.com/embed/XNjQ4MTg2ODcy', 'https://vthumb.ykimg.com/0541040852AC515F6A0A41237073AB1E', '40:24', null);
INSERT INTO `videos` VALUES ('244', '141', '【郝斌C语言】- 141 指针之 21：malloc函数使用的简单介绍', 'http://player.youku.com/embed/XNjQ4MTkxNzEy', 'https://vthumb.ykimg.com/0541040852AC51236A0A4C4C3DBCB75B', '28:12', null);
INSERT INTO `videos` VALUES ('245', '137', '【郝斌C语言】- 137 指针之 17：何谓变量的地址 和 一个指针变量', 'http://player.youku.com/embed/XNjQ4MTkwMTM2', 'https://vthumb.ykimg.com/0541040852AC50336A0A3F42D183C2EF', '25:13', null);
INSERT INTO `videos` VALUES ('246', '142', '【郝斌C语言】- 142 指针之 22：malloc函数的用法(续)', 'http://player.youku.com/embed/XNjQ4MTkyMDg0', 'https://vthumb.ykimg.com/0541040852AC50776A0A406371B17DDB', '16:32', null);
INSERT INTO `videos` VALUES ('247', '139', '【郝斌C语言】- 139 指针之 19：传统数组的缺点', 'http://player.youku.com/embed/XNjQ4MTkwODg0', 'https://vthumb.ykimg.com/0541040852AC4FEA6A0A4744A2253828', '19:59', null);
INSERT INTO `videos` VALUES ('248', '126', '【郝斌C语言】- 126 指针之6：基本类型指针常见错误解析', 'http://player.youku.com/embed/XNjQ4MTgyNzgw', 'https://vthumb.ykimg.com/0541040852AC4CE56A0A4377CD8642E2', '26:26', null);
INSERT INTO `videos` VALUES ('249', '127', '【郝斌C语言】- 127 指针之7：经典指针程序_互换两个数字', 'http://player.youku.com/embed/XNjQ4MTgzMjE2', 'https://vthumb.ykimg.com/0541040852AC4D256A0A451E247A0AB6', '31:04', null);
INSERT INTO `videos` VALUES ('250', '138', '【郝斌C语言】- 138 指针之 18：动态内存分配概述', 'http://player.youku.com/embed/XNjQ4MTkwMzgw', 'https://vthumb.ykimg.com/0541040852AC4E316A0A4E4BCEAC89CB', '03:47', null);
INSERT INTO `videos` VALUES ('251', '140', '【郝斌C语言】- 140 指针之 20：为什么需要动态分配内存', 'http://player.youku.com/embed/XNjQ4MTkxMDA4', 'https://vthumb.ykimg.com/0541040852AC4E586A0A4604E2AD1853', '01:17', null);
INSERT INTO `videos` VALUES ('252', '129', '【郝斌C语言】- 129 指针之 9 复习前面所有指针知识 实参和形参', 'http://player.youku.com/embed/XNjQ4MTgzOTg0', 'https://vthumb.ykimg.com/0541040852AC4D926A0A4063602164A6', '34:59', null);
